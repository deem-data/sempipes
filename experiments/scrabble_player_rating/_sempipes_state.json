{
  "generated_code": [
    "\n# (Player mean score per game)\n# Usefulness: Captures player's average performance in scoring which is directly relevant for skill/rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440]\ndf['player_mean_score'] = df.groupby('nickname')['score'].transform('mean')\n\n# (Player win rate)\n# Usefulness: Encodes player's competitive success, which should correlate with higher rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'winner': [1, 1, 1]\ndf['player_win_rate'] = df.groupby('nickname')['winner'].transform('mean')\n\n# (Player mean points per turn)\n# Usefulness: Reflects efficiency and skill level; high rates suggest strong play.\n# Input samples: 'score': [335, 429, 440], 'total_turns': [13, 14, 14]\ndf['player_mean_points_per_turn'] = df.groupby('nickname').apply(lambda g: (g['score'].sum() / g['total_turns'].sum())).reindex(df.index).values\n\n# (Player games played count)\n# Usefulness: More games played may indicate experience; experience can be linked to rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid']\ndf['player_games_played'] = df.groupby('nickname')['game_id'].transform('nunique')\n\n# (Mean game duration per player)\n# Usefulness: Measures time management and/or play style, which can be linked to rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'game_duration_seconds': [674.84, 492.27, 350.86]\ndf['player_mean_game_duration'] = df.groupby('nickname')['game_duration_seconds'].transform('mean')\n\n# (Fraction of games played first)\n# Usefulness: May indicate player preference/skill in securing first position, which can impact rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'first': ['BetterBot', 'BetterBot', 'BetterBot']\ndf['player_fraction_games_first'] = (df['nickname'] == df['first']).groupby(df['nickname']).transform('mean')\n\n# (Mean first five turns points per player)\n# Usefulness: Initial strong performance suggests skill and aggression, often related to rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'first_five_turns_points': [122, 95, 136]\ndf['player_mean_first_five_pts'] = df.groupby('nickname')['first_five_turns_points'].transform('mean')\n\n# (Mean max points in a turn per player)\n# Usefulness: Shows player’s peak performance in a single turn; relevant for rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_points_turn': [68, 98, 103]\ndf['player_mean_max_turn_pts'] = df.groupby('nickname')['max_points_turn'].transform('mean')\n\n# (Mean min points in a turn per player)\n# Usefulness: Consistency can be important for high ratings; higher minimums indicate fewer blunders.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'min_points_turn': [8, 2, 13]\ndf['player_mean_min_turn_pts'] = df.groupby('nickname')['min_points_turn'].transform('mean')\n\n# (Player mean max_min_difference)\n# Usefulness: Indicates volatility in scoring; low volatility may relate to higher skill/rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_min_difference': [60, 96, 90]\ndf['player_mean_max_min_diff'] = df.groupby('nickname')['max_min_difference'].transform('mean')\n\n# (Player mean points per second)\n# Usefulness: Combines speed and effectiveness, providing a skill efficiency proxy.\n# Input samples: 'score': [335, 429, 440], 'game_duration_seconds': [674.84, 492.27, 350.86]\ndf['player_mean_points_per_second'] = df.groupby('nickname').apply(\n    lambda g: (g['score'].sum() / g['game_duration_seconds'].sum())\n).reindex(df.index).values\n\n# (Mean initial time seconds per player)\n# Usefulness: Captures preferred time controls and whether player selects/practices with faster/slower games.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'initial_time_seconds': [1200, 1200, 900]\ndf['player_mean_initial_time'] = df.groupby('nickname')['initial_time_seconds'].transform('mean')\n\n# (Mean increment seconds per player)\n# Usefulness: Reflects if player prefers time increments, which can impact play style, related to rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'increment_seconds': [0, 0, 0]\ndf['player_mean_increment'] = df.groupby('nickname')['increment_seconds'].transform('mean')\n\n# (Mean max overtime minutes per player)\n# Usefulness: May indicate if player is used to longer possible games, relevant to play style and rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_overtime_minutes': [1, 1, 5]\ndf['player_mean_overtime'] = df.groupby('nickname')['max_overtime_minutes'].transform('mean')\n\n# (Player fraction of games resigned)\n# Usefulness: High resignation rate can indicate lower skill or frustration, predictive of rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'game_end_reason': ['STANDARD', 'STANDARD', 'STANDARD']\ndf['player_fraction_resigned'] = (df['game_end_reason'] == 'RESIGNED').groupby(df['nickname']).transform('mean')\n# (Was player first in this game)\n# Usefulness: Captures whether the player had the advantage of the first move, which may affect their score and rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'first': ['BetterBot', 'BetterBot', 'BetterBot']\ndf['is_first_this_game'] = (df['nickname'] == df['first']).astype(int)\n\n# (Player mean score when first in game)\n# Usefulness: Measures player's ability to capitalize on playing first, which could signal high skill/rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_score_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'score'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player win rate as first)\n# Usefulness: Indicates ability to convert first-move advantage into victory, reflecting rating-relevant skill.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'winner': [1, 1, 1], 'is_first_this_game': [1, 0, 0]\ndf['player_win_rate_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'winner'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean score when not first)\n# Usefulness: Measures performance under less advantageous starting conditions; robust high scoring relates to high rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_score_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'score'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player win rate when not first)\n# Usefulness: Ability to win from second position suggests strong play, valuable for rating prediction.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'winner': [1, 1, 1], 'is_first_this_game': [1, 0, 0]\ndf['player_win_rate_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'winner'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Mean points per turn as first in game)\n# Usefulness: Indicates if the player is especially efficient when holding the first-move advantage.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_pts_per_turn_as_first'] = df.groupby('nickname').apply(\n    lambda g: (g.loc[g['is_first_this_game'] == 1, 'score'].sum() / g.loc[g['is_first_this_game'] == 1, 'total_turns'].sum())\n    if any(g['is_first_this_game'] == 1) and g.loc[g['is_first_this_game'] == 1, 'total_turns'].sum() > 0 else np.nan\n).reindex(df.index).values\n\n# (Mean points per turn as not first)\n# Usefulness: Shows ability to score efficiently despite not going first, may separate strong players.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_pts_per_turn_not_first'] = df.groupby('nickname').apply(\n    lambda g: (g.loc[g['is_first_this_game'] == 0, 'score'].sum() / g.loc[g['is_first_this_game'] == 0, 'total_turns'].sum())\n    if any(g['is_first_this_game'] == 0) and g.loc[g['is_first_this_game'] == 0, 'total_turns'].sum() > 0 else np.nan\n).reindex(df.index).values\n\n# (Player total unique opponents played)\n# Usefulness: Diversity of opponents could relate to rating reliability and player experience.\n# Input samples: 'game_id': [1, 1, 3], 'nickname': ['BetterBot', 'stevy', 'davidavid']\ndf['player_unique_opponents'] = df.groupby('nickname').apply(\n    lambda g: g.groupby('game_id')['nickname'].transform('count').count() - g['game_id'].nunique()\n).reindex(df.index).values\n\n# (Player mean score difference vs other player in game)\n# Usefulness: Dominance in terms of margin of victory or loss is highly relevant for rating.\n# Input samples: 'game_id': [1, 1, 3], 'score': [335, 429, 440]\nmean_score_diff = df.groupby('game_id')['score'].transform(lambda x: x - x.mean())\ndf['score_vs_opponent'] = mean_score_diff\n\n# (Player fraction of rated games)\n# Usefulness: Rated games more accurately reflect competitive play and skill; high rated fraction can signal serious players.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'rating_mode': ['CASUAL', 'CASUAL', 'RATED']\ndf['player_fraction_rated'] = (df['rating_mode'] == 'RATED').groupby(df['nickname']).transform('mean')\n\n# (Player mean game length in turns)\n# Usefulness: May indicate skill/style; efficient players may finish in fewer turns.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'total_turns': [13, 14, 14]\ndf['player_mean_game_turns'] = df.groupby('nickname')['total_turns'].transform('mean')\n\n# (Player diversity of lexicons used)\n# Usefulness: Ability/willingness to play multiple lexicons may indicate broader skill base.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'lexicon': ['NWL20', 'NWL20', 'CSW21']\ndf['player_lexicon_diversity'] = df.groupby('nickname')['lexicon'].transform('nunique')\n\n# (Player diversity of time controls used)\n# Usefulness: Comfort with multiple time controls may reflect flexibility and deeper experience.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'time_control_name': ['regular', 'regular', 'regular']\ndf['player_time_control_diversity'] = df.groupby('nickname')['time_control_name'].transform('nunique')\n\n# (Player mean score in rated games)\n# Usefulness: How well a player performs in rated (vs casual) games should be closely tied to rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440], 'rating_mode': ['CASUAL', 'CASUAL', 'RATED']\ndf['player_mean_score_rated'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['rating_mode'] == 'RATED', 'score'].mean() if any(g['rating_mode'] == 'RATED') else np.nan\n).reindex(df.index).values\n# (Player mean max points turn as first)\n# Usefulness: Assesses ability to achieve high single-turn scores when going first, which may correlate with strong openers and high rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_points_turn': [68, 98, 103], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_max_points_turn_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'max_points_turn'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean min points turn as first)\n# Usefulness: Consistency while going first; high minimums as first suggest fewer errors, possibly higher rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'min_points_turn': [8, 2, 13], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_min_points_turn_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'min_points_turn'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean max points turn not first)\n# Usefulness: Indicates ability to make high-scoring moves without first-move advantage—robust play indicator.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_points_turn': [68, 98, 103], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_max_points_turn_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'max_points_turn'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player mean min points turn not first)\n# Usefulness: Captures consistency regardless of order; higher minimums may indicate fewer mistakes when going second.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'min_points_turn': [8, 2, 13], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_min_points_turn_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'min_points_turn'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player mean max_min_difference as first)\n# Usefulness: Volatility in single-turn scores when first; less volatility may indicate stable, strong play.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_min_difference': [60, 96, 90], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_max_min_diff_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'max_min_difference'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean max_min_difference not first)\n# Usefulness: Stability/volatility in scores on non-first moves, potentially highlighting adaptable, skilled play.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_min_difference': [60, 96, 90], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_max_min_diff_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'max_min_difference'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player mean first five points as first)\n# Usefulness: Strong early play going first may be correlated with overall high skill/rating.\n# Input samples: 'first_five_turns_points': [122, 95, 136], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_first5pts_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'first_five_turns_points'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean first five points not first)\n# Usefulness: Shows ability to start strong even when not first; robust players may show little drop-off.\n# Input samples: 'first_five_turns_points': [122, 95, 136], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_first5pts_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'first_five_turns_points'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player mean game duration as first)\n# Usefulness: May indicate time-management style or confidence when going first, which could correlate to rating.\n# Input samples: 'game_duration_seconds': [674.84, 492.27, 350.86], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_game_duration_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'game_duration_seconds'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean game duration not first)\n# Usefulness: May indicate adaptability, strategic approach, or time stress when not first.\n# Input samples: 'game_duration_seconds': [674.84, 492.27, 350.86], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_game_duration_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'game_duration_seconds'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player ratio of mean points per turn as first vs not first)\n# Usefulness: Directly compares player's efficiency when first and not first; values near 1 indicate robustness.\n# Input samples: 'player_mean_pts_per_turn_as_first': [30.5, np.nan, np.nan], 'player_mean_pts_per_turn_not_first': [np.nan, 32.2, 31.4]\ndf['player_pts_per_turn_first_vs_not'] = (\n    df['player_mean_pts_per_turn_as_first'] / df['player_mean_pts_per_turn_not_first']\n)\n\n# (Player ratio of win rate as first vs not first)\n# Usefulness: Quantifies relative advantage (or lack thereof) when going first; high values may reflect more typical skill distributions.\n# Input samples: 'player_win_rate_as_first': [0.8, np.nan, np.nan], 'player_win_rate_not_first': [np.nan, 0.7, 0.6]\ndf['player_winrate_first_vs_not'] = (\n    df['player_win_rate_as_first'] / df['player_win_rate_not_first']\n)\n\n# (Player mean overtime minutes as first)\n# Usefulness: May indicate strategic time usage in advantageous (first) positions.\n# Input samples: 'max_overtime_minutes': [1, 1, 5], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_overtime_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'max_overtime_minutes'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean overtime minutes not first)\n# Usefulness: May indicate time pressure or defensive strategy when not first.\n# Input samples: 'max_overtime_minutes': [1, 1, 5], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_overtime_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'max_overtime_minutes'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n# (Player variance in score)\n# Usefulness: Indicates consistency in performance; lower variance may signal dependable high skill.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440]\ndf['player_score_var'] = df.groupby('nickname')['score'].transform('var')\n\n# (Player variance in points per turn)\n# Usefulness: Evaluates steadiness in point-scoring per turn; consistent players are often rated higher.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440], 'total_turns': [13, 14, 14]\ndf['points_per_turn'] = df['score'] / df['total_turns']\ndf['player_points_per_turn_var'] = df.groupby('nickname')['points_per_turn'].transform('var')\n\n# (Player variance in game duration)\n# Usefulness: Consistency of game pacing may correlate with experience and rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'game_duration_seconds': [674.84, 492.27, 350.86]\ndf['player_game_duration_var'] = df.groupby('nickname')['game_duration_seconds'].transform('var')\n\n# (Player variance in win rate over time)\n# Usefulness: Fluctuating win/loss patterns over games could indicate streakiness or improvement.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'winner': [1, 1, 1], 'created_at': ['2022-08-26 03:38:49', ...]\ndf['created_at_dt'] = pd.to_datetime(df['created_at'])\ndf['player_winrate_rolling_var'] = (\n    df.sort_values('created_at_dt')\n      .groupby('nickname')['winner']\n      .transform(lambda x: x.rolling(5, min_periods=1).mean().var())\n)\n\n# (Player median score)\n# Usefulness: Robust to outliers; median skill level correlates to rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440]\ndf['player_median_score'] = df.groupby('nickname')['score'].transform('median')\n\n# (Player median points per turn)\n# Usefulness: Robust measure of player's typical per-turn effectiveness.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'points_per_turn': [25.77, 30.64, 31.43]\ndf['player_median_points_per_turn'] = df.groupby('nickname')['points_per_turn'].transform('median')\n\n# (Player best score)\n# Usefulness: Shows player's top performance; high best-score may reflect high potential/peak rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440]\ndf['player_best_score'] = df.groupby('nickname')['score'].transform('max')\n\n# (Player worst score)\n# Usefulness: Lower worst scores may indicate fewer major mistakes, important for rating stability.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'score': [335, 429, 440]\ndf['player_worst_score'] = df.groupby('nickname')['score'].transform('min')\n\n# (Player fraction of games with zero min turn)\n# Usefulness: Frequency of turns with zero points may correlate with blunders and lower rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'min_points_turn': [8, 2, 13]\ndf['player_frac_games_zero_min_turn'] = (df['min_points_turn'] == 0).groupby(df['nickname']).transform('mean')\n\n# (Player mean score difference vs opponent in wins)\n# Usefulness: Margin of victory in wins is a strong indicator of dominance and rating.\n# Input samples: 'winner': [1, 1, 1], 'score_vs_opponent': [10, 25, -5]\ndf['player_mean_margin_win'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['winner'] == 1, 'score_vs_opponent'].mean() if any(g['winner'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean score difference vs opponent in losses)\n# Usefulness: Margin of defeat in losses; small losses indicate resilience, large losses signal weak play.\n# Input samples: 'winner': [1, 1, 1], 'score_vs_opponent': [10, 25, -5]\ndf['player_mean_margin_loss'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['winner'] == 0, 'score_vs_opponent'].mean() if any(g['winner'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player fraction of games with high max points turn, e.g. >70)\n# Usefulness: Ability to routinely make high-value plays, which is typical of higher-rated players.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_points_turn': [68, 98, 103]\ndf['player_frac_high_max_turn'] = (df['max_points_turn'] > 70).groupby(df['nickname']).transform('mean')\n\n# (Player fraction of games with low min points turn, e.g. <= 2)\n# Usefulness: Frequency of very low scoring turns; excessive frequency may reflect blundering or inexperience.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'min_points_turn': [8, 2, 13]\ndf['player_frac_low_min_turn'] = (df['min_points_turn'] <= 2).groupby(df['nickname']).transform('mean')\n\n# (Player average points per second as first)\n# Usefulness: Time efficiency while going first; can be a signal of confidence and skill.\n# Input samples: 'score': [335, 429, 440], 'game_duration_seconds': [674.84, 492.27, 350.86], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_pts_per_sec_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, ['score', 'game_duration_seconds']].assign(\n        pts_per_sec=lambda x: x['score'] / x['game_duration_seconds']\n    )['pts_per_sec'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player average points per second not first)\n# Usefulness: Time efficiency without first-move advantage; robust players may show less drop-off.\n# Input samples: 'score': [335, 429, 440], 'game_duration_seconds': [674.84, 492.27, 350.86], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_pts_per_sec_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, ['score', 'game_duration_seconds']].assign(\n        pts_per_sec=lambda x: x['score'] / x['game_duration_seconds']\n    )['pts_per_sec'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# Clean up helper column\ndf.drop(columns='points_per_turn', inplace=True)\ndf.drop(columns='created_at_dt', inplace=True)\n# (Player number of days active)\n# Usefulness: Measures longevity and engagement; longer activity may suggest experience and stable rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'created_at': ['2022-08-26 03:38:49', ...]\ndf['created_at_dt'] = pd.to_datetime(df['created_at'])\ndf['player_n_active_days'] = df.groupby('nickname')['created_at_dt'].transform(lambda x: (x.max() - x.min()).days + 1)\n\n# (Player average games per active day)\n# Usefulness: High game frequency per day may reflect engagement, focus, or streakiness, which could matter for rating.\n# Input samples: 'player_games_played': [12, 10, 8], 'player_n_active_days': [6, 5, 4]\ndf['player_games_per_day'] = df['player_games_played'] / df['player_n_active_days']\n\n# (Player number of unique days played)\n# Usefulness: Indicates sustained play as opposed to burst activity, informing experience/rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'created_at': ['2022-08-26 03:38:49', ...]\ndf['player_unique_days_played'] = df.groupby('nickname')['created_at_dt'].transform(lambda x: x.dt.date.nunique())\n\n# (Player fraction of days played out of total active days)\n# Usefulness: Measures consistency and regularity of play, which can be predictive of rating improvements.\n# Input samples: 'player_unique_days_played': [5, 4, 3], 'player_n_active_days': [6, 5, 4]\ndf['player_frac_days_played'] = df['player_unique_days_played'] / df['player_n_active_days']\n\n# (Player average time per turn)\n# Usefulness: Captures player’s pace; slower play may indicate more thoughtful or inexperienced play, both relevant to rating.\n# Input samples: 'game_duration_seconds': [674.84, 492.27, 350.86], 'total_turns': [13, 14, 14]\ndf['time_per_turn'] = df['game_duration_seconds'] / df['total_turns']\ndf['player_mean_time_per_turn'] = df.groupby('nickname')['time_per_turn'].transform('mean')\ndf.drop(columns='time_per_turn', inplace=True)\n\n# (Player average initial time per turn)\n# Usefulness: May reflect preferred game tempo and time management.\n# Input samples: 'initial_time_seconds': [1200, 900, 1200], 'total_turns': [13, 14, 14]\ndf['init_time_per_turn'] = df['initial_time_seconds'] / df['total_turns']\ndf['player_mean_init_time_per_turn'] = df.groupby('nickname')['init_time_per_turn'].transform('mean')\ndf.drop(columns='init_time_per_turn', inplace=True)\n\n# (Player average increment per turn)\n# Usefulness: Influence of increment on play style and outcomes.\n# Input samples: 'increment_seconds': [0, 0, 0], 'total_turns': [13, 14, 14]\ndf['increment_per_turn'] = df['increment_seconds'] / df['total_turns']\ndf['player_mean_increment_per_turn'] = df.groupby('nickname')['increment_per_turn'].transform('mean')\ndf.drop(columns='increment_per_turn', inplace=True)\n\n# (Player most common lexicon)\n# Usefulness: Specialization in a lexicon can relate to skill depth and hence rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'lexicon': ['NWL20', 'CSW21', 'NWL20']\ndf['player_main_lexicon'] = df.groupby('nickname')['lexicon'].transform(lambda x: x.mode().iat[0] if not x.mode().empty else x.iloc[0])\n\n# (Player most common time control)\n# Usefulness: Preference for certain time controls may shape rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'time_control_name': ['regular', 'regular', 'regular']\ndf['player_main_time_control'] = df.groupby('nickname')['time_control_name'].transform(lambda x: x.mode().iat[0] if not x.mode().empty else x.iloc[0])\n\n# (Player most common rating mode)\n# Usefulness: Indicates if player mostly plays rated or casual, which may reflect seriousness/skill.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'rating_mode': ['CASUAL', 'RATED', 'CASUAL']\ndf['player_main_rating_mode'] = df.groupby('nickname')['rating_mode'].transform(lambda x: x.mode().iat[0] if not x.mode().empty else x.iloc[0])\n\n# (Player most common overtime minutes)\n# Usefulness: May signal player’s preferred pace and time-pressure resilience.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'max_overtime_minutes': [1, 1, 5]\ndf['player_main_overtime'] = df.groupby('nickname')['max_overtime_minutes'].transform(lambda x: x.mode().iat[0] if not x.mode().empty else x.iloc[0])\n\n# (Player fraction of games played at their most common lexicon)\n# Usefulness: Indicates degree of specialization versus versatility.\n# Input samples: 'lexicon': ['NWL20', 'CSW21', 'NWL20'], 'player_main_lexicon': ['NWL20', 'NWL20', 'NWL20']\ndf['player_frac_main_lexicon'] = (df['lexicon'] == df['player_main_lexicon']).groupby(df['nickname']).transform('mean')\n\n# (Player fraction of games played at their most common time control)\n# Usefulness: Specialization in time control may impact rating.\n# Input samples: 'time_control_name': ['regular', 'regular', 'regular'], 'player_main_time_control': ['regular', 'regular', 'regular']\ndf['player_frac_main_time_control'] = (df['time_control_name'] == df['player_main_time_control']).groupby(df['nickname']).transform('mean')\n\n# (Player fraction of games played at their most common rating mode)\n# Usefulness: Consistency in competition type could reflect seriousness.\n# Input samples: 'rating_mode': ['CASUAL', 'RATED', 'CASUAL'], 'player_main_rating_mode': ['CASUAL', 'CASUAL', 'CASUAL']\ndf['player_frac_main_rating_mode'] = (df['rating_mode'] == df['player_main_rating_mode']).groupby(df['nickname']).transform('mean')\n\n# (Player fraction of games played at their most common overtime)\n# Usefulness: Consistency here may relate to comfort under specific overtime conditions.\n# Input samples: 'max_overtime_minutes': [1, 1, 5], 'player_main_overtime': [1, 1, 1]\ndf['player_frac_main_overtime'] = (df['max_overtime_minutes'] == df['player_main_overtime']).groupby(df['nickname']).transform('mean')\n\ndf.drop(columns='created_at_dt', inplace=True)\n# (Player mean time per turn as first)\n# Usefulness: Indicates if player uses more/less time per turn with first-move advantage, potentially correlated with skill/confidence.\n# Input samples: 'game_duration_seconds': [674.84, 492.27, 350.86], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['time_per_turn'] = df['game_duration_seconds'] / df['total_turns']\ndf['player_mean_time_per_turn_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'time_per_turn'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean time per turn not first)\n# Usefulness: Highlights differences in pace depending on play order, relevant for style/rating.\n# Input samples: 'game_duration_seconds': [674.84, 492.27, 350.86], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_time_per_turn_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'time_per_turn'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Ratio of mean time per turn as first to not first)\n# Usefulness: Directly compares time usage; high/low ratio may distinguish confidence or discomfort when not first.\n# Input samples: 'player_mean_time_per_turn_as_first': [40.3, np.nan, np.nan], 'player_mean_time_per_turn_not_first': [np.nan, 43.2, 41.7]\ndf['player_time_per_turn_first_vs_not'] = (\n    df['player_mean_time_per_turn_as_first'] / df['player_mean_time_per_turn_not_first']\n)\n\n# (Player mean initial time per turn as first)\n# Usefulness: Shows whether initial time allocation per turn is different when going first.\n# Input samples: 'initial_time_seconds': [1200, 900, 1200], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['init_time_per_turn'] = df['initial_time_seconds'] / df['total_turns']\ndf['player_mean_init_time_per_turn_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'init_time_per_turn'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean initial time per turn not first)\n# Usefulness: Differential strategy in time allocation based on play order.\n# Input samples: 'initial_time_seconds': [1200, 900, 1200], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_init_time_per_turn_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'init_time_per_turn'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Ratio of mean initial time per turn as first to not first)\n# Usefulness: Compares initial time allocation pattern, could be linked to rating-relevant confidence.\n# Input samples: 'player_mean_init_time_per_turn_as_first': [100, np.nan, np.nan], 'player_mean_init_time_per_turn_not_first': [np.nan, 110, 107]\ndf['player_init_time_per_turn_first_vs_not'] = (\n    df['player_mean_init_time_per_turn_as_first'] / df['player_mean_init_time_per_turn_not_first']\n)\n\n# (Player mean increment per turn as first)\n# Usefulness: Captures if increment strategies differ by play order.\n# Input samples: 'increment_seconds': [0, 0, 0], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['increment_per_turn'] = df['increment_seconds'] / df['total_turns']\ndf['player_mean_increment_per_turn_as_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 1, 'increment_per_turn'].mean() if any(g['is_first_this_game'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean increment per turn not first)\n# Usefulness: Segment by play order for more nuanced feature pattern.\n# Input samples: 'increment_seconds': [0, 0, 0], 'total_turns': [13, 14, 14], 'is_first_this_game': [1, 0, 0]\ndf['player_mean_increment_per_turn_not_first'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['is_first_this_game'] == 0, 'increment_per_turn'].mean() if any(g['is_first_this_game'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Ratio of mean increment per turn as first to not first)\n# Usefulness: Differential increment exploitation patterns by play order can be linked with rating.\n# Input samples: 'player_mean_increment_per_turn_as_first': [0.0, np.nan, np.nan], 'player_mean_increment_per_turn_not_first': [np.nan, 0.0, 0.0]\ndf['player_increment_per_turn_first_vs_not'] = (\n    df['player_mean_increment_per_turn_as_first'] / df['player_mean_increment_per_turn_not_first']\n)\n\ndf.drop(columns=['time_per_turn', 'init_time_per_turn', 'increment_per_turn'], inplace=True)\n# (Player fraction of wins by resignation)\n# Usefulness: Winning by resignation may indicate dominance or intimidation factor, which can be correlated with rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'winner': [1, 1, 1], 'game_end_reason': ['STANDARD', 'RESIGNED', 'STANDARD']\ndf['player_frac_win_by_resign'] = df.groupby('nickname').apply(\n    lambda g: ((g['winner'] == 1) & (g['game_end_reason'] == 'RESIGNED')).sum() / max((g['winner'] == 1).sum(), 1)\n).reindex(df.index).values\n\n# (Player fraction of losses by resignation)\n# Usefulness: Frequent resignation when losing may indicate frustration or lack of resilience, possibly associated with lower rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'winner': [1, 0, 1], 'game_end_reason': ['STANDARD', 'RESIGNED', 'STANDARD']\ndf['player_frac_loss_by_resign'] = df.groupby('nickname').apply(\n    lambda g: ((g['winner'] == 0) & (g['game_end_reason'] == 'RESIGNED')).sum() / max((g['winner'] == 0).sum(), 1)\n).reindex(df.index).values\n\n# (Player mean time per turn in won games)\n# Usefulness: Winning fast or slow may relate to confidence or thoroughness, affecting rating.\n# Input samples: 'game_duration_seconds': [674.84, 492.27, 350.86], 'total_turns': [13, 14, 14], 'winner': [1, 1, 0]\ndf['time_per_turn'] = df['game_duration_seconds'] / df['total_turns']\ndf['player_mean_time_per_turn_win'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['winner'] == 1, 'time_per_turn'].mean() if any(g['winner'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean time per turn in lost games)\n# Usefulness: Losing fast may signal poor resilience, while losing slow could mean strategic but unsuccessful play.\n# Input samples: 'game_duration_seconds': [674.84, 492.27, 350.86], 'total_turns': [13, 14, 14], 'winner': [1, 1, 0]\ndf['player_mean_time_per_turn_loss'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['winner'] == 0, 'time_per_turn'].mean() if any(g['winner'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player mean points per turn in won games)\n# Usefulness: Shows efficiency and dominance in winning games; high-scoring wins often reflect higher rating.\n# Input samples: 'score': [335, 429, 440], 'total_turns': [13, 14, 14], 'winner': [1, 1, 0]\ndf['points_per_turn'] = df['score'] / df['total_turns']\ndf['player_mean_pts_per_turn_win'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['winner'] == 1, 'points_per_turn'].mean() if any(g['winner'] == 1) else np.nan\n).reindex(df.index).values\n\n# (Player mean points per turn in lost games)\n# Usefulness: How well a player scores even when losing can distinguish solid players from weak ones.\n# Input samples: 'score': [335, 429, 440], 'total_turns': [13, 14, 14], 'winner': [1, 1, 0]\ndf['player_mean_pts_per_turn_loss'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['winner'] == 0, 'points_per_turn'].mean() if any(g['winner'] == 0) else np.nan\n).reindex(df.index).values\n\n# (Player mean score margin in resigned wins)\n# Usefulness: Winning by resignation with large margins can indicate overwhelming strength.\n# Input samples: 'winner': [1, 1, 0], 'game_end_reason': ['RESIGNED', 'STANDARD', 'RESIGNED'], 'score_vs_opponent': [40, 20, -30]\ndf['player_mean_margin_win_resign'] = df.groupby('nickname').apply(\n    lambda g: g.loc[(g['winner'] == 1) & (g['game_end_reason'] == 'RESIGNED'), 'score_vs_opponent'].mean()\n    if any((g['winner'] == 1) & (g['game_end_reason'] == 'RESIGNED')) else np.nan\n).reindex(df.index).values\n\n# (Player mean score margin in resigned losses)\n# Usefulness: Resigning with small/large deficits may reflect different psychological or strategic traits that relate to rating.\n# Input samples: 'winner': [1, 1, 0], 'game_end_reason': ['RESIGNED', 'STANDARD', 'RESIGNED'], 'score_vs_opponent': [40, 20, -30]\ndf['player_mean_margin_loss_resign'] = df.groupby('nickname').apply(\n    lambda g: g.loc[(g['winner'] == 0) & (g['game_end_reason'] == 'RESIGNED'), 'score_vs_opponent'].mean()\n    if any((g['winner'] == 0) & (g['game_end_reason'] == 'RESIGNED')) else np.nan\n).reindex(df.index).values\n\ndf.drop(columns=['time_per_turn', 'points_per_turn'], inplace=True)\n# (Player total number of resignations)\n# Usefulness: Frequent resignations (win or loss) might indicate temperament, risk tolerance, or competitive style, all of which can reflect on rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'game_end_reason': ['STANDARD', 'RESIGNED', 'RESIGNED']\ndf['player_total_resignations'] = df.groupby('nickname')['game_end_reason'].transform(lambda x: (x == 'RESIGNED').sum())\n\n# (Player total number of standard (non-resigned) wins)\n# Usefulness: Winning without opponent resignation may indicate ability to maintain advantage and close out games, reflecting skill and discipline.\n# Input samples: 'winner': [1, 1, 0], 'game_end_reason': ['STANDARD', 'RESIGNED', 'STANDARD']\ndf['player_total_standard_win'] = df.groupby('nickname').apply(\n    lambda g: ((g['winner'] == 1) & (g['game_end_reason'] == 'STANDARD')).sum()\n).reindex(df.index).values\n\n# (Player total number of resigned wins)\n# Usefulness: High number may indicate ability to force opponents to give up due to overwhelming play strength.\n# Input samples: 'winner': [1, 1, 0], 'game_end_reason': ['STANDARD', 'RESIGNED', 'STANDARD']\ndf['player_total_resigned_win'] = df.groupby('nickname').apply(\n    lambda g: ((g['winner'] == 1) & (g['game_end_reason'] == 'RESIGNED')).sum()\n).reindex(df.index).values\n\n# (Player total number of resigned losses)\n# Usefulness: High number of resigned losses may signal frustration, tilt, or lower resilience, predictive of lower rating.\n# Input samples: 'winner': [1, 0, 0], 'game_end_reason': ['RESIGNED', 'RESIGNED', 'STANDARD']\ndf['player_total_resigned_loss'] = df.groupby('nickname').apply(\n    lambda g: ((g['winner'] == 0) & (g['game_end_reason'] == 'RESIGNED')).sum()\n).reindex(df.index).values\n\n# (Player average turn number of max points turn)\n# Usefulness: Tendency to score big early or late may reveal play style (aggressive opener vs. endgame finisher) and its effect on rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'total_turns': [13, 14, 14], 'max_points_turn': [68, 98, 103]\ndf['max_points_turn_ratio'] = df['max_points_turn'] / df['score']\ndf['player_mean_max_points_turn_ratio'] = df.groupby('nickname')['max_points_turn_ratio'].transform('mean')\ndf.drop(columns='max_points_turn_ratio', inplace=True)\n\n# (Player average turn number of min points turn)\n# Usefulness: When blunders happen in a game (early/late) may be informative about focus or strategy.\n# Input samples: 'min_points_turn': [8, 2, 13], 'score': [335, 429, 440]\ndf['min_points_turn_ratio'] = df['min_points_turn'] / df['score']\ndf['player_mean_min_points_turn_ratio'] = df.groupby('nickname')['min_points_turn_ratio'].transform('mean')\ndf.drop(columns='min_points_turn_ratio', inplace=True)\n\n# (Player mean ratio of first five turns points to total score)\n# Usefulness: High ratios suggest aggressive/strong openers, which could be typical for high-rated players.\n# Input samples: 'first_five_turns_points': [122, 95, 136], 'score': [335, 429, 440]\ndf['first5_score_ratio'] = df['first_five_turns_points'] / df['score']\ndf['player_mean_first5_score_ratio'] = df.groupby('nickname')['first5_score_ratio'].transform('mean')\ndf.drop(columns='first5_score_ratio', inplace=True)\n\n# (Player mean ratio of max_min_difference to score)\n# Usefulness: Encodes relative volatility; high-rated players may have lower ratio due to steady scoring.\n# Input samples: 'max_min_difference': [60, 96, 90], 'score': [335, 429, 440]\ndf['max_min_diff_ratio'] = df['max_min_difference'] / df['score']\ndf['player_mean_max_min_diff_ratio'] = df.groupby('nickname')['max_min_diff_ratio'].transform('mean')\ndf.drop(columns='max_min_diff_ratio', inplace=True)\n\n# (Player mean turn efficiency: score divided by total_turns squared)\n# Usefulness: Rewards players who score disproportionately high in fewer turns (potentially more efficient).\n# Input samples: 'score': [335, 429, 440], 'total_turns': [13, 14, 14]\ndf['turn_efficiency'] = df['score'] / (df['total_turns']**2)\ndf['player_mean_turn_efficiency'] = df.groupby('nickname')['turn_efficiency'].transform('mean')\ndf.drop(columns='turn_efficiency', inplace=True)\n\n# (Player mean score standard deviation in rolling 5-game window)\n# Usefulness: Captures streakiness or inconsistency for recent games, which can relate to rating volatility.\n# Input samples: 'score': [335, 429, 440], 'created_at': ['2022-08-26 03:38:49', ...]\ndf['created_at_dt'] = pd.to_datetime(df['created_at'])\ndf['player_score_rolling_5std'] = (\n    df.sort_values('created_at_dt')\n      .groupby('nickname')['score']\n      .transform(lambda x: x.rolling(5, min_periods=1).std())\n)\ndf.drop(columns='created_at_dt', inplace=True)\n# (Player number of unique opponents played against)\n# Usefulness: Diversity of opposition can indicate experience and adaptability, which may correlate with rating.\n# Input samples: 'game_id': [1, 1, 3], 'nickname': ['BetterBot', 'stevy', 'davidavid']\ndf['opponent'] = df.groupby('game_id')['nickname'].transform(lambda x: x.iloc[::-1].values[0])\ndf['player_n_unique_opponents'] = df.groupby('nickname')['opponent'].transform('nunique')\n\n# (Player fraction of games against main opponent)\n# Usefulness: Over-specializing against a single opponent may inflate/deflate rating, while broad competition is a sign of true rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'opponent': ['stevy', 'BetterBot', 'BetterBot']\ndf['player_main_opponent'] = df.groupby('nickname')['opponent'].transform(lambda x: x.mode().iat[0] if not x.mode().empty else x.iloc[0])\ndf['player_frac_main_opponent'] = (df['opponent'] == df['player_main_opponent']).groupby(df['nickname']).transform('mean')\n\n# (Player win rate against main opponent)\n# Usefulness: If a player’s rating benefits from reliably beating a specific opponent, this could bias the regression.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'winner': [1, 0, 1]\ndf['player_winrate_vs_main_opponent'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['opponent'] == g['player_main_opponent'].iloc[0], 'winner'].mean()\n).reindex(df.index).values\n\n# (Player win rate against unique opponents)\n# Usefulness: Measures how broadly a player can beat different people—a hallmark of high rating.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'winner': [1, 0, 1]\ndf['player_winrate_vs_unique_opponents'] = df.groupby('nickname').apply(\n    lambda g: g.groupby('opponent')['winner'].mean().mean()\n).reindex(df.index).values\n\n# (Player mean score margin against main opponent)\n# Usefulness: Routinely beating main opponent by a wide margin can distort rating.\n# Input samples: 'score_vs_opponent': [10, -5, 7], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'player_main_opponent': ['stevy', 'BetterBot', 'BetterBot']\ndf['player_mean_margin_vs_main_opponent'] = df.groupby('nickname').apply(\n    lambda g: g.loc[g['opponent'] == g['player_main_opponent'].iloc[0], 'score_vs_opponent'].mean()\n).reindex(df.index).values\n\n# (Player mean score margin vs unique opponents)\n# Usefulness: Indicates dominance across different matchups, which is more predictive of rating.\n# Input samples: 'score_vs_opponent': [10, -5, 7], 'opponent': ['stevy', 'BetterBot', 'BetterBot']\ndf['player_mean_margin_vs_unique_opponents'] = df.groupby('nickname').apply(\n    lambda g: g.groupby('opponent')['score_vs_opponent'].mean().mean()\n).reindex(df.index).values\n\n# (Player games played against main opponent)\n# Usefulness: High counts may reflect rivalry or practice, affecting rating volatility.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'player_main_opponent': ['stevy', 'BetterBot', 'BetterBot']\ndf['player_games_vs_main_opponent'] = df.groupby('nickname').apply(\n    lambda g: (g['opponent'] == g['player_main_opponent'].iloc[0]).sum()\n).reindex(df.index).values\n\n# (Player games played vs unique opponents)\n# Usefulness: High numbers signal depth of experience.\n# Input samples: 'nickname': ['BetterBot', 'stevy', 'davidavid'], 'opponent': ['stevy', 'BetterBot', 'BetterBot']\ndf['player_games_vs_unique_opponents'] = df.groupby('nickname').apply(\n    lambda g: g.groupby('opponent').size().mean()\n).reindex(df.index).values\n\n# (Player mean score as first vs main opponent)\n# Usefulness: Performance as first vs rival may signal confidence and skill.\n# Input samples: 'is_first_this_game': [1, 0, 1], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'player_main_opponent': ['stevy', 'BetterBot', 'BetterBot'], 'score': [335, 429, 440]\ndf['player_mean_score_as_first_vs_main_opponent'] = df.groupby('nickname').apply(\n    lambda g: g.loc[(g['is_first_this_game'] == 1) & (g['opponent'] == g['player_main_opponent'].iloc[0]), 'score'].mean()\n    if any((g['is_first_this_game'] == 1) & (g['opponent'] == g['player_main_opponent'].iloc[0])) else np.nan\n).reindex(df.index).values\n\n# (Player mean score not first vs main opponent)\n# Usefulness: Performance from second play order vs principal opponent.\n# Input samples: 'is_first_this_game': [1, 0, 1], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'player_main_opponent': ['stevy', 'BetterBot', 'BetterBot'], 'score': [335, 429, 440]\ndf['player_mean_score_not_first_vs_main_opponent'] = df.groupby('nickname').apply(\n    lambda g: g.loc[(g['is_first_this_game'] == 0) & (g['opponent'] == g['player_main_opponent'].iloc[0]), 'score'].mean()\n    if any((g['is_first_this_game'] == 0) & (g['opponent'] == g['player_main_opponent'].iloc[0])) else np.nan\n).reindex(df.index).values\n\n# (Player win rate as first vs main opponent)\n# Usefulness: Shows player's ability to win when first against their most frequent rival.\n# Input samples: 'is_first_this_game': [1, 0, 1], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'player_main_opponent': ['stevy', 'BetterBot', 'BetterBot'], 'winner': [1, 1, 0]\ndf['player_winrate_as_first_vs_main_opponent'] = df.groupby('nickname').apply(\n    lambda g: g.loc[(g['is_first_this_game'] == 1) & (g['opponent'] == g['player_main_opponent'].iloc[0]), 'winner'].mean()\n    if any((g['is_first_this_game'] == 1) & (g['opponent'] == g['player_main_opponent'].iloc[0])) else np.nan\n).reindex(df.index).values\n\n# (Player win rate not first vs main opponent)\n# Usefulness: As above, but without first-move advantage.\n# Input samples: 'is_first_this_game': [1, 0, 1], 'opponent': ['stevy', 'BetterBot', 'BetterBot'], 'player_main_opponent': ['stevy', 'BetterBot', 'BetterBot'], 'winner': [1, 1, 0]\ndf['player_winrate_not_first_vs_main_opponent'] = df.groupby('nickname').apply(\n    lambda g: g.loc[(g['is_first_this_game'] == 0) & (g['opponent'] == g['player_main_opponent'].iloc[0]), 'winner'].mean()\n    if any((g['is_first_this_game'] == 0) & (g['opponent'] == g['player_main_opponent'].iloc[0])) else np.nan\n).reindex(df.index).values\n\ndf.drop(columns=['opponent', 'player_main_opponent'], inplace=True)\n"
  ]
}
