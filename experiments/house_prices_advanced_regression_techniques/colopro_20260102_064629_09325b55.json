"{\"sempipes_config\": {\"llm_for_code_generation\": {\"name\": \"gemini/gemini-2.5-flash\", \"parameters\": {\"temperature\": 2.0}}, \"llm_for_batch_processing\": {\"name\": \"ollama/gpt-oss:120b\", \"parameters\": {\"api_base\": \"http://localhost:11434\", \"temperature\": 0.0}}, \"batch_size_for_batch_processing\": 20}, \"optimizer_args\": {\"operator_name\": \"house_features\", \"num_trials\": 24, \"scoring\": \"neg_root_mean_squared_log_error\", \"cv\": \"5\", \"num_hpo_iterations_per_trial\": 10}, \"outcomes\": [{\"search_node\": {\"trial\": 0, \"parent_trial\": null, \"memory\": [], \"predefined_state\": {\"generated_code\": []}, \"parent_score\": null, \"inspirations\": []}, \"state\": {\"generated_code\": []}, \"score\": -0.11561350952648, \"memory_update\": \"\"}, {\"search_node\": {\"trial\": 1, \"parent_trial\": 0, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}], \"predefined_state\": null, \"parent_score\": -0.11561350952648, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\"]}, \"score\": -0.11564900906267117, \"memory_update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\"}, {\"search_node\": {\"trial\": 2, \"parent_trial\": 0, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}], \"predefined_state\": null, \"parent_score\": -0.11561350952648, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\"]}, \"score\": -0.11561350952648, \"memory_update\": \"\"}, {\"search_node\": {\"trial\": 3, \"parent_trial\": 0, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}], \"predefined_state\": null, \"parent_score\": -0.11561350952648, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\"]}, \"score\": -0.11561350952648, \"memory_update\": \"\"}, {\"search_node\": {\"trial\": 4, \"parent_trial\": 2, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}], \"predefined_state\": null, \"parent_score\": -0.11561350952648, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# (TotalSF)\\n# Usefulness: Represents the combined total finished square footage of the above-grade living area and the basement, which is a major determinant of house value.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Represents the total number of bathrooms, including full and half, and distinguishing between above-grade and basement bathrooms by assigning half bathrooms a weight of 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Indicates how old the house was at the time of sale. Older houses might command different prices or require more maintenance.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Indicates the time elapsed since the last major remodel or addition. More recent remodels generally increase house value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (HasBsmt)\\n# Usefulness: A binary indicator if the property has a basement, which adds significant utility and storage space.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (HasFireplace)\\n# Usefulness: A binary indicator if the property has a fireplace, often considered a desirable amenity.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (HasGarage)\\n# Usefulness: A binary indicator if the property has a garage, which adds value for parking and storage.\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (HasPool)\\n# Usefulness: A binary indicator if the property has a pool, a high-value amenity though less common.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (TotalPorchArea)\\n# Usefulness: Combines all types of outdoor porch and deck areas, representing additional living or leisure space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Remodeled)\\n# Usefulness: A binary indicator if the house has undergone remodeling since its original construction, which often correlates with improved condition and higher value.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAge)\\n# Usefulness: The age of the garage at the time of sale. An older garage might be in poorer condition or of outdated construction. NaN values for GarageYrBlt are imputed with the House Age (if there is a garage), else 0 if no garage, and the AgeAtSale used for comparison. If GarageYrBlt is NaN and there is a garage (GarageCars>0), use YearBuilt, else use 0. If GarageCars is 0, set to 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageCars': [1, 3, 1]\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[df['GarageCars'] == 0, 'GarageAge'] = 0 # No garage means age 0\\n\\n# Define mappings for ordinal categorical features\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\nbsmt_quality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nexposure_mapping = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nbsmt_fin_type_mapping = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\ngarage_finish_mapping = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no garage, treated as 0 score\\n\\n# (ExterQual_Score)\\n# Usefulness: Converts the ordinal categorical exterior quality into a numerical scale, allowing it to be used directly in regression models. 'NA' means no information/zero quality.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_mapping).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Converts the ordinal categorical exterior condition into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_mapping).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Converts the ordinal categorical kitchen quality into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_mapping).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Converts the ordinal categorical basement height quality into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Converts the ordinal categorical basement condition into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Converts the ordinal categorical heating quality into a numerical scale.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_mapping).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Converts the ordinal categorical fireplace quality into a numerical scale, with 'NA' mapping to 0 for no fireplace.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageQual_Score)\\n# Usefulness: Converts the ordinal categorical garage quality into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Score'] = df['GarageQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageCond_Score)\\n# Usefulness: Converts the ordinal categorical garage condition into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Score'] = df['GarageCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts the ordinal categorical pool quality into a numerical scale. Given 'PoolQC' has NaN-freq [100%], if the column exists, it will correctly map NaNs to 0. If it doesn't exist, this statement should implicitly handle it if the environment is strict about non-existent columns. As it failed before, explicitly setting a default is safer for error handling.\\n# Input samples: 'PoolQC': [nan, nan, nan]\\n# Corrected handling: Since 'PoolQC' has 100% NaN frequency and caused KeyError, it will be skipped from being explicitly mapped to avoid the error. This effectively means 'PoolQC_Score' remains at a default of 0 if the column truly isn't available, or will effectively be 0 for all rows if it does exist and only contains NaNs.\\n# Assuming the intention for a 100% NaN column is for it to effectively contribute zero, this omission achieves the same outcome while resolving the error.\\nif 'PoolQC' in df.columns: # Check explicitly for column existence\\n    df['PoolQC_Score'] = df['PoolQC'].map(bsmt_quality_mapping).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0 # Default to 0 if the column is entirely absent or contains no information\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Converts the ordinal categorical basement exposure into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_mapping).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 1 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (BsmtFinType2_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 2 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Score'] = df['BsmtFinType2'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Converts the ordinal categorical garage interior finish into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_mapping).fillna(0)\\n\\n# (Neighborhood_Quality_Interaction)\\n# Usefulness: Combines the house's overall quality rating with its neighborhood, assuming some neighborhoods inherently have higher quality expectations. This captures interaction effects between two important factors.\\n# Input samples: 'OverallQual': [5, 8, 5], 'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']\\nneighborhood_quality_mapping = df.groupby('Neighborhood')['OverallQual'].transform('mean')\\ndf['Neighborhood_Quality_Interaction'] = df['OverallQual'] * neighborhood_quality_mapping\\n\\n# (LotSizeProduct)\\n# Usefulness: Combines the linear feet of street connection with the total lot area, which might indicate more prominent or accessible properties with larger plots.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0], 'LotArea': [10000, 14541, 4500]\\ndf['LotSizeProduct'] = df['LotFrontage'].fillna(0) * df['LotArea']\\n\\n# (TotalFlrSF)\\n# Usefulness: Represents the total square footage across all floors (1st, 2nd, and low quality finished), offering a comprehensive measure of usable living space above ground.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'LowQualFinSF': [0, 0, 0]\\ndf['TotalFlrSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['LowQualFinSF']\\n\\n# (ExteriorQualCond)\\n# Usefulness: Combines the quality and condition of the exterior materials, offering a holistic view of the outside's state, which impacts curb appeal and maintenance costs.\\n# Input samples: 'ExterQual_Score': [3, 4, 3], 'ExterCond_Score': [3, 4, 3]\\ndf['ExteriorQualCond'] = df['ExterQual_Score'] + df['ExterCond_Score']\\n\\n# (HasMasVnr)\\n# Usefulness: A binary indicator if the house has masonry veneer, which can be an aesthetic upgrade and contribute to a higher appraisal value.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Quality_Overall_Ratio)\\n# Usefulness: Divides the general overall quality by the overall condition, highlighting houses where quality might be higher than current condition (implying potential for restoration) or vice-versa.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Quality_Overall_Ratio'] = df['OverallQual'] / df['OverallCond']\\n\\n# (AvgRoomSF)\\n# Usefulness: Calculates the average square footage per room above grade (excluding bathrooms). This gives a sense of room spaciousness.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd']\\n# Replace infinite values (if TotRmsAbvGrd is 0) with 0 for meaningful representation in a regression context.\\ndf['AvgRoomSF'] = df['AvgRoomSF'].replace([np.inf, -np.inf], 0).fillna(0)\\n\\n# (YearBuiltCategory)\\n# Usefulness: Categorizes houses into broader age groups (e.g., 'New', 'Recent', 'Old', 'VeryOld') which might capture generational architectural styles or construction standards, and simplify a potentially non-linear relationship.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932]\\ndf['YearBuiltCategory'] = pd.cut(df['YearBuilt'], bins=[0, 1940, 1970, 1995, 2010, np.inf], labels=['Pre1940', '1940-1969', '1970-1994', '1995-2009', 'Post2010'])\\n\\n# (BedroomBathroomRatio)\\n# Usefulness: Indicates the proportion of bedrooms to bathrooms. This might be important for family homes or larger properties where an equal balance or specific ratio is preferred.\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotalBathrooms': [2.0, 3.5, 1.0]\\ndf['BedroomBathroomRatio'] = df['BedroomAbvGr'] / df['TotalBathrooms']\\ndf['BedroomBathroomRatio'] = df['BedroomBathroomRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where TotalBathrooms might be 0\\n\\n# (GarageDensity)\\n# Usefulness: Represents the car capacity per square foot of garage area, which can indicate if a garage is more compact or spacious per vehicle.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageDensity'] = df['GarageCars'] / df['GarageArea']\\ndf['GarageDensity'] = df['GarageDensity'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GarageArea might be 0\\n\\n# (PorchToGrLivRatio)\\n# Usefulness: Relates the total porch/deck area to the above-grade living area, providing insight into the relative outdoor living space compared to indoor living space.\\n# Input samples: 'TotalPorchArea': [165, 264, 56], 'GrLivArea': [1144, 2520, 1520]\\ndf['PorchToGrLivRatio'] = df['TotalPorchArea'] / df['GrLivArea']\\ndf['PorchToGrLivRatio'] = df['PorchToGrLivRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (FireplacesPerGrLivArea)\\n# Usefulness: The ratio of fireplaces to the living area. This can indicate luxury or architectural features for the given size of the house.\\n# Input samples: 'Fireplaces': [1, 1, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['FireplacesPerGrLivArea'] = df['Fireplaces'] / df['GrLivArea']\\ndf['FireplacesPerGrLivArea'] = df['FireplacesPerGrLivArea'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (IsNewBuild)\\n# Usefulness: A binary indicator for houses sold in the same year they were built, often commanding premium prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YrSold': [2009, 2006, 2009]\\ndf['IsNewBuild'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: A binary indicator for properties having a second floor. This greatly impacts the house's style, footprint, and potentially value.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalSquareFootageRank)\\n# Usefulness: Ranks houses based on their total square footage. This helps capture non-linear effects of size by categorizing it relative to other houses.\\n# Input samples: 'TotalSF': [864, 1338, 793]\\ndf['TotalSquareFootageRank'] = df['TotalSF'].rank(method='dense')\\n\\n# (BsmtFinSF1Ratio)\\n# Usefulness: The ratio of finished basement area Type 1 to the total basement area. Indicates how much of the basement is dedicated to higher quality finished living space.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1'] / df['TotalBsmtSF']\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1Ratio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\\n# (LivAreaToLotAreaRatio)\\n# Usefulness: Represents the proportion of above-grade living area to the total lot area, which can indicate building density on the plot or remaining yard space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\ndf['LivAreaToLotAreaRatio'] = df['LivAreaToLotAreaRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\"]}, \"score\": -0.13104060995676203, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# (TotalSF)\\n# Usefulness: Represents the combined total finished square footage of the above-grade living area and the basement, which is a major determinant of house value.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Represents the total number of bathrooms, including full and half, and distinguishing between above-grade and basement bathrooms by assigning half bathrooms a weight of 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Indicates how old the house was at the time of sale. Older houses might command different prices or require more maintenance.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Indicates the time elapsed since the last major remodel or addition. More recent remodels generally increase house value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (HasBsmt)\\n# Usefulness: A binary indicator if the property has a basement, which adds significant utility and storage space.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (HasFireplace)\\n# Usefulness: A binary indicator if the property has a fireplace, often considered a desirable amenity.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (HasGarage)\\n# Usefulness: A binary indicator if the property has a garage, which adds value for parking and storage.\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (HasPool)\\n# Usefulness: A binary indicator if the property has a pool, a high-value amenity though less common.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (TotalPorchArea)\\n# Usefulness: Combines all types of outdoor porch and deck areas, representing additional living or leisure space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Remodeled)\\n# Usefulness: A binary indicator if the house has undergone remodeling since its original construction, which often correlates with improved condition and higher value.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAge)\\n# Usefulness: The age of the garage at the time of sale. An older garage might be in poorer condition or of outdated construction. NaN values for GarageYrBlt are imputed with the House Age (if there is a garage), else 0 if no garage, and the AgeAtSale used for comparison. If GarageYrBlt is NaN and there is a garage (GarageCars>0), use YearBuilt, else use 0. If GarageCars is 0, set to 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageCars': [1, 3, 1]\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[df['GarageCars'] == 0, 'GarageAge'] = 0 # No garage means age 0\\n\\n# Define mappings for ordinal categorical features\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\nbsmt_quality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nexposure_mapping = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nbsmt_fin_type_mapping = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\ngarage_finish_mapping = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no garage, treated as 0 score\\n\\n# (ExterQual_Score)\\n# Usefulness: Converts the ordinal categorical exterior quality into a numerical scale, allowing it to be used directly in regression models. 'NA' means no information/zero quality.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_mapping).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Converts the ordinal categorical exterior condition into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_mapping).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Converts the ordinal categorical kitchen quality into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_mapping).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Converts the ordinal categorical basement height quality into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Converts the ordinal categorical basement condition into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Converts the ordinal categorical heating quality into a numerical scale.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_mapping).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Converts the ordinal categorical fireplace quality into a numerical scale, with 'NA' mapping to 0 for no fireplace.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageQual_Score)\\n# Usefulness: Converts the ordinal categorical garage quality into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Score'] = df['GarageQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageCond_Score)\\n# Usefulness: Converts the ordinal categorical garage condition into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Score'] = df['GarageCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts the ordinal categorical pool quality into a numerical scale. Given 'PoolQC' has NaN-freq [100%], if the column exists, it will correctly map NaNs to 0. If it doesn't exist, this statement should implicitly handle it if the environment is strict about non-existent columns. As it failed before, explicitly setting a default is safer for error handling.\\n# Input samples: 'PoolQC': [nan, nan, nan]\\n# Corrected handling: Since 'PoolQC' has 100% NaN frequency and caused KeyError, it will be skipped from being explicitly mapped to avoid the error. This effectively means 'PoolQC_Score' remains at a default of 0 if the column truly isn't available, or will effectively be 0 for all rows if it does exist and only contains NaNs.\\n# Assuming the intention for a 100% NaN column is for it to effectively contribute zero, this omission achieves the same outcome while resolving the error.\\nif 'PoolQC' in df.columns: # Check explicitly for column existence\\n    df['PoolQC_Score'] = df['PoolQC'].map(bsmt_quality_mapping).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0 # Default to 0 if the column is entirely absent or contains no information\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Converts the ordinal categorical basement exposure into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_mapping).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 1 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (BsmtFinType2_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 2 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Score'] = df['BsmtFinType2'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Converts the ordinal categorical garage interior finish into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_mapping).fillna(0)\\n\\n# (Neighborhood_Quality_Interaction)\\n# Usefulness: Combines the house's overall quality rating with its neighborhood, assuming some neighborhoods inherently have higher quality expectations. This captures interaction effects between two important factors.\\n# Input samples: 'OverallQual': [5, 8, 5], 'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']\\nneighborhood_quality_mapping = df.groupby('Neighborhood')['OverallQual'].transform('mean')\\ndf['Neighborhood_Quality_Interaction'] = df['OverallQual'] * neighborhood_quality_mapping\\n\\n# (LotSizeProduct)\\n# Usefulness: Combines the linear feet of street connection with the total lot area, which might indicate more prominent or accessible properties with larger plots.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0], 'LotArea': [10000, 14541, 4500]\\ndf['LotSizeProduct'] = df['LotFrontage'].fillna(0) * df['LotArea']\\n\\n# (TotalFlrSF)\\n# Usefulness: Represents the total square footage across all floors (1st, 2nd, and low quality finished), offering a comprehensive measure of usable living space above ground.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'LowQualFinSF': [0, 0, 0]\\ndf['TotalFlrSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['LowQualFinSF']\\n\\n# (ExteriorQualCond)\\n# Usefulness: Combines the quality and condition of the exterior materials, offering a holistic view of the outside's state, which impacts curb appeal and maintenance costs.\\n# Input samples: 'ExterQual_Score': [3, 4, 3], 'ExterCond_Score': [3, 4, 3]\\ndf['ExteriorQualCond'] = df['ExterQual_Score'] + df['ExterCond_Score']\\n\\n# (HasMasVnr)\\n# Usefulness: A binary indicator if the house has masonry veneer, which can be an aesthetic upgrade and contribute to a higher appraisal value.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Quality_Overall_Ratio)\\n# Usefulness: Divides the general overall quality by the overall condition, highlighting houses where quality might be higher than current condition (implying potential for restoration) or vice-versa.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Quality_Overall_Ratio'] = df['OverallQual'] / df['OverallCond']\\n\\n# (AvgRoomSF)\\n# Usefulness: Calculates the average square footage per room above grade (excluding bathrooms). This gives a sense of room spaciousness.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd']\\n# Replace infinite values (if TotRmsAbvGrd is 0) with 0 for meaningful representation in a regression context.\\ndf['AvgRoomSF'] = df['AvgRoomSF'].replace([np.inf, -np.inf], 0).fillna(0)\\n\\n# (YearBuiltCategory)\\n# Usefulness: Categorizes houses into broader age groups (e.g., 'New', 'Recent', 'Old', 'VeryOld') which might capture generational architectural styles or construction standards, and simplify a potentially non-linear relationship.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932]\\ndf['YearBuiltCategory'] = pd.cut(df['YearBuilt'], bins=[0, 1940, 1970, 1995, 2010, np.inf], labels=['Pre1940', '1940-1969', '1970-1994', '1995-2009', 'Post2010'])\\n\\n# (BedroomBathroomRatio)\\n# Usefulness: Indicates the proportion of bedrooms to bathrooms. This might be important for family homes or larger properties where an equal balance or specific ratio is preferred.\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotalBathrooms': [2.0, 3.5, 1.0]\\ndf['BedroomBathroomRatio'] = df['BedroomAbvGr'] / df['TotalBathrooms']\\ndf['BedroomBathroomRatio'] = df['BedroomBathroomRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where TotalBathrooms might be 0\\n\\n# (GarageDensity)\\n# Usefulness: Represents the car capacity per square foot of garage area, which can indicate if a garage is more compact or spacious per vehicle.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageDensity'] = df['GarageCars'] / df['GarageArea']\\ndf['GarageDensity'] = df['GarageDensity'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GarageArea might be 0\\n\\n# (PorchToGrLivRatio)\\n# Usefulness: Relates the total porch/deck area to the above-grade living area, providing insight into the relative outdoor living space compared to indoor living space.\\n# Input samples: 'TotalPorchArea': [165, 264, 56], 'GrLivArea': [1144, 2520, 1520]\\ndf['PorchToGrLivRatio'] = df['TotalPorchArea'] / df['GrLivArea']\\ndf['PorchToGrLivRatio'] = df['PorchToGrLivRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (FireplacesPerGrLivArea)\\n# Usefulness: The ratio of fireplaces to the living area. This can indicate luxury or architectural features for the given size of the house.\\n# Input samples: 'Fireplaces': [1, 1, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['FireplacesPerGrLivArea'] = df['Fireplaces'] / df['GrLivArea']\\ndf['FireplacesPerGrLivArea'] = df['FireplacesPerGrLivArea'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (IsNewBuild)\\n# Usefulness: A binary indicator for houses sold in the same year they were built, often commanding premium prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YrSold': [2009, 2006, 2009]\\ndf['IsNewBuild'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: A binary indicator for properties having a second floor. This greatly impacts the house's style, footprint, and potentially value.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalSquareFootageRank)\\n# Usefulness: Ranks houses based on their total square footage. This helps capture non-linear effects of size by categorizing it relative to other houses.\\n# Input samples: 'TotalSF': [864, 1338, 793]\\ndf['TotalSquareFootageRank'] = df['TotalSF'].rank(method='dense')\\n\\n# (BsmtFinSF1Ratio)\\n# Usefulness: The ratio of finished basement area Type 1 to the total basement area. Indicates how much of the basement is dedicated to higher quality finished living space.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1'] / df['TotalBsmtSF']\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1Ratio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\\n# (LivAreaToLotAreaRatio)\\n# Usefulness: Represents the proportion of above-grade living area to the total lot area, which can indicate building density on the plot or remaining yard space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\ndf['LivAreaToLotAreaRatio'] = df['LivAreaToLotAreaRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\"}, {\"search_node\": {\"trial\": 5, \"parent_trial\": 3, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}], \"predefined_state\": null, \"parent_score\": -0.11561350952648, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import pandas as pd\\nimport numpy as np\\n\\n# (Exterior Quality - Encoded)\\n# Usefulness: Translates the ordinal quality of the material on the exterior into a numerical scale, providing a direct, quantitative measure for the regression model to associate with SalePrice. Higher quality generally means higher price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Enc'] = df['ExterQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Exterior Condition - Encoded)\\n# Usefulness: Converts the ordinal condition of the exterior materials into a numerical scale, allowing the model to weigh this factor in pricing. Better condition typically indicates higher value.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Enc'] = df['ExterCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Basement Quality - Encoded)\\n# Usefulness: Represents the quality/height of the basement using a numerical scale. Basements significantly impact property value, and this encoding allows the model to directly use this hierarchical information. 'NA' implies no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Enc'] = df['BsmtQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Condition - Encoded)\\n# Usefulness: Numerically quantifies the general condition of the basement, with 'NA' indicating no basement. A well-maintained basement is a positive asset, and this feature helps capture that impact on price.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Enc'] = df['BsmtCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Heating Quality and Condition - Encoded)\\n# Usefulness: Transforms the ordinal rating of heating quality into a numerical feature. Excellent heating systems add more value than poor ones.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Enc'] = df['HeatingQC'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Kitchen Quality - Encoded)\\n# Usefulness: Encodes the quality of the kitchen, which is a major factor in home valuation. A higher quality kitchen corresponds to a higher potential sale price.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Enc'] = df['KitchenQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Fireplace Quality - Encoded)\\n# Usefulness: Converts fireplace quality into a numerical score, with 'NA' signifying no fireplace. Fireplaces are desirable features that influence appeal and price.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Enc'] = df['FireplaceQu'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Quality - Encoded)\\n# Usefulness: Numerically ranks the quality of the garage, where 'NA' means no garage. Garage quality is important for perceived utility and value.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Enc'] = df['GarageQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Condition - Encoded)\\n# Usefulness: Transforms garage condition into a numerical score. Similar to quality, the condition reflects maintenance and functionality, influencing buyer perception and price.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Enc'] = df['GarageCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Lot Shape - Encoded)\\n# Usefulness: Converts the ordinal LotShape categories into a numerical scale where 'Reg' (regular) is most desirable and 'IR3' (irregular) is least. This allows the model to understand the appeal of the lot shape.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['LotShape_Enc'] = df['LotShape'].map({'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}).fillna(0).astype(int)\\n\\n# (Basement Exposure - Encoded)\\n# Usefulness: Ordinally maps basement exposure to a numerical value. Good exposure means more natural light and potential for living space, increasing value. 'NA' means no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Enc'] = df['BsmtExposure'].map({'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 1 - Encoded)\\n# Usefulness: Encodes the primary type of finished basement area. 'GLQ' (Good Living Quarters) is highly desirable for resale, while 'Unf' (Unfinished) or 'NA' (No Basement) contribute less to initial appeal.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Enc'] = df['BsmtFinType1'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 2 - Encoded)\\n# Usefulness: Similar to BsmtFinType1, but for the secondary finished area. Provides granular information on how basement space is utilized, impacting overall livability and value.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Enc'] = df['BsmtFinType2'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Functional - Encoded)\\n# Usefulness: Converts the functionality rating of the home into a numerical scale, where 'Typ' (Typical Functionality) is best and 'Sal' (Salvage only) is worst. Functional issues negatively impact market value.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\ndf['Functional_Enc'] = df['Functional'].map({'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}).fillna(0).astype(int)\\n\\n# (Garage Finish - Encoded)\\n# Usefulness: Ordinally maps the interior finish of the garage. A finished garage ('Fin') typically adds more value and utility compared to an unfinished one ('Unf') or no garage ('NA').\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Enc'] = df['GarageFinish'].map({'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Paved Driveway - Encoded)\\n# Usefulness: Translates driveway paving status into a numerical score, where 'Y' (Paved) is most desirable and 'N' (Dirt/Gravel) is least. This affects curb appeal and utility.\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y']\\ndf['PavedDrive_Enc'] = df['PavedDrive'].map({'Y': 2, 'P': 1, 'N': 0}).fillna(0).astype(int)\\n\\n# (Total Baths - Combined)\\n# Usefulness: Aggregates all full and half bathrooms into a single numerical feature, giving a comprehensive view of bathroom count. Full baths contribute more than half baths.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBaths'] = df['FullBath'] + df['HalfBath'] * 0.5 + df['BsmtFullBath'] + df['BsmtHalfBath'] * 0.5\\n\\n# (Total Above Ground Rooms per Square Foot)\\n# Usefulness: Calculates the density of rooms relative to living area. A higher value might indicate smaller rooms, which could be positive or negative depending on market preference for larger or more numerous rooms.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['RmsPerGrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Total Square Footage)\\n# Usefulness: Combines all major square footage metrics into a single, comprehensive measure of total usable area. This is a primary driver of home price.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total Outdoor Area)\\n# Usefulness: Aggregates all outdoor amenities (decks, porches, screens) into one feature, reflecting the total amount of dedicated outdoor living space, which can significantly enhance a home's appeal and value.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Total Number of Garages Cars and Area interaction)\\n# Usefulness: Combines the car capacity and square footage of the garage, offering a more nuanced understanding of garage utility. Useful garages typically add to property value.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageCapacityArea'] = df['GarageCars'] * df['GarageArea']\\n\\n# (Years Since Built)\\n# Usefulness: Represents the age of the house at the time of sale, calculated from the YearBuilt and YrSold. Newer houses often command higher prices due to modern amenities and less wear.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Remodel)\\n# Usefulness: Calculates the years passed since the last remodel or addition. More recent remodels generally indicate better condition and higher market appeal. If no remodel, it's `YearsSinceBuilt`.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Is Remodeled)\\n# Usefulness: A binary indicator (1 or 0) whether the house has undergone any remodeling. Remodeled homes are often perceived as more valuable than original builds, assuming quality renovations.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['IsRemodeled'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (Overall Quality-Condition Interaction)\\n# Usefulness: Creates an interaction term by multiplying OverallQual and OverallCond. This feature captures how both the material quality and current condition synergistically influence a property's appeal.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQC'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Above Grade SF including Porches)\\n# Usefulness: Combines the main above-ground living area with all porch and deck areas, giving a comprehensive view of above-grade accessible and recreational space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalGrLivSFPlusOutdoor'] = df['GrLivArea'] + df['TotalOutdoorArea']\\n\\n# (Total SF excluding Low Quality Finish)\\n# Usefulness: Represents the primary valuable living space by summing 1st, 2nd floor, and total basement SF, while subtracting any low-quality finished areas.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793], 'LowQualFinSF': [0, 0, 0]\\ndf['HighQualitySF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF'] - df['LowQualFinSF']\\n\\n# (House Age Group)\\n# Usefulness: Categorizes houses into age groups based on 'YearsSinceBuilt' to capture potential non-linear effects of age. Houses within certain age ranges might appeal to different buyer segments.\\n# Input samples: 'YearsSinceBuilt': [48, 13, 77]\\ndf['HouseAgeGroup'] = pd.cut(df['YearsSinceBuilt'], bins=[0, 10, 20, 40, 60, np.inf], labels=[0, 1, 2, 3, 4], right=False, include_lowest=True).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator for whether a property has a pool. Pools are a significant luxury feature, and their presence (or absence) is a key determinant for some buyers.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Lot Config: Is CulDSac or Corner)\\n# Usefulness: Identifies properties located in cul-de-sacs or corner lots, which often offer more privacy, yard space, or specific aesthetic appeal that can increase value.\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside']\\ndf['IsCulDSacOrCorner'] = ((df['LotConfig'] == 'CulDSac') | (df['LotConfig'] == 'Corner')).astype(int)\\n\\n# (Location Density)\\n# Usefulness: Creates a numerical proxy for property density based on lot size. Smaller lots might indicate higher density urban areas, which could influence pricing differently.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LotAreaDensity'] = 1 / np.log(df['LotArea'])\\n\\n# (MasVnrType Indicator)\\n# Usefulness: A binary feature indicating the presence of a masonry veneer. Masonry veneers add to the aesthetic appeal and perceived quality of a home.\\n# Input samples: 'MasVnrType': [nan, nan, nan]\\ndf['HasMasVnr'] = (~df['MasVnrType'].isna()).astype(int)\\n\\n# (Porch Total Area)\\n# Usefulness: Aggregates all types of porches (open, enclosed, 3-season, screen) into one value. Total porch space indicates opportunities for outdoor living and relaxation.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['PorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Computes how old the garage is at the time of sale. Newer garages are generally in better condition and are preferred. Handles NaNs by filling with the YearSold for houses without a garage, resulting in an age of 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\ndf['GarageAge'] = (df['YrSold'] - df['GarageYrBlt']).fillna(0).astype(int) # fillna(0) for missing garage, assuming age 0\\ndf['GarageAge'] = df['GarageAge'].mask(df['GarageType'].isna(), -1) # Assign -1 for houses with no garage at all\\n\\n# (Number of Bedrooms per Total Rooms)\\n# Usefulness: Calculates the ratio of bedrooms to total rooms above grade. This ratio might indicate layout efficiency or focus of the house (e.g., more bedrooms for smaller living spaces vs. fewer bedrooms with larger communal areas).\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['BedBathsPerTotRms'] = (df['BedroomAbvGr'] + df['TotalBaths']) / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Has Alley Access)\\n# Usefulness: A simple binary indicator for whether the property has alley access. This can be either a convenience or a drawback, influencing its specific value.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = (~df['Alley'].isna()).astype(int)\\n\"]}, \"score\": -0.11538058001634222, \"memory_update\": \"import pandas as pd\\nimport numpy as np\\n\\n# (Exterior Quality - Encoded)\\n# Usefulness: Translates the ordinal quality of the material on the exterior into a numerical scale, providing a direct, quantitative measure for the regression model to associate with SalePrice. Higher quality generally means higher price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Enc'] = df['ExterQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Exterior Condition - Encoded)\\n# Usefulness: Converts the ordinal condition of the exterior materials into a numerical scale, allowing the model to weigh this factor in pricing. Better condition typically indicates higher value.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Enc'] = df['ExterCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Basement Quality - Encoded)\\n# Usefulness: Represents the quality/height of the basement using a numerical scale. Basements significantly impact property value, and this encoding allows the model to directly use this hierarchical information. 'NA' implies no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Enc'] = df['BsmtQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Condition - Encoded)\\n# Usefulness: Numerically quantifies the general condition of the basement, with 'NA' indicating no basement. A well-maintained basement is a positive asset, and this feature helps capture that impact on price.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Enc'] = df['BsmtCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Heating Quality and Condition - Encoded)\\n# Usefulness: Transforms the ordinal rating of heating quality into a numerical feature. Excellent heating systems add more value than poor ones.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Enc'] = df['HeatingQC'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Kitchen Quality - Encoded)\\n# Usefulness: Encodes the quality of the kitchen, which is a major factor in home valuation. A higher quality kitchen corresponds to a higher potential sale price.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Enc'] = df['KitchenQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Fireplace Quality - Encoded)\\n# Usefulness: Converts fireplace quality into a numerical score, with 'NA' signifying no fireplace. Fireplaces are desirable features that influence appeal and price.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Enc'] = df['FireplaceQu'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Quality - Encoded)\\n# Usefulness: Numerically ranks the quality of the garage, where 'NA' means no garage. Garage quality is important for perceived utility and value.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Enc'] = df['GarageQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Condition - Encoded)\\n# Usefulness: Transforms garage condition into a numerical score. Similar to quality, the condition reflects maintenance and functionality, influencing buyer perception and price.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Enc'] = df['GarageCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Lot Shape - Encoded)\\n# Usefulness: Converts the ordinal LotShape categories into a numerical scale where 'Reg' (regular) is most desirable and 'IR3' (irregular) is least. This allows the model to understand the appeal of the lot shape.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['LotShape_Enc'] = df['LotShape'].map({'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}).fillna(0).astype(int)\\n\\n# (Basement Exposure - Encoded)\\n# Usefulness: Ordinally maps basement exposure to a numerical value. Good exposure means more natural light and potential for living space, increasing value. 'NA' means no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Enc'] = df['BsmtExposure'].map({'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 1 - Encoded)\\n# Usefulness: Encodes the primary type of finished basement area. 'GLQ' (Good Living Quarters) is highly desirable for resale, while 'Unf' (Unfinished) or 'NA' (No Basement) contribute less to initial appeal.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Enc'] = df['BsmtFinType1'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 2 - Encoded)\\n# Usefulness: Similar to BsmtFinType1, but for the secondary finished area. Provides granular information on how basement space is utilized, impacting overall livability and value.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Enc'] = df['BsmtFinType2'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Functional - Encoded)\\n# Usefulness: Converts the functionality rating of the home into a numerical scale, where 'Typ' (Typical Functionality) is best and 'Sal' (Salvage only) is worst. Functional issues negatively impact market value.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\ndf['Functional_Enc'] = df['Functional'].map({'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}).fillna(0).astype(int)\\n\\n# (Garage Finish - Encoded)\\n# Usefulness: Ordinally maps the interior finish of the garage. A finished garage ('Fin') typically adds more value and utility compared to an unfinished one ('Unf') or no garage ('NA').\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Enc'] = df['GarageFinish'].map({'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Paved Driveway - Encoded)\\n# Usefulness: Translates driveway paving status into a numerical score, where 'Y' (Paved) is most desirable and 'N' (Dirt/Gravel) is least. This affects curb appeal and utility.\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y']\\ndf['PavedDrive_Enc'] = df['PavedDrive'].map({'Y': 2, 'P': 1, 'N': 0}).fillna(0).astype(int)\\n\\n# (Total Baths - Combined)\\n# Usefulness: Aggregates all full and half bathrooms into a single numerical feature, giving a comprehensive view of bathroom count. Full baths contribute more than half baths.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBaths'] = df['FullBath'] + df['HalfBath'] * 0.5 + df['BsmtFullBath'] + df['BsmtHalfBath'] * 0.5\\n\\n# (Total Above Ground Rooms per Square Foot)\\n# Usefulness: Calculates the density of rooms relative to living area. A higher value might indicate smaller rooms, which could be positive or negative depending on market preference for larger or more numerous rooms.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['RmsPerGrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Total Square Footage)\\n# Usefulness: Combines all major square footage metrics into a single, comprehensive measure of total usable area. This is a primary driver of home price.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total Outdoor Area)\\n# Usefulness: Aggregates all outdoor amenities (decks, porches, screens) into one feature, reflecting the total amount of dedicated outdoor living space, which can significantly enhance a home's appeal and value.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Total Number of Garages Cars and Area interaction)\\n# Usefulness: Combines the car capacity and square footage of the garage, offering a more nuanced understanding of garage utility. Useful garages typically add to property value.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageCapacityArea'] = df['GarageCars'] * df['GarageArea']\\n\\n# (Years Since Built)\\n# Usefulness: Represents the age of the house at the time of sale, calculated from the YearBuilt and YrSold. Newer houses often command higher prices due to modern amenities and less wear.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Remodel)\\n# Usefulness: Calculates the years passed since the last remodel or addition. More recent remodels generally indicate better condition and higher market appeal. If no remodel, it's `YearsSinceBuilt`.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Is Remodeled)\\n# Usefulness: A binary indicator (1 or 0) whether the house has undergone any remodeling. Remodeled homes are often perceived as more valuable than original builds, assuming quality renovations.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['IsRemodeled'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (Overall Quality-Condition Interaction)\\n# Usefulness: Creates an interaction term by multiplying OverallQual and OverallCond. This feature captures how both the material quality and current condition synergistically influence a property's appeal.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQC'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Above Grade SF including Porches)\\n# Usefulness: Combines the main above-ground living area with all porch and deck areas, giving a comprehensive view of above-grade accessible and recreational space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalGrLivSFPlusOutdoor'] = df['GrLivArea'] + df['TotalOutdoorArea']\\n\\n# (Total SF excluding Low Quality Finish)\\n# Usefulness: Represents the primary valuable living space by summing 1st, 2nd floor, and total basement SF, while subtracting any low-quality finished areas.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793], 'LowQualFinSF': [0, 0, 0]\\ndf['HighQualitySF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF'] - df['LowQualFinSF']\\n\\n# (House Age Group)\\n# Usefulness: Categorizes houses into age groups based on 'YearsSinceBuilt' to capture potential non-linear effects of age. Houses within certain age ranges might appeal to different buyer segments.\\n# Input samples: 'YearsSinceBuilt': [48, 13, 77]\\ndf['HouseAgeGroup'] = pd.cut(df['YearsSinceBuilt'], bins=[0, 10, 20, 40, 60, np.inf], labels=[0, 1, 2, 3, 4], right=False, include_lowest=True).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator for whether a property has a pool. Pools are a significant luxury feature, and their presence (or absence) is a key determinant for some buyers.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Lot Config: Is CulDSac or Corner)\\n# Usefulness: Identifies properties located in cul-de-sacs or corner lots, which often offer more privacy, yard space, or specific aesthetic appeal that can increase value.\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside']\\ndf['IsCulDSacOrCorner'] = ((df['LotConfig'] == 'CulDSac') | (df['LotConfig'] == 'Corner')).astype(int)\\n\\n# (Location Density)\\n# Usefulness: Creates a numerical proxy for property density based on lot size. Smaller lots might indicate higher density urban areas, which could influence pricing differently.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LotAreaDensity'] = 1 / np.log(df['LotArea'])\\n\\n# (MasVnrType Indicator)\\n# Usefulness: A binary feature indicating the presence of a masonry veneer. Masonry veneers add to the aesthetic appeal and perceived quality of a home.\\n# Input samples: 'MasVnrType': [nan, nan, nan]\\ndf['HasMasVnr'] = (~df['MasVnrType'].isna()).astype(int)\\n\\n# (Porch Total Area)\\n# Usefulness: Aggregates all types of porches (open, enclosed, 3-season, screen) into one value. Total porch space indicates opportunities for outdoor living and relaxation.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['PorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Computes how old the garage is at the time of sale. Newer garages are generally in better condition and are preferred. Handles NaNs by filling with the YearSold for houses without a garage, resulting in an age of 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\ndf['GarageAge'] = (df['YrSold'] - df['GarageYrBlt']).fillna(0).astype(int) # fillna(0) for missing garage, assuming age 0\\ndf['GarageAge'] = df['GarageAge'].mask(df['GarageType'].isna(), -1) # Assign -1 for houses with no garage at all\\n\\n# (Number of Bedrooms per Total Rooms)\\n# Usefulness: Calculates the ratio of bedrooms to total rooms above grade. This ratio might indicate layout efficiency or focus of the house (e.g., more bedrooms for smaller living spaces vs. fewer bedrooms with larger communal areas).\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['BedBathsPerTotRms'] = (df['BedroomAbvGr'] + df['TotalBaths']) / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Has Alley Access)\\n# Usefulness: A simple binary indicator for whether the property has alley access. This can be either a convenience or a drawback, influencing its specific value.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = (~df['Alley'].isna()).astype(int)\\n\"}, {\"search_node\": {\"trial\": 6, \"parent_trial\": 1, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}], \"predefined_state\": null, \"parent_score\": -0.11564900906267117, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\"]}, \"score\": -0.1149670157247227, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\"}, {\"search_node\": {\"trial\": 7, \"parent_trial\": 1, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}], \"predefined_state\": null, \"parent_score\": -0.11564900906267117, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\"]}, \"score\": -0.11380374429092432, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\"}, {\"search_node\": {\"trial\": 8, \"parent_trial\": 3, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}], \"predefined_state\": null, \"parent_score\": -0.11561350952648, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Total square footage of the house (above grade + basement)\\n# Usefulness: A larger total living area is generally associated with a higher sale price.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]\\ndf['TotalSF'] = df['TotalBsmtSF'] + df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# Total number of bathrooms (considering half baths as 0.5)\\n# Usefulness: More bathrooms typically indicate a more desirable and expensive home.\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBathrooms'] = df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath']) + \\\\\\n                     df['FullBath'] + (0.5 * df['HalfBath'])\\n\\n# Total outdoor living space (wood deck, open porch, enclosed porch, 3-season porch, screen porch)\\n# Usefulness: Homes with more outdoor amenities like decks and porches often fetch higher prices, especially if well-maintained.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + \\\\\\n                      df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# Age of the house at the time of sale\\n# Usefulness: Older houses might be less desirable, but very old, well-preserved/remodeled ones can be valuable.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['Age'] = df['YrSold'] - df['YearBuilt']\\n\\n# Years since the last remodel or construction (if no remodel)\\n# Usefulness: Newer remodels generally indicate a more modern and attractive home, increasing its value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# Flag indicating if the house was built and sold in the same year (often signifies a new construction)\\n# Usefulness: New homes typically command higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 2003], 'YrSold': [2009, 2006, 2007]\\ndf['IsNewConstruction'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# Flag indicating the presence of a basement\\n# Usefulness: Houses with basements offer more functional space and storage, which is generally positive for sale price.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# Flag indicating the presence of a garage\\n# Usefulness: A garage is a highly desired amenity, adding significant value to a home.\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# Flag indicating the presence of a pool\\n# Usefulness: While pools can be a maintenance cost, for some buyers they are a luxury that adds value.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# Living area per room above grade\\n# Usefulness: Provides a sense of spaciousness; higher values might indicate larger, more functional rooms.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['GrLivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd']\\ndf['GrLivAreaPerRoom'] = df['GrLivAreaPerRoom'].replace([np.inf, -np.inf], 0).fillna(0) # Handle potential division by zero\\n\\n# Simplified 'MSSubClass' into 'TypeDwelling' category (e.g., 'Story_1' or 'Story_2' based on first digit)\\n# Usefulness: Categorizing dwelling types into broader groups might capture underlying patterns more effectively than the specific numeric codes.\\n# Input samples: 'MSSubClass': [20, 60, 50]\\ndef map_dwelling_type(ms_subclass):\\n    if ms_subclass in [20, 30, 40, 120, 45, 50, 150]: return 'Story_1_or_1_5'\\n    elif ms_subclass in [60, 70, 75, 160]: return 'Story_2_or_2_5'\\n    elif ms_subclass in [80, 85, 180]: return 'Split_or_Multi'\\n    elif ms_subclass in [90, 190]: return 'Duplex_or_Conversion'\\n    else: return 'Other'\\ndf['TypeDwellingCat'] = df['MSSubClass'].apply(map_dwelling_type)\\n\\n# Combined quality score for exterior and basement\\n# Usefulness: The quality of these major structural components significantly impacts home value.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']\\nquality_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}\\ndf['ExterQual_val'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_val'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallExteriorBasementQual'] = df['ExterQual_val'] + df['BsmtQual_val']\\ndf.drop(columns=['ExterQual_val', 'BsmtQual_val'], inplace=True) # drop temporary columns\\n\\n# Combined quality score for heating and kitchen\\n# Usefulness: The quality of heating and kitchen are critical for daily living and highly impact buyer satisfaction.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex'], 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['HeatingQC_val'] = df['HeatingQC'].map(quality_map).fillna(0)\\ndf['KitchenQual_val'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['OverallHeatingKitchenQual'] = df['HeatingQC_val'] + df['KitchenQual_val']\\ndf.drop(columns=['HeatingQC_val', 'KitchenQual_val'], inplace=True) # drop temporary columns\\n\\n# Average quality score across overall, exterior, basement, heating, and kitchen\\n# Usefulness: A single aggregate score might provide a comprehensive view of the house's quality level.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallExteriorBasementQual': [6, 8, 6], 'OverallHeatingKitchenQual': [8, 9, 8]\\ndf['AvgQualScore'] = (df['OverallQual'] + df['OverallExteriorBasementQual'] + df['OverallHeatingKitchenQual']) / 3\\n\\n# Ratio of living area to lot area\\n# Usefulness: Indication of density/build-up on the lot. A larger house relative to the lot might be perceived differently.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['GrLivAreaToLotRatio'] = df['GrLivArea'] / df['LotArea']\\ndf['GrLivAreaToLotRatio'] = df['GrLivAreaToLotRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle potential division by zero if LotArea is 0\\n\\n# Binary feature for homes with an 'IR' LotShape (irregular)\\n# Usefulness: Irregular lots can sometimes be less desirable or harder to build on, potentially affecting price.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['IsIrregularLot'] = df['LotShape'].apply(lambda x: 1 if 'IR' in x else 0)\\n\\n# Binary feature for homes located on a corner lot\\n# Usefulness: Corner lots can be more desirable due to increased light and space, but also have more street exposure.\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside']\\ndf['IsCornerLot'] = (df['LotConfig'] == 'Corner').astype(int)\\n\\n# Indicates if the house has central air conditioning\\n# Usefulness: Central air is a significant modern comfort feature, often expected in higher-priced homes.\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# Age of garage when sold\\n# Usefulness: A very old garage might require significant repairs, impacting the overall perceived value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt']\\ndf['GarageAge'] = df['GarageAge'].fillna(df['Age']) # Impute missing GarageYrBlt with House Age. If no garage, then GarageAge can also be NaN\\n\\n# Does the house have any special miscellaneous feature (not including Shed > 100SF, which might be common)\\n# Usefulness: Special features could increase or decrease value, but generally signal unique attributes.\\n# Input samples: 'MiscFeature': ['Shed', nan, nan]\\ndf['HasMiscFeature'] = df['MiscFeature'].apply(lambda x: 0 if pd.isna(x) or x == 'Shed' else 1)\\n\\n# Is the condition of the first property adjacent (Condition1 includes Artery or Feedr)\\n# Usefulness: Proximity to arterial or feeder streets could impact desirability due to noise/traffic.\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm']\\ndf['NearMajorRoad'] = df['Condition1'].apply(lambda x: 1 if x in ['Artery', 'Feedr'] else 0)\\n\\n# Is the house above average in both overall quality and condition\\n# Usefulness: A general indicator of a well-maintained and desirable property.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['AboveAvgOverall'] = ((df['OverallQual'] >= 6) & (df['OverallCond'] >= 6)).astype(int)\\n\\n# Flag indicating presence of a fireplace\\n# Usefulness: Fireplaces are a desirable feature, especially for aesthetic appeal and comfort.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# Garage Area per car capacity\\n# Usefulness: Provides insight into the spaciousness of the garage for its intended car capacity.\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars']\\ndf['GarageAreaPerCar'] = df['GarageAreaPerCar'].replace([np.inf, -np.inf], 0).fillna(0) # Handle potential division by zero if GarageCars is 0 or NaN\\n\\n# Calculate combined lot attributes (shape, contour, config) score\\n# Usefulness: Synthesize different aspects of the lot itself, potentially revealing patterns for value.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2'], 'LandContour': ['Lvl', 'Lvl', 'Bnk'], 'LotConfig': ['Corner', 'Corner', 'Inside']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\nland_contour_map = {'Lvl': 4, 'Bnk': 3, 'HLS': 2, 'Low': 1}\\nlot_config_map = {'Inside': 3, 'Corner': 4, 'CulDSac': 5, 'FR2': 2, 'FR3': 1} # Cul-de-sac often desirable\\ndf['LotShape_score'] = df['LotShape'].map(lot_shape_map).fillna(0)\\ndf['LandContour_score'] = df['LandContour'].map(land_contour_map).fillna(0)\\ndf['LotConfig_score'] = df['LotConfig'].map(lot_config_map).fillna(0)\\ndf['CombinedLotScore'] = df['LotShape_score'] + df['LandContour_score'] + df['LotConfig_score']\\ndf.drop(columns=['LotShape_score', 'LandContour_score', 'LotConfig_score'], inplace=True) # drop temporary columns\\n\"]}, \"score\": -0.11636261684284666, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Total square footage of the house (above grade + basement)\\n# Usefulness: A larger total living area is generally associated with a higher sale price.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]\\ndf['TotalSF'] = df['TotalBsmtSF'] + df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# Total number of bathrooms (considering half baths as 0.5)\\n# Usefulness: More bathrooms typically indicate a more desirable and expensive home.\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBathrooms'] = df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath']) + \\\\\\n                     df['FullBath'] + (0.5 * df['HalfBath'])\\n\\n# Total outdoor living space (wood deck, open porch, enclosed porch, 3-season porch, screen porch)\\n# Usefulness: Homes with more outdoor amenities like decks and porches often fetch higher prices, especially if well-maintained.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + \\\\\\n                      df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# Age of the house at the time of sale\\n# Usefulness: Older houses might be less desirable, but very old, well-preserved/remodeled ones can be valuable.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['Age'] = df['YrSold'] - df['YearBuilt']\\n\\n# Years since the last remodel or construction (if no remodel)\\n# Usefulness: Newer remodels generally indicate a more modern and attractive home, increasing its value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# Flag indicating if the house was built and sold in the same year (often signifies a new construction)\\n# Usefulness: New homes typically command higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 2003], 'YrSold': [2009, 2006, 2007]\\ndf['IsNewConstruction'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# Flag indicating the presence of a basement\\n# Usefulness: Houses with basements offer more functional space and storage, which is generally positive for sale price.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# Flag indicating the presence of a garage\\n# Usefulness: A garage is a highly desired amenity, adding significant value to a home.\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# Flag indicating the presence of a pool\\n# Usefulness: While pools can be a maintenance cost, for some buyers they are a luxury that adds value.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# Living area per room above grade\\n# Usefulness: Provides a sense of spaciousness; higher values might indicate larger, more functional rooms.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['GrLivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd']\\ndf['GrLivAreaPerRoom'] = df['GrLivAreaPerRoom'].replace([np.inf, -np.inf], 0).fillna(0) # Handle potential division by zero\\n\\n# Simplified 'MSSubClass' into 'TypeDwelling' category (e.g., 'Story_1' or 'Story_2' based on first digit)\\n# Usefulness: Categorizing dwelling types into broader groups might capture underlying patterns more effectively than the specific numeric codes.\\n# Input samples: 'MSSubClass': [20, 60, 50]\\ndef map_dwelling_type(ms_subclass):\\n    if ms_subclass in [20, 30, 40, 120, 45, 50, 150]: return 'Story_1_or_1_5'\\n    elif ms_subclass in [60, 70, 75, 160]: return 'Story_2_or_2_5'\\n    elif ms_subclass in [80, 85, 180]: return 'Split_or_Multi'\\n    elif ms_subclass in [90, 190]: return 'Duplex_or_Conversion'\\n    else: return 'Other'\\ndf['TypeDwellingCat'] = df['MSSubClass'].apply(map_dwelling_type)\\n\\n# Combined quality score for exterior and basement\\n# Usefulness: The quality of these major structural components significantly impacts home value.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']\\nquality_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}\\ndf['ExterQual_val'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_val'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallExteriorBasementQual'] = df['ExterQual_val'] + df['BsmtQual_val']\\ndf.drop(columns=['ExterQual_val', 'BsmtQual_val'], inplace=True) # drop temporary columns\\n\\n# Combined quality score for heating and kitchen\\n# Usefulness: The quality of heating and kitchen are critical for daily living and highly impact buyer satisfaction.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex'], 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['HeatingQC_val'] = df['HeatingQC'].map(quality_map).fillna(0)\\ndf['KitchenQual_val'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['OverallHeatingKitchenQual'] = df['HeatingQC_val'] + df['KitchenQual_val']\\ndf.drop(columns=['HeatingQC_val', 'KitchenQual_val'], inplace=True) # drop temporary columns\\n\\n# Average quality score across overall, exterior, basement, heating, and kitchen\\n# Usefulness: A single aggregate score might provide a comprehensive view of the house's quality level.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallExteriorBasementQual': [6, 8, 6], 'OverallHeatingKitchenQual': [8, 9, 8]\\ndf['AvgQualScore'] = (df['OverallQual'] + df['OverallExteriorBasementQual'] + df['OverallHeatingKitchenQual']) / 3\\n\\n# Ratio of living area to lot area\\n# Usefulness: Indication of density/build-up on the lot. A larger house relative to the lot might be perceived differently.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['GrLivAreaToLotRatio'] = df['GrLivArea'] / df['LotArea']\\ndf['GrLivAreaToLotRatio'] = df['GrLivAreaToLotRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle potential division by zero if LotArea is 0\\n\\n# Binary feature for homes with an 'IR' LotShape (irregular)\\n# Usefulness: Irregular lots can sometimes be less desirable or harder to build on, potentially affecting price.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['IsIrregularLot'] = df['LotShape'].apply(lambda x: 1 if 'IR' in x else 0)\\n\\n# Binary feature for homes located on a corner lot\\n# Usefulness: Corner lots can be more desirable due to increased light and space, but also have more street exposure.\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside']\\ndf['IsCornerLot'] = (df['LotConfig'] == 'Corner').astype(int)\\n\\n# Indicates if the house has central air conditioning\\n# Usefulness: Central air is a significant modern comfort feature, often expected in higher-priced homes.\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# Age of garage when sold\\n# Usefulness: A very old garage might require significant repairs, impacting the overall perceived value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt']\\ndf['GarageAge'] = df['GarageAge'].fillna(df['Age']) # Impute missing GarageYrBlt with House Age. If no garage, then GarageAge can also be NaN\\n\\n# Does the house have any special miscellaneous feature (not including Shed > 100SF, which might be common)\\n# Usefulness: Special features could increase or decrease value, but generally signal unique attributes.\\n# Input samples: 'MiscFeature': ['Shed', nan, nan]\\ndf['HasMiscFeature'] = df['MiscFeature'].apply(lambda x: 0 if pd.isna(x) or x == 'Shed' else 1)\\n\\n# Is the condition of the first property adjacent (Condition1 includes Artery or Feedr)\\n# Usefulness: Proximity to arterial or feeder streets could impact desirability due to noise/traffic.\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm']\\ndf['NearMajorRoad'] = df['Condition1'].apply(lambda x: 1 if x in ['Artery', 'Feedr'] else 0)\\n\\n# Is the house above average in both overall quality and condition\\n# Usefulness: A general indicator of a well-maintained and desirable property.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['AboveAvgOverall'] = ((df['OverallQual'] >= 6) & (df['OverallCond'] >= 6)).astype(int)\\n\\n# Flag indicating presence of a fireplace\\n# Usefulness: Fireplaces are a desirable feature, especially for aesthetic appeal and comfort.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# Garage Area per car capacity\\n# Usefulness: Provides insight into the spaciousness of the garage for its intended car capacity.\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars']\\ndf['GarageAreaPerCar'] = df['GarageAreaPerCar'].replace([np.inf, -np.inf], 0).fillna(0) # Handle potential division by zero if GarageCars is 0 or NaN\\n\\n# Calculate combined lot attributes (shape, contour, config) score\\n# Usefulness: Synthesize different aspects of the lot itself, potentially revealing patterns for value.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2'], 'LandContour': ['Lvl', 'Lvl', 'Bnk'], 'LotConfig': ['Corner', 'Corner', 'Inside']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\nland_contour_map = {'Lvl': 4, 'Bnk': 3, 'HLS': 2, 'Low': 1}\\nlot_config_map = {'Inside': 3, 'Corner': 4, 'CulDSac': 5, 'FR2': 2, 'FR3': 1} # Cul-de-sac often desirable\\ndf['LotShape_score'] = df['LotShape'].map(lot_shape_map).fillna(0)\\ndf['LandContour_score'] = df['LandContour'].map(land_contour_map).fillna(0)\\ndf['LotConfig_score'] = df['LotConfig'].map(lot_config_map).fillna(0)\\ndf['CombinedLotScore'] = df['LotShape_score'] + df['LandContour_score'] + df['LotConfig_score']\\ndf.drop(columns=['LotShape_score', 'LandContour_score', 'LotConfig_score'], inplace=True) # drop temporary columns\\n\"}, {\"search_node\": {\"trial\": 9, \"parent_trial\": 7, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\", \"score\": -0.11380374429092432}], \"predefined_state\": null, \"parent_score\": -0.11380374429092432, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define mappings for categorical features\\n# General quality/condition\\nquality_map_general = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, np.nan: 0}\\n# Basement exposure\\nbsmt_exposure_map = {'No': 1, 'Mn': 2, 'Av': 3, 'Gd': 4, np.nan: 0}\\n# Basement Fin Type\\nbsmt_fin_type_map = {'Unf': 1, 'LwQ': 2, 'Rec': 3, 'BLQ': 4, 'ALQ': 5, 'GLQ': 6, np.nan: 0}\\n# Functional\\nfunctional_map = {'Sal': 1, 'Sev': 2, 'Maj2': 3, 'Maj1': 4, 'Mod': 5, 'Min2': 6, 'Min1': 7, 'Typ': 8}\\n# PavedDrive\\npaved_drive_map = {'N': 1, 'P': 2, 'Y': 3}\\n# Fence quality\\nfence_map = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, np.nan: 0}\\n# MasVnrType map\\nmas_vnr_type_map = {'None': 0, 'BrkCmn': 1, 'CBlock': 1, 'Stone': 3, 'BrkFace': 2, np.nan: 0}\\n# Electrical map\\nelectrical_map = {'FuseP': 1, 'FuseF': 2, 'FuseA': 3, 'SBrkr': 4, 'Mix': 2.5}\\n\\n\\n# (Square footage of 2nd floor as a proportion of total above ground living area)\\n# Usefulness: Helps understand the layout and style of the house. A higher proportion of 2nd floor could indicate a more vertical, possibly newer construction style.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672], 'GrLivArea': [1144, 2520, 1520]}\\ndf['2ndFlrSF_ratio_GrLivArea'] = df['2ndFlrSF'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Basement finished area 1 as a proportion of total basement area)\\n# Usefulness: Quantifies the extent and quality of finished basement space, which can significantly influence a home's value by adding usable square footage.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinSF1_ratio_TotalBsmtSF'] = df['BsmtFinSF1'] / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtFinSF1_ratio_TotalBsmtSF'] = df['BsmtFinSF1_ratio_TotalBsmtSF'].fillna(0)\\n\\n# (Unfinished Basement Area as a proportion of total basement area)\\n# Usefulness: Indicates potential for future finishing by homeowners, impacting the future value or initial desirability for buyers seeking customization.\\n# Input samples: {'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtUnfSF_ratio_TotalBsmtSF'] = df['BsmtUnfSF'] / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtUnfSF_ratio_TotalBsmtSF'] = df['BsmtUnfSF_ratio_TotalBsmtSF'].fillna(0)\\n\\n# (Combined score for Basement Finished Type 1 and Type 2)\\n# Usefulness: A weighted average of basement finished areas, accounting for their quality ratings. More \\\"Good Living Quarters\\\" contributes more value.\\n# Input samples: {'BsmtFinType1': ['BLQ', 'GLQ', 'Rec'], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinType2': ['Unf', 'Unf', 'Unf'], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]}\\nbsmt_fin_type1_score = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\nbsmt_fin_type2_score = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\ndf['BsmtFinSF_Weighted'] = (df['BsmtFinSF1'] * bsmt_fin_type1_score + df['BsmtFinSF2'] * bsmt_fin_type2_score) / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtFinSF_Weighted'] = df['BsmtFinSF_Weighted'].fillna(0)\\n\\n# (Quality of Pool)\\n# Usefulness: Indicates the quality of the pool if present. Pools can be a significant amenity, and their condition influences desirability. A 0 indicates no pool.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns: # Check if 'PoolQC' column exists before trying to map it\\n    df['PoolQC_Score'] = df['PoolQC'].map(quality_map_general)\\nelse:\\n    df['PoolQC_Score'] = 0 # Default to 0 if column is missing, effectively indicating no pool or no quality assessment.\\n\\n# (Quality of Fence)\\n# Usefulness: A good quality fence can enhance privacy, security, and aesthetics, adding to property value. A 0 indicates no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_map)\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Similar to house age, garage age matters. An old garage might need renovation or indicate wear. A value near 0 means garage built same year as sold (new or remodeled recently).\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAgeAtSale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\ndf['GarageAgeAtSale'] = df['GarageAgeAtSale'].apply(lambda x: x if x >= 0 else 0)\\n\\n# (Number of Years between Built and Remodel/Add)\\n# Usefulness: Shows how long a house existed before its first (or only) remodel. A longer period could suggest original parts are older, or significant overhaul was needed.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['Years_Since_Built_vs_Remod'] = df['YearRemodAdd'] - df['YearBuilt']\\ndf['Years_Since_Built_vs_Remod'] = df['Years_Since_Built_vs_Remod'].apply(lambda x: x if x >= 0 else 0)\\n\\n# (Binary: Is house new build (same year built as sold and no remodel))\\n# Usefulness: New homes typically command higher prices due to modern design, features, and less maintenance initially. This identifies new construction.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['Is_New_Build'] = ((df['YearBuilt'] == df['YrSold']) & (df['YearBuilt'] == df['YearRemodAdd'])).astype(int)\\n\\n# (Is property located on a corner lot or cul-de-sac)\\n# Usefulness: These lot configurations can influence privacy, traffic, and access, often viewed positively by buyers.\\n# Input samples: {'LotConfig': ['Corner', 'Corner', 'Inside']}\\ndf['Is_Corner_CulDSac'] = ((df['LotConfig'] == 'Corner') | (df['LotConfig'] == 'CulDSac')).astype(int)\\n\\n# (Log Transformation of LotFrontage - impute missing)\\n# Usefulness: LotFrontage is often skewed and has missing values. Log transformation can stabilize variance. Imputing with median ensures consistency.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['Log_LotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (MasVnr Area Interaction with MasVnr Type Score)\\n# Usefulness: Combines the physical area of masonry veneer with a quality score from its type. A larger area of quality veneer contributes more to value.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]}\\nmas_vnr_type_score_mapped = df['MasVnrType'].map(mas_vnr_type_map).fillna(0)\\ndf['MasVnr_QualityArea'] = df['MasVnrArea'].fillna(0) * mas_vnr_type_score_mapped\\n\\n# (Total square feet per room above grade)\\n# Usefulness: Indicates average room size above grade. Larger rooms are often more desirable, indicating a more spacious layout.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['GrLivArea_Per_Room'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1)\\n\\n# (Number of stories inferred from HouseStyle)\\n# Usefulness: Indicates the number of floors, which is a key structural attribute influencing vertical space and overall perceived size.\\n# Input samples: {'HouseStyle': ['1Story', '2Story', '1.5Fin']}\\ndf['NumStories'] = df['HouseStyle'].map({\\n    '1Story': 1, '1.5Unf': 1.5, '1.5Fin': 1.5, '2Story': 2, '2.5Unf': 2.5, '2.5Fin': 2.5,\\n    'SFoyer': 1, 'SLvl': 1,\\n}).fillna(1)\\n\\n# (Functional - Is Non-Typical Functionality?)\\n# Usefulness: Flagging homes that have any degree of functional defect, which could indicate problems impacting value.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_NonTypical_Binary'] = (df['Functional'] != 'Typ').astype(int)\\n\\n# (Electrical Quality Score)\\n# Usefulness: Maps the 'Electrical' system to an ordinal score. A robust electrical system is crucial for safety and functionality.\\n# Input samples: {'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']}\\ndf['Electrical_Score'] = df['Electrical'].map(electrical_map).fillna(df['Electrical'].map(electrical_map).mode()[0])\\n\\n# (Bedroom above grade squared)\\n# Usefulness: Number of bedrooms often has a non-linear relationship with price.\\n# Input samples: {'BedroomAbvGr': [3, 5, 3]}\\ndf['BedroomAbvGr_Sq'] = df['BedroomAbvGr'] ** 2\\n\\n# (Total Area excluding basement - Living + Garage)\\n# Usefulness: Focuses on the accessible and main living/car areas of the home.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'GarageArea': [264, 796, 281]}\\ndf['AboveGroundAreaPlusGarage'] = df['GrLivArea'] + df['GarageArea']\\n\\n# (Binary: Does MSZoning represent a residential area?)\\n# Usefulness: Flag to easily differentiate residential vs. non-residential properties.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\ndf['Is_Residential_Zoning'] = df['MSZoning'].isin(['RL', 'RM', 'RH', 'FV', 'RP']).astype(int)\\n\\n# (YearRemodAdd same as YearBuilt)\\n# Usefulness: Indicates if the property has never been remodeled since its construction.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['No_Remodel_Since_Built'] = (df['YearRemodAdd'] == df['YearBuilt']).astype(int)\\n\\n# (Combined ExterQual & OverallQual score)\\n# Usefulness: Multiplies two key quality indicators to potentially capture a stronger non-linear effect.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Quality_Product'] = df['OverallQual'] * df['ExterQual'].map(quality_map_general)\\n\\n# (Binary: Property adjacent to (positive) off-site feature)\\n# Usefulness: Identifies properties benefiting from desirable external features like parks or greenbelts.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['Near_Positive_Feature'] = (\\n    (df['Condition1'].isin(['PosN', 'PosA'])) |\\n    (df['Condition2'].isin(['PosN', 'PosA']))\\n).astype(int)\\n\\n# (Binary: Property adjacent to undesirable feature like arterial/feeder street or railroad)\\n# Usefulness: Flags properties potentially negatively impacted by proximity to high-traffic areas or noise sources.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\nundesirable_features = ['Artery', 'Feedr', 'RRNn', 'RRAn', 'RRNe', 'RRAe']\\ndf['Near_Undesirable_Feature'] = (\\n    (df['Condition1'].isin(undesirable_features)) |\\n    (df['Condition2'].isin(undesirable_features))\\n).astype(int)\\n\\n# (Log Transformation of MasVnrArea)\\n# Usefulness: Addresses potential skewness in masonry veneer area, helping linear models. Handles zeros with log1p.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['Log_MasVnrArea'] = np.log1p(df['MasVnrArea'].fillna(0))\\n\\n# (Paved Driveway Quality Score)\\n# Usefulness: Converts `PavedDrive` to an ordinal score. A fully paved driveway is generally preferred.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Score'] = df['PavedDrive'].map(paved_drive_map)\\ndf['PavedDrive_Score'] = df['PavedDrive_Score'].fillna(0) # Should not be NaN if map covers all types, but safe\\n\\n# (Building Type - Is Townhouse?)\\n# Usefulness: Binary flag for townhouses. Townhouses often have different price dynamics.\\n# Input samples: {'BldgType': ['1Fam', '1Fam', '1Fam']}\\ndf['Is_Townhouse'] = df['BldgType'].isin(['TwnhsE', 'TwnhsI']).astype(int)\\n\\n# (Total Full and Half Baths Above Grade)\\n# Usefulness: Captures the number of easily accessible bathrooms (excluding basement), which is a crucial selling point and contributor to a home's comfort and value. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]}\\ndf['FullHalfBath_AboveGrade'] = df['FullBath'] + 0.5 * df['HalfBath']\\n\"]}, \"score\": -0.11494290218006176, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define mappings for categorical features\\n# General quality/condition\\nquality_map_general = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, np.nan: 0}\\n# Basement exposure\\nbsmt_exposure_map = {'No': 1, 'Mn': 2, 'Av': 3, 'Gd': 4, np.nan: 0}\\n# Basement Fin Type\\nbsmt_fin_type_map = {'Unf': 1, 'LwQ': 2, 'Rec': 3, 'BLQ': 4, 'ALQ': 5, 'GLQ': 6, np.nan: 0}\\n# Functional\\nfunctional_map = {'Sal': 1, 'Sev': 2, 'Maj2': 3, 'Maj1': 4, 'Mod': 5, 'Min2': 6, 'Min1': 7, 'Typ': 8}\\n# PavedDrive\\npaved_drive_map = {'N': 1, 'P': 2, 'Y': 3}\\n# Fence quality\\nfence_map = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, np.nan: 0}\\n# MasVnrType map\\nmas_vnr_type_map = {'None': 0, 'BrkCmn': 1, 'CBlock': 1, 'Stone': 3, 'BrkFace': 2, np.nan: 0}\\n# Electrical map\\nelectrical_map = {'FuseP': 1, 'FuseF': 2, 'FuseA': 3, 'SBrkr': 4, 'Mix': 2.5}\\n\\n\\n# (Square footage of 2nd floor as a proportion of total above ground living area)\\n# Usefulness: Helps understand the layout and style of the house. A higher proportion of 2nd floor could indicate a more vertical, possibly newer construction style.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672], 'GrLivArea': [1144, 2520, 1520]}\\ndf['2ndFlrSF_ratio_GrLivArea'] = df['2ndFlrSF'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Basement finished area 1 as a proportion of total basement area)\\n# Usefulness: Quantifies the extent and quality of finished basement space, which can significantly influence a home's value by adding usable square footage.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinSF1_ratio_TotalBsmtSF'] = df['BsmtFinSF1'] / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtFinSF1_ratio_TotalBsmtSF'] = df['BsmtFinSF1_ratio_TotalBsmtSF'].fillna(0)\\n\\n# (Unfinished Basement Area as a proportion of total basement area)\\n# Usefulness: Indicates potential for future finishing by homeowners, impacting the future value or initial desirability for buyers seeking customization.\\n# Input samples: {'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtUnfSF_ratio_TotalBsmtSF'] = df['BsmtUnfSF'] / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtUnfSF_ratio_TotalBsmtSF'] = df['BsmtUnfSF_ratio_TotalBsmtSF'].fillna(0)\\n\\n# (Combined score for Basement Finished Type 1 and Type 2)\\n# Usefulness: A weighted average of basement finished areas, accounting for their quality ratings. More \\\"Good Living Quarters\\\" contributes more value.\\n# Input samples: {'BsmtFinType1': ['BLQ', 'GLQ', 'Rec'], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinType2': ['Unf', 'Unf', 'Unf'], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]}\\nbsmt_fin_type1_score = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\nbsmt_fin_type2_score = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\ndf['BsmtFinSF_Weighted'] = (df['BsmtFinSF1'] * bsmt_fin_type1_score + df['BsmtFinSF2'] * bsmt_fin_type2_score) / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtFinSF_Weighted'] = df['BsmtFinSF_Weighted'].fillna(0)\\n\\n# (Quality of Pool)\\n# Usefulness: Indicates the quality of the pool if present. Pools can be a significant amenity, and their condition influences desirability. A 0 indicates no pool.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns: # Check if 'PoolQC' column exists before trying to map it\\n    df['PoolQC_Score'] = df['PoolQC'].map(quality_map_general)\\nelse:\\n    df['PoolQC_Score'] = 0 # Default to 0 if column is missing, effectively indicating no pool or no quality assessment.\\n\\n# (Quality of Fence)\\n# Usefulness: A good quality fence can enhance privacy, security, and aesthetics, adding to property value. A 0 indicates no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_map)\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Similar to house age, garage age matters. An old garage might need renovation or indicate wear. A value near 0 means garage built same year as sold (new or remodeled recently).\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAgeAtSale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\ndf['GarageAgeAtSale'] = df['GarageAgeAtSale'].apply(lambda x: x if x >= 0 else 0)\\n\\n# (Number of Years between Built and Remodel/Add)\\n# Usefulness: Shows how long a house existed before its first (or only) remodel. A longer period could suggest original parts are older, or significant overhaul was needed.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['Years_Since_Built_vs_Remod'] = df['YearRemodAdd'] - df['YearBuilt']\\ndf['Years_Since_Built_vs_Remod'] = df['Years_Since_Built_vs_Remod'].apply(lambda x: x if x >= 0 else 0)\\n\\n# (Binary: Is house new build (same year built as sold and no remodel))\\n# Usefulness: New homes typically command higher prices due to modern design, features, and less maintenance initially. This identifies new construction.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['Is_New_Build'] = ((df['YearBuilt'] == df['YrSold']) & (df['YearBuilt'] == df['YearRemodAdd'])).astype(int)\\n\\n# (Is property located on a corner lot or cul-de-sac)\\n# Usefulness: These lot configurations can influence privacy, traffic, and access, often viewed positively by buyers.\\n# Input samples: {'LotConfig': ['Corner', 'Corner', 'Inside']}\\ndf['Is_Corner_CulDSac'] = ((df['LotConfig'] == 'Corner') | (df['LotConfig'] == 'CulDSac')).astype(int)\\n\\n# (Log Transformation of LotFrontage - impute missing)\\n# Usefulness: LotFrontage is often skewed and has missing values. Log transformation can stabilize variance. Imputing with median ensures consistency.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['Log_LotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (MasVnr Area Interaction with MasVnr Type Score)\\n# Usefulness: Combines the physical area of masonry veneer with a quality score from its type. A larger area of quality veneer contributes more to value.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]}\\nmas_vnr_type_score_mapped = df['MasVnrType'].map(mas_vnr_type_map).fillna(0)\\ndf['MasVnr_QualityArea'] = df['MasVnrArea'].fillna(0) * mas_vnr_type_score_mapped\\n\\n# (Total square feet per room above grade)\\n# Usefulness: Indicates average room size above grade. Larger rooms are often more desirable, indicating a more spacious layout.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['GrLivArea_Per_Room'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1)\\n\\n# (Number of stories inferred from HouseStyle)\\n# Usefulness: Indicates the number of floors, which is a key structural attribute influencing vertical space and overall perceived size.\\n# Input samples: {'HouseStyle': ['1Story', '2Story', '1.5Fin']}\\ndf['NumStories'] = df['HouseStyle'].map({\\n    '1Story': 1, '1.5Unf': 1.5, '1.5Fin': 1.5, '2Story': 2, '2.5Unf': 2.5, '2.5Fin': 2.5,\\n    'SFoyer': 1, 'SLvl': 1,\\n}).fillna(1)\\n\\n# (Functional - Is Non-Typical Functionality?)\\n# Usefulness: Flagging homes that have any degree of functional defect, which could indicate problems impacting value.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_NonTypical_Binary'] = (df['Functional'] != 'Typ').astype(int)\\n\\n# (Electrical Quality Score)\\n# Usefulness: Maps the 'Electrical' system to an ordinal score. A robust electrical system is crucial for safety and functionality.\\n# Input samples: {'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']}\\ndf['Electrical_Score'] = df['Electrical'].map(electrical_map).fillna(df['Electrical'].map(electrical_map).mode()[0])\\n\\n# (Bedroom above grade squared)\\n# Usefulness: Number of bedrooms often has a non-linear relationship with price.\\n# Input samples: {'BedroomAbvGr': [3, 5, 3]}\\ndf['BedroomAbvGr_Sq'] = df['BedroomAbvGr'] ** 2\\n\\n# (Total Area excluding basement - Living + Garage)\\n# Usefulness: Focuses on the accessible and main living/car areas of the home.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'GarageArea': [264, 796, 281]}\\ndf['AboveGroundAreaPlusGarage'] = df['GrLivArea'] + df['GarageArea']\\n\\n# (Binary: Does MSZoning represent a residential area?)\\n# Usefulness: Flag to easily differentiate residential vs. non-residential properties.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\ndf['Is_Residential_Zoning'] = df['MSZoning'].isin(['RL', 'RM', 'RH', 'FV', 'RP']).astype(int)\\n\\n# (YearRemodAdd same as YearBuilt)\\n# Usefulness: Indicates if the property has never been remodeled since its construction.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['No_Remodel_Since_Built'] = (df['YearRemodAdd'] == df['YearBuilt']).astype(int)\\n\\n# (Combined ExterQual & OverallQual score)\\n# Usefulness: Multiplies two key quality indicators to potentially capture a stronger non-linear effect.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Quality_Product'] = df['OverallQual'] * df['ExterQual'].map(quality_map_general)\\n\\n# (Binary: Property adjacent to (positive) off-site feature)\\n# Usefulness: Identifies properties benefiting from desirable external features like parks or greenbelts.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['Near_Positive_Feature'] = (\\n    (df['Condition1'].isin(['PosN', 'PosA'])) |\\n    (df['Condition2'].isin(['PosN', 'PosA']))\\n).astype(int)\\n\\n# (Binary: Property adjacent to undesirable feature like arterial/feeder street or railroad)\\n# Usefulness: Flags properties potentially negatively impacted by proximity to high-traffic areas or noise sources.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\nundesirable_features = ['Artery', 'Feedr', 'RRNn', 'RRAn', 'RRNe', 'RRAe']\\ndf['Near_Undesirable_Feature'] = (\\n    (df['Condition1'].isin(undesirable_features)) |\\n    (df['Condition2'].isin(undesirable_features))\\n).astype(int)\\n\\n# (Log Transformation of MasVnrArea)\\n# Usefulness: Addresses potential skewness in masonry veneer area, helping linear models. Handles zeros with log1p.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['Log_MasVnrArea'] = np.log1p(df['MasVnrArea'].fillna(0))\\n\\n# (Paved Driveway Quality Score)\\n# Usefulness: Converts `PavedDrive` to an ordinal score. A fully paved driveway is generally preferred.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Score'] = df['PavedDrive'].map(paved_drive_map)\\ndf['PavedDrive_Score'] = df['PavedDrive_Score'].fillna(0) # Should not be NaN if map covers all types, but safe\\n\\n# (Building Type - Is Townhouse?)\\n# Usefulness: Binary flag for townhouses. Townhouses often have different price dynamics.\\n# Input samples: {'BldgType': ['1Fam', '1Fam', '1Fam']}\\ndf['Is_Townhouse'] = df['BldgType'].isin(['TwnhsE', 'TwnhsI']).astype(int)\\n\\n# (Total Full and Half Baths Above Grade)\\n# Usefulness: Captures the number of easily accessible bathrooms (excluding basement), which is a crucial selling point and contributor to a home's comfort and value. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]}\\ndf['FullHalfBath_AboveGrade'] = df['FullBath'] + 0.5 * df['HalfBath']\\n\"}, {\"search_node\": {\"trial\": 10, \"parent_trial\": 6, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\", \"score\": -0.1149670157247227}], \"predefined_state\": null, \"parent_score\": -0.1149670157247227, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality map for categorical ordinal features where 'NA' means 'no item'\\nquality_rating_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Pool specific quality map where 'NA' means 'no pool'\\npool_quality_map = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\n# Fence specific quality map where 'NA' means 'no fence'\\nfence_quality_map = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- Features from previous blocks (re-created due to error state reset) ---\\n\\n# (Total Living Area SF)\\n# Usefulness: Sum of above-grade living area and total basement square footage. Represents the primary usable living space.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Consolidates all full and half bathrooms into a single metric, valuing half baths as 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age at Sale)\\n# Usefulness: The age of the house when it was sold. Newer homes often command higher prices due to modern design and less wear.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel)\\n# Usefulness: The number of years since the last remodeling. Recent remodels usually increase home value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: Multiplies OverallQual by OverallCond to capture a synergistic effect. Higher values reflect exceptionally well-maintained high-quality homes.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Log-transformed Lot Area)\\n# Usefulness: A log transform reduces skewness in 'LotArea', making its relationship with sale price more linear.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Presence of a Fireplace)\\n# Usefulness: A binary flag for whether the property has any fireplaces, often seen as a desirable amenity.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Presence of a Basement)\\n# Usefulness: Binary flag indicating if the house includes a basement, which adds storage and potential finished space.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Presence of a Garage)\\n# Usefulness: Binary flag for the presence of any garage space. A crucial feature for most homeowners.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Total Exterior Porch and Deck Area)\\n# Usefulness: Sums all square footage from various outdoor covered/deck areas. More outdoor living space generally increases appeal.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Exterior Quality Score)\\n# Usefulness: Numerical conversion of `ExterQual`, reflecting the quality of exterior materials. Good exterior quality enhances curb appeal and perceived value.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Numerical conversion of `KitchenQual`. The kitchen is a key selling point, so its quality heavily influences buyer interest.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Basement Quality Score)\\n# Usefulness: Numerical conversion of `BsmtQual`. Indicates basement quality and functionality, where 'NA' (no basement) maps to 0.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Numerical conversion of `HeatingQC`. High-quality heating contributes to comfort and lower utility costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Numerical conversion of `FireplaceQu`. Quality of fireplaces adds to luxury feel; 'NA' (no fireplace) maps to 0.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Combined Garage Quality Score)\\n# Usefulness: Sums `GarageQual` and `GarageCond` numerical scores. Represents the overall condition and quality of the garage, where 'NA' means no garage (scores 0).\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_Score'] = df['GarageQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['GarageCond_Score'] = df['GarageCond'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['TotalGarageQualityScore'] = df['GarageQual_Score'] + df['GarageCond_Score']\\n\\n# (Age Since Garage Update)\\n# Usefulness: Calculates the years since the garage was built or last extensively remodeled (using max of GarageYrBlt and YearRemodAdd). Newer updates typically indicate better condition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['GarageYrBlt_filled'] = df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt_filled'], df['YearRemodAdd'])\\n\\n# (Home Functionality Score)\\n# Usefulness: Ordinal numerical score for `Functional` status, with 'Typ' being the highest. Reflects the general functionality and repair needs of the house.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7)\\n\\n# (Presence of Masonry Veneer)\\n# Usefulness: A binary flag indicating whether the house has any masonry veneer (brick, stone, etc.). This feature often adds to a home's aesthetic appeal and durability. `MasVnrArea` NaNs are filled with 0.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]}\\ndf['HasMasonryVeneer'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Log-transformed Lot Frontage)\\n# Usefulness: A log transform normalizes the skewed distribution of 'LotFrontage' and smooths its relationship with SalePrice. Missing values are filled with the median.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (Proximity to Positive Off-site Features)\\n# Usefulness: Binary flag if the property is near or adjacent to desirable features like parks. Such locations typically increase property value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['IsNearPositiveFeature'] = ((df['Condition1'].str.contains('Pos')) | (df['Condition2'].str.contains('Pos'))).astype(int)\\n\\n# (Ratio of Garage Area to Car Capacity)\\n# Usefulness: Calculates the average square footage per car in the garage. This might indicate whether a garage offers more than just parking space. Handles cases where GarageCars is zero by making the ratio 0.\\n# Input samples: {'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]}\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars'].replace(0, 1)\\n\\n# (Indicates Near Major Traffic or Railroad)\\n# Usefulness: Binary flag if the property is close to sources of noise or inconvenience like arterial streets or railroads, which can negatively affect value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['NearMajorTrafficRail'] = (\\n    (df['Condition1'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe'])) |\\n    (df['Condition2'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe']))\\n).astype(int)\\n\\n# (Presence of a Pool)\\n# Usefulness: A binary flag indicating if the property includes a pool. Pools are a luxury feature that can increase value in suitable climates/markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Pool Quality Score)\\n# Usefulness: Numerical conversion of `PoolQC`. High-quality pools are more desirable; 'NA' (no pool) maps to 0. Handles potential absence of the 'PoolQC' column.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map).fillna(pool_quality_map['NA'])\\nelse:\\n    # If PoolQC column is not present, assume no pool quality, mapping to 0\\n    df['PoolQC_Score'] = 0\\n\\n# (Remodeled More Recently Than Built)\\n# Usefulness: Binary flag indicating if the `YearRemodAdd` is later than `YearBuilt`. This shows whether the house has undergone a significant modernization.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodeledRecently'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Is Residential)\\n# Usefulness: Binary flag indicating if the property's zoning is residential ('RL', 'RH', 'RM', 'FV', 'RP'). Residential properties are the most common type for single-family homes and may have different price dynamics.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\ndf['IsResidential'] = df['MSZoning'].isin(['RL', 'RH', 'RM', 'FV', 'RP']).astype(int)\\n\\n# (Lot Shape Irregularity Score)\\n# Usefulness: Maps lot shape to an ordinal score, where 'Reg' is most regular (lowest score) and 'IR3' is most irregular (highest score). Irregular lots can sometimes be less desirable or harder to develop.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map({'Reg': 0, 'IR1': 1, 'IR2': 2, 'IR3': 3}).fillna(0)\\n\\n# (Has Utilities for All Public Services)\\n# Usefulness: Binary flag for properties with 'AllPub' utilities. Indicates full standard utility access, a basic expectation that might have a floor effect on value. If 'Utilities' is missing, assume not 'AllPub'.\\n# Input samples: {'Utilities': ['AllPub', 'AllPub', 'AllPub']}\\nif 'Utilities' in df.columns:\\n    df['HasAllPublicUtilities'] = (df['Utilities'] == 'AllPub').astype(int)\\nelse:\\n    df['HasAllPublicUtilities'] = 1 # Assume all public utilities if column missing, as AllPub is dominant in samples.\\n\\n# (Total Baths * OverallQual)\\n# Usefulness: Interaction term combining the total number of bathrooms with overall quality. More baths in a higher quality home indicates higher luxury.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'OverallQual': [5, 8, 5]}\\ndf['TotalBath_x_OverallQual'] = df['TotalBath'] * df['OverallQual']\"]}, \"score\": -0.11434282337426378, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality map for categorical ordinal features where 'NA' means 'no item'\\nquality_rating_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Pool specific quality map where 'NA' means 'no pool'\\npool_quality_map = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\n# Fence specific quality map where 'NA' means 'no fence'\\nfence_quality_map = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- Features from previous blocks (re-created due to error state reset) ---\\n\\n# (Total Living Area SF)\\n# Usefulness: Sum of above-grade living area and total basement square footage. Represents the primary usable living space.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Consolidates all full and half bathrooms into a single metric, valuing half baths as 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age at Sale)\\n# Usefulness: The age of the house when it was sold. Newer homes often command higher prices due to modern design and less wear.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel)\\n# Usefulness: The number of years since the last remodeling. Recent remodels usually increase home value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: Multiplies OverallQual by OverallCond to capture a synergistic effect. Higher values reflect exceptionally well-maintained high-quality homes.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Log-transformed Lot Area)\\n# Usefulness: A log transform reduces skewness in 'LotArea', making its relationship with sale price more linear.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Presence of a Fireplace)\\n# Usefulness: A binary flag for whether the property has any fireplaces, often seen as a desirable amenity.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Presence of a Basement)\\n# Usefulness: Binary flag indicating if the house includes a basement, which adds storage and potential finished space.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Presence of a Garage)\\n# Usefulness: Binary flag for the presence of any garage space. A crucial feature for most homeowners.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Total Exterior Porch and Deck Area)\\n# Usefulness: Sums all square footage from various outdoor covered/deck areas. More outdoor living space generally increases appeal.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Exterior Quality Score)\\n# Usefulness: Numerical conversion of `ExterQual`, reflecting the quality of exterior materials. Good exterior quality enhances curb appeal and perceived value.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Numerical conversion of `KitchenQual`. The kitchen is a key selling point, so its quality heavily influences buyer interest.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Basement Quality Score)\\n# Usefulness: Numerical conversion of `BsmtQual`. Indicates basement quality and functionality, where 'NA' (no basement) maps to 0.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Numerical conversion of `HeatingQC`. High-quality heating contributes to comfort and lower utility costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Numerical conversion of `FireplaceQu`. Quality of fireplaces adds to luxury feel; 'NA' (no fireplace) maps to 0.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Combined Garage Quality Score)\\n# Usefulness: Sums `GarageQual` and `GarageCond` numerical scores. Represents the overall condition and quality of the garage, where 'NA' means no garage (scores 0).\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_Score'] = df['GarageQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['GarageCond_Score'] = df['GarageCond'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['TotalGarageQualityScore'] = df['GarageQual_Score'] + df['GarageCond_Score']\\n\\n# (Age Since Garage Update)\\n# Usefulness: Calculates the years since the garage was built or last extensively remodeled (using max of GarageYrBlt and YearRemodAdd). Newer updates typically indicate better condition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['GarageYrBlt_filled'] = df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt_filled'], df['YearRemodAdd'])\\n\\n# (Home Functionality Score)\\n# Usefulness: Ordinal numerical score for `Functional` status, with 'Typ' being the highest. Reflects the general functionality and repair needs of the house.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7)\\n\\n# (Presence of Masonry Veneer)\\n# Usefulness: A binary flag indicating whether the house has any masonry veneer (brick, stone, etc.). This feature often adds to a home's aesthetic appeal and durability. `MasVnrArea` NaNs are filled with 0.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]}\\ndf['HasMasonryVeneer'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Log-transformed Lot Frontage)\\n# Usefulness: A log transform normalizes the skewed distribution of 'LotFrontage' and smooths its relationship with SalePrice. Missing values are filled with the median.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (Proximity to Positive Off-site Features)\\n# Usefulness: Binary flag if the property is near or adjacent to desirable features like parks. Such locations typically increase property value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['IsNearPositiveFeature'] = ((df['Condition1'].str.contains('Pos')) | (df['Condition2'].str.contains('Pos'))).astype(int)\\n\\n# (Ratio of Garage Area to Car Capacity)\\n# Usefulness: Calculates the average square footage per car in the garage. This might indicate whether a garage offers more than just parking space. Handles cases where GarageCars is zero by making the ratio 0.\\n# Input samples: {'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]}\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars'].replace(0, 1)\\n\\n# (Indicates Near Major Traffic or Railroad)\\n# Usefulness: Binary flag if the property is close to sources of noise or inconvenience like arterial streets or railroads, which can negatively affect value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['NearMajorTrafficRail'] = (\\n    (df['Condition1'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe'])) |\\n    (df['Condition2'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe']))\\n).astype(int)\\n\\n# (Presence of a Pool)\\n# Usefulness: A binary flag indicating if the property includes a pool. Pools are a luxury feature that can increase value in suitable climates/markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Pool Quality Score)\\n# Usefulness: Numerical conversion of `PoolQC`. High-quality pools are more desirable; 'NA' (no pool) maps to 0. Handles potential absence of the 'PoolQC' column.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map).fillna(pool_quality_map['NA'])\\nelse:\\n    # If PoolQC column is not present, assume no pool quality, mapping to 0\\n    df['PoolQC_Score'] = 0\\n\\n# (Remodeled More Recently Than Built)\\n# Usefulness: Binary flag indicating if the `YearRemodAdd` is later than `YearBuilt`. This shows whether the house has undergone a significant modernization.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodeledRecently'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Is Residential)\\n# Usefulness: Binary flag indicating if the property's zoning is residential ('RL', 'RH', 'RM', 'FV', 'RP'). Residential properties are the most common type for single-family homes and may have different price dynamics.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\ndf['IsResidential'] = df['MSZoning'].isin(['RL', 'RH', 'RM', 'FV', 'RP']).astype(int)\\n\\n# (Lot Shape Irregularity Score)\\n# Usefulness: Maps lot shape to an ordinal score, where 'Reg' is most regular (lowest score) and 'IR3' is most irregular (highest score). Irregular lots can sometimes be less desirable or harder to develop.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map({'Reg': 0, 'IR1': 1, 'IR2': 2, 'IR3': 3}).fillna(0)\\n\\n# (Has Utilities for All Public Services)\\n# Usefulness: Binary flag for properties with 'AllPub' utilities. Indicates full standard utility access, a basic expectation that might have a floor effect on value. If 'Utilities' is missing, assume not 'AllPub'.\\n# Input samples: {'Utilities': ['AllPub', 'AllPub', 'AllPub']}\\nif 'Utilities' in df.columns:\\n    df['HasAllPublicUtilities'] = (df['Utilities'] == 'AllPub').astype(int)\\nelse:\\n    df['HasAllPublicUtilities'] = 1 # Assume all public utilities if column missing, as AllPub is dominant in samples.\\n\\n# (Total Baths * OverallQual)\\n# Usefulness: Interaction term combining the total number of bathrooms with overall quality. More baths in a higher quality home indicates higher luxury.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'OverallQual': [5, 8, 5]}\\ndf['TotalBath_x_OverallQual'] = df['TotalBath'] * df['OverallQual']\"}, {\"search_node\": {\"trial\": 11, \"parent_trial\": 5, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import pandas as pd\\nimport numpy as np\\n\\n# (Exterior Quality - Encoded)\\n# Usefulness: Translates the ordinal quality of the material on the exterior into a numerical scale, providing a direct, quantitative measure for the regression model to associate with SalePrice. Higher quality generally means higher price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Enc'] = df['ExterQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Exterior Condition - Encoded)\\n# Usefulness: Converts the ordinal condition of the exterior materials into a numerical scale, allowing the model to weigh this factor in pricing. Better condition typically indicates higher value.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Enc'] = df['ExterCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Basement Quality - Encoded)\\n# Usefulness: Represents the quality/height of the basement using a numerical scale. Basements significantly impact property value, and this encoding allows the model to directly use this hierarchical information. 'NA' implies no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Enc'] = df['BsmtQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Condition - Encoded)\\n# Usefulness: Numerically quantifies the general condition of the basement, with 'NA' indicating no basement. A well-maintained basement is a positive asset, and this feature helps capture that impact on price.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Enc'] = df['BsmtCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Heating Quality and Condition - Encoded)\\n# Usefulness: Transforms the ordinal rating of heating quality into a numerical feature. Excellent heating systems add more value than poor ones.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Enc'] = df['HeatingQC'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Kitchen Quality - Encoded)\\n# Usefulness: Encodes the quality of the kitchen, which is a major factor in home valuation. A higher quality kitchen corresponds to a higher potential sale price.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Enc'] = df['KitchenQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Fireplace Quality - Encoded)\\n# Usefulness: Converts fireplace quality into a numerical score, with 'NA' signifying no fireplace. Fireplaces are desirable features that influence appeal and price.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Enc'] = df['FireplaceQu'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Quality - Encoded)\\n# Usefulness: Numerically ranks the quality of the garage, where 'NA' means no garage. Garage quality is important for perceived utility and value.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Enc'] = df['GarageQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Condition - Encoded)\\n# Usefulness: Transforms garage condition into a numerical score. Similar to quality, the condition reflects maintenance and functionality, influencing buyer perception and price.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Enc'] = df['GarageCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Lot Shape - Encoded)\\n# Usefulness: Converts the ordinal LotShape categories into a numerical scale where 'Reg' (regular) is most desirable and 'IR3' (irregular) is least. This allows the model to understand the appeal of the lot shape.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['LotShape_Enc'] = df['LotShape'].map({'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}).fillna(0).astype(int)\\n\\n# (Basement Exposure - Encoded)\\n# Usefulness: Ordinally maps basement exposure to a numerical value. Good exposure means more natural light and potential for living space, increasing value. 'NA' means no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Enc'] = df['BsmtExposure'].map({'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 1 - Encoded)\\n# Usefulness: Encodes the primary type of finished basement area. 'GLQ' (Good Living Quarters) is highly desirable for resale, while 'Unf' (Unfinished) or 'NA' (No Basement) contribute less to initial appeal.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Enc'] = df['BsmtFinType1'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 2 - Encoded)\\n# Usefulness: Similar to BsmtFinType1, but for the secondary finished area. Provides granular information on how basement space is utilized, impacting overall livability and value.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Enc'] = df['BsmtFinType2'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Functional - Encoded)\\n# Usefulness: Converts the functionality rating of the home into a numerical scale, where 'Typ' (Typical Functionality) is best and 'Sal' (Salvage only) is worst. Functional issues negatively impact market value.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\ndf['Functional_Enc'] = df['Functional'].map({'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}).fillna(0).astype(int)\\n\\n# (Garage Finish - Encoded)\\n# Usefulness: Ordinally maps the interior finish of the garage. A finished garage ('Fin') typically adds more value and utility compared to an unfinished one ('Unf') or no garage ('NA').\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Enc'] = df['GarageFinish'].map({'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Paved Driveway - Encoded)\\n# Usefulness: Translates driveway paving status into a numerical score, where 'Y' (Paved) is most desirable and 'N' (Dirt/Gravel) is least. This affects curb appeal and utility.\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y']\\ndf['PavedDrive_Enc'] = df['PavedDrive'].map({'Y': 2, 'P': 1, 'N': 0}).fillna(0).astype(int)\\n\\n# (Total Baths - Combined)\\n# Usefulness: Aggregates all full and half bathrooms into a single numerical feature, giving a comprehensive view of bathroom count. Full baths contribute more than half baths.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBaths'] = df['FullBath'] + df['HalfBath'] * 0.5 + df['BsmtFullBath'] + df['BsmtHalfBath'] * 0.5\\n\\n# (Total Above Ground Rooms per Square Foot)\\n# Usefulness: Calculates the density of rooms relative to living area. A higher value might indicate smaller rooms, which could be positive or negative depending on market preference for larger or more numerous rooms.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['RmsPerGrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Total Square Footage)\\n# Usefulness: Combines all major square footage metrics into a single, comprehensive measure of total usable area. This is a primary driver of home price.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total Outdoor Area)\\n# Usefulness: Aggregates all outdoor amenities (decks, porches, screens) into one feature, reflecting the total amount of dedicated outdoor living space, which can significantly enhance a home's appeal and value.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Total Number of Garages Cars and Area interaction)\\n# Usefulness: Combines the car capacity and square footage of the garage, offering a more nuanced understanding of garage utility. Useful garages typically add to property value.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageCapacityArea'] = df['GarageCars'] * df['GarageArea']\\n\\n# (Years Since Built)\\n# Usefulness: Represents the age of the house at the time of sale, calculated from the YearBuilt and YrSold. Newer houses often command higher prices due to modern amenities and less wear.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Remodel)\\n# Usefulness: Calculates the years passed since the last remodel or addition. More recent remodels generally indicate better condition and higher market appeal. If no remodel, it's `YearsSinceBuilt`.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Is Remodeled)\\n# Usefulness: A binary indicator (1 or 0) whether the house has undergone any remodeling. Remodeled homes are often perceived as more valuable than original builds, assuming quality renovations.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['IsRemodeled'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (Overall Quality-Condition Interaction)\\n# Usefulness: Creates an interaction term by multiplying OverallQual and OverallCond. This feature captures how both the material quality and current condition synergistically influence a property's appeal.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQC'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Above Grade SF including Porches)\\n# Usefulness: Combines the main above-ground living area with all porch and deck areas, giving a comprehensive view of above-grade accessible and recreational space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalGrLivSFPlusOutdoor'] = df['GrLivArea'] + df['TotalOutdoorArea']\\n\\n# (Total SF excluding Low Quality Finish)\\n# Usefulness: Represents the primary valuable living space by summing 1st, 2nd floor, and total basement SF, while subtracting any low-quality finished areas.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793], 'LowQualFinSF': [0, 0, 0]\\ndf['HighQualitySF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF'] - df['LowQualFinSF']\\n\\n# (House Age Group)\\n# Usefulness: Categorizes houses into age groups based on 'YearsSinceBuilt' to capture potential non-linear effects of age. Houses within certain age ranges might appeal to different buyer segments.\\n# Input samples: 'YearsSinceBuilt': [48, 13, 77]\\ndf['HouseAgeGroup'] = pd.cut(df['YearsSinceBuilt'], bins=[0, 10, 20, 40, 60, np.inf], labels=[0, 1, 2, 3, 4], right=False, include_lowest=True).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator for whether a property has a pool. Pools are a significant luxury feature, and their presence (or absence) is a key determinant for some buyers.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Lot Config: Is CulDSac or Corner)\\n# Usefulness: Identifies properties located in cul-de-sacs or corner lots, which often offer more privacy, yard space, or specific aesthetic appeal that can increase value.\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside']\\ndf['IsCulDSacOrCorner'] = ((df['LotConfig'] == 'CulDSac') | (df['LotConfig'] == 'Corner')).astype(int)\\n\\n# (Location Density)\\n# Usefulness: Creates a numerical proxy for property density based on lot size. Smaller lots might indicate higher density urban areas, which could influence pricing differently.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LotAreaDensity'] = 1 / np.log(df['LotArea'])\\n\\n# (MasVnrType Indicator)\\n# Usefulness: A binary feature indicating the presence of a masonry veneer. Masonry veneers add to the aesthetic appeal and perceived quality of a home.\\n# Input samples: 'MasVnrType': [nan, nan, nan]\\ndf['HasMasVnr'] = (~df['MasVnrType'].isna()).astype(int)\\n\\n# (Porch Total Area)\\n# Usefulness: Aggregates all types of porches (open, enclosed, 3-season, screen) into one value. Total porch space indicates opportunities for outdoor living and relaxation.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['PorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Computes how old the garage is at the time of sale. Newer garages are generally in better condition and are preferred. Handles NaNs by filling with the YearSold for houses without a garage, resulting in an age of 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\ndf['GarageAge'] = (df['YrSold'] - df['GarageYrBlt']).fillna(0).astype(int) # fillna(0) for missing garage, assuming age 0\\ndf['GarageAge'] = df['GarageAge'].mask(df['GarageType'].isna(), -1) # Assign -1 for houses with no garage at all\\n\\n# (Number of Bedrooms per Total Rooms)\\n# Usefulness: Calculates the ratio of bedrooms to total rooms above grade. This ratio might indicate layout efficiency or focus of the house (e.g., more bedrooms for smaller living spaces vs. fewer bedrooms with larger communal areas).\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['BedBathsPerTotRms'] = (df['BedroomAbvGr'] + df['TotalBaths']) / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Has Alley Access)\\n# Usefulness: A simple binary indicator for whether the property has alley access. This can be either a convenience or a drawback, influencing its specific value.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = (~df['Alley'].isna()).astype(int)\\n\", \"score\": -0.11538058001634222}], \"predefined_state\": null, \"parent_score\": -0.11538058001634222, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import pandas as pd\\nimport numpy as np\\n\\n# (Exterior Quality - Encoded)\\n# Usefulness: Translates the ordinal quality of the material on the exterior into a numerical scale, providing a direct, quantitative measure for the regression model to associate with SalePrice. Higher quality generally means higher price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Enc'] = df['ExterQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Exterior Condition - Encoded)\\n# Usefulness: Converts the ordinal condition of the exterior materials into a numerical scale, allowing the model to weigh this factor in pricing. Better condition typically indicates higher value.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Enc'] = df['ExterCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Basement Quality - Encoded)\\n# Usefulness: Represents the quality/height of the basement using a numerical scale. Basements significantly impact property value, and this encoding allows the model to directly use this hierarchical information. 'NA' implies no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Enc'] = df['BsmtQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Condition - Encoded)\\n# Usefulness: Numerically quantifies the general condition of the basement, with 'NA' indicating no basement. A well-maintained basement is a positive asset, and this feature helps capture that impact on price.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Enc'] = df['BsmtCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Heating Quality and Condition - Encoded)\\n# Usefulness: Transforms the ordinal rating of heating quality into a numerical feature. Excellent heating systems add more value than poor ones.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Enc'] = df['HeatingQC'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Kitchen Quality - Encoded)\\n# Usefulness: Encodes the quality of the kitchen, which is a major factor in home valuation. A higher quality kitchen corresponds to a higher potential sale price.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Enc'] = df['KitchenQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}).fillna(0).astype(int)\\n\\n# (Fireplace Quality - Encoded)\\n# Usefulness: Converts fireplace quality into a numerical score, with 'NA' signifying no fireplace. Fireplaces are desirable features that influence appeal and price.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Enc'] = df['FireplaceQu'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Quality - Encoded)\\n# Usefulness: Numerically ranks the quality of the garage, where 'NA' means no garage. Garage quality is important for perceived utility and value.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Enc'] = df['GarageQual'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Garage Condition - Encoded)\\n# Usefulness: Transforms garage condition into a numerical score. Similar to quality, the condition reflects maintenance and functionality, influencing buyer perception and price.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Enc'] = df['GarageCond'].map({'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Lot Shape - Encoded)\\n# Usefulness: Converts the ordinal LotShape categories into a numerical scale where 'Reg' (regular) is most desirable and 'IR3' (irregular) is least. This allows the model to understand the appeal of the lot shape.\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['LotShape_Enc'] = df['LotShape'].map({'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}).fillna(0).astype(int)\\n\\n# (Basement Exposure - Encoded)\\n# Usefulness: Ordinally maps basement exposure to a numerical value. Good exposure means more natural light and potential for living space, increasing value. 'NA' means no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Enc'] = df['BsmtExposure'].map({'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 1 - Encoded)\\n# Usefulness: Encodes the primary type of finished basement area. 'GLQ' (Good Living Quarters) is highly desirable for resale, while 'Unf' (Unfinished) or 'NA' (No Basement) contribute less to initial appeal.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Enc'] = df['BsmtFinType1'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Basement Finished Type 2 - Encoded)\\n# Usefulness: Similar to BsmtFinType1, but for the secondary finished area. Provides granular information on how basement space is utilized, impacting overall livability and value.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Enc'] = df['BsmtFinType2'].map({'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Functional - Encoded)\\n# Usefulness: Converts the functionality rating of the home into a numerical scale, where 'Typ' (Typical Functionality) is best and 'Sal' (Salvage only) is worst. Functional issues negatively impact market value.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\ndf['Functional_Enc'] = df['Functional'].map({'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}).fillna(0).astype(int)\\n\\n# (Garage Finish - Encoded)\\n# Usefulness: Ordinally maps the interior finish of the garage. A finished garage ('Fin') typically adds more value and utility compared to an unfinished one ('Unf') or no garage ('NA').\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Enc'] = df['GarageFinish'].map({'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0}).fillna(0).astype(int)\\n\\n# (Paved Driveway - Encoded)\\n# Usefulness: Translates driveway paving status into a numerical score, where 'Y' (Paved) is most desirable and 'N' (Dirt/Gravel) is least. This affects curb appeal and utility.\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y']\\ndf['PavedDrive_Enc'] = df['PavedDrive'].map({'Y': 2, 'P': 1, 'N': 0}).fillna(0).astype(int)\\n\\n# (Total Baths - Combined)\\n# Usefulness: Aggregates all full and half bathrooms into a single numerical feature, giving a comprehensive view of bathroom count. Full baths contribute more than half baths.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBaths'] = df['FullBath'] + df['HalfBath'] * 0.5 + df['BsmtFullBath'] + df['BsmtHalfBath'] * 0.5\\n\\n# (Total Above Ground Rooms per Square Foot)\\n# Usefulness: Calculates the density of rooms relative to living area. A higher value might indicate smaller rooms, which could be positive or negative depending on market preference for larger or more numerous rooms.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['RmsPerGrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Total Square Footage)\\n# Usefulness: Combines all major square footage metrics into a single, comprehensive measure of total usable area. This is a primary driver of home price.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total Outdoor Area)\\n# Usefulness: Aggregates all outdoor amenities (decks, porches, screens) into one feature, reflecting the total amount of dedicated outdoor living space, which can significantly enhance a home's appeal and value.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Total Number of Garages Cars and Area interaction)\\n# Usefulness: Combines the car capacity and square footage of the garage, offering a more nuanced understanding of garage utility. Useful garages typically add to property value.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageCapacityArea'] = df['GarageCars'] * df['GarageArea']\\n\\n# (Years Since Built)\\n# Usefulness: Represents the age of the house at the time of sale, calculated from the YearBuilt and YrSold. Newer houses often command higher prices due to modern amenities and less wear.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Remodel)\\n# Usefulness: Calculates the years passed since the last remodel or addition. More recent remodels generally indicate better condition and higher market appeal. If no remodel, it's `YearsSinceBuilt`.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Is Remodeled)\\n# Usefulness: A binary indicator (1 or 0) whether the house has undergone any remodeling. Remodeled homes are often perceived as more valuable than original builds, assuming quality renovations.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['IsRemodeled'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (Overall Quality-Condition Interaction)\\n# Usefulness: Creates an interaction term by multiplying OverallQual and OverallCond. This feature captures how both the material quality and current condition synergistically influence a property's appeal.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQC'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Above Grade SF including Porches)\\n# Usefulness: Combines the main above-ground living area with all porch and deck areas, giving a comprehensive view of above-grade accessible and recreational space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalGrLivSFPlusOutdoor'] = df['GrLivArea'] + df['TotalOutdoorArea']\\n\\n# (Total SF excluding Low Quality Finish)\\n# Usefulness: Represents the primary valuable living space by summing 1st, 2nd floor, and total basement SF, while subtracting any low-quality finished areas.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793], 'LowQualFinSF': [0, 0, 0]\\ndf['HighQualitySF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF'] - df['LowQualFinSF']\\n\\n# (House Age Group)\\n# Usefulness: Categorizes houses into age groups based on 'YearsSinceBuilt' to capture potential non-linear effects of age. Houses within certain age ranges might appeal to different buyer segments.\\n# Input samples: 'YearsSinceBuilt': [48, 13, 77]\\ndf['HouseAgeGroup'] = pd.cut(df['YearsSinceBuilt'], bins=[0, 10, 20, 40, 60, np.inf], labels=[0, 1, 2, 3, 4], right=False, include_lowest=True).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator for whether a property has a pool. Pools are a significant luxury feature, and their presence (or absence) is a key determinant for some buyers.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Lot Config: Is CulDSac or Corner)\\n# Usefulness: Identifies properties located in cul-de-sacs or corner lots, which often offer more privacy, yard space, or specific aesthetic appeal that can increase value.\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside']\\ndf['IsCulDSacOrCorner'] = ((df['LotConfig'] == 'CulDSac') | (df['LotConfig'] == 'Corner')).astype(int)\\n\\n# (Location Density)\\n# Usefulness: Creates a numerical proxy for property density based on lot size. Smaller lots might indicate higher density urban areas, which could influence pricing differently.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LotAreaDensity'] = 1 / np.log(df['LotArea'])\\n\\n# (MasVnrType Indicator)\\n# Usefulness: A binary feature indicating the presence of a masonry veneer. Masonry veneers add to the aesthetic appeal and perceived quality of a home.\\n# Input samples: 'MasVnrType': [nan, nan, nan]\\ndf['HasMasVnr'] = (~df['MasVnrType'].isna()).astype(int)\\n\\n# (Porch Total Area)\\n# Usefulness: Aggregates all types of porches (open, enclosed, 3-season, screen) into one value. Total porch space indicates opportunities for outdoor living and relaxation.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['PorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Computes how old the garage is at the time of sale. Newer garages are generally in better condition and are preferred. Handles NaNs by filling with the YearSold for houses without a garage, resulting in an age of 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\ndf['GarageAge'] = (df['YrSold'] - df['GarageYrBlt']).fillna(0).astype(int) # fillna(0) for missing garage, assuming age 0\\ndf['GarageAge'] = df['GarageAge'].mask(df['GarageType'].isna(), -1) # Assign -1 for houses with no garage at all\\n\\n# (Number of Bedrooms per Total Rooms)\\n# Usefulness: Calculates the ratio of bedrooms to total rooms above grade. This ratio might indicate layout efficiency or focus of the house (e.g., more bedrooms for smaller living spaces vs. fewer bedrooms with larger communal areas).\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['BedBathsPerTotRms'] = (df['BedroomAbvGr'] + df['TotalBaths']) / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Has Alley Access)\\n# Usefulness: A simple binary indicator for whether the property has alley access. This can be either a convenience or a drawback, influencing its specific value.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = (~df['Alley'].isna()).astype(int)\\n\", \"import pandas as pd\\nimport numpy as np\\n\\n# (Central Air Conditioning - Binary)\\n# Usefulness: A binary indicator for whether the house has central air conditioning, a highly desirable feature that significantly impacts comfort and often sale price.\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Has Fence - Binary)\\n# Usefulness: Indicates the presence of a fence. A fence provides privacy and security, which can be appealing to buyers and thus influence the sale price. 'NA' means no fence.\\n# Input samples: 'Fence': ['GdWo', nan, nan]\\ndf['HasFence'] = (~df['Fence'].isna()).astype(int)\\n\\n# (Has Miscellaneous Feature - Binary)\\n# Usefulness: Denotes the presence of any miscellaneous feature not covered elsewhere. While 'MiscVal' provides the value, this binary feature flags the existence of an additional special feature, which could be an attractive point. 'NA' means no miscellaneous feature.\\n# Input samples: 'MiscFeature': ['Shed', nan, nan]\\ndf['HasMiscFeature'] = (~df['MiscFeature'].isna()).astype(int)\\n\\n# (Basement Present - Binary)\\n# Usefulness: A simple indicator of whether the house has a basement. Basements add considerable square footage and storage, influencing the perceived value and utility.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Garage Present - Binary)\\n# Usefulness: Flags the existence of a garage. Garages are essential for vehicle storage and often for extra utility space, greatly affecting a home's functionality and market value.\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Functional - Good/Typical vs Minor/Major Deductions)\\n# Usefulness: Simplifies the 'Functional' categorical feature into a binary indicating whether the house is of typical functionality or has significant issues. Major deductions imply repair costs and lower appeal.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\ndf['Functional_Good'] = (df['Functional'].isin(['Typ', 'Min1', 'Min2'])).astype(int)\\n\\n# (Age of house when sold for remodelled homes - interaction term)\\n# Usefulness: Captures the 'modernity' effect, especially relevant for remodelled homes. Houses that were remodelled more recently relative to their original construction might be valued differently. This applies 'YearsSinceRemodel' only when a remodel has happened.\\n# Input samples: 'YearsSinceRemod_OrigBuilt_Diff': [48-26, 13-0, 77-68] --> [22, 13, 9] (assuming remodelled dates given are correct)\\ndf['YearsSinceRemod_WhenRemodeled'] = df['YearsSinceRemodel'].copy()\\ndf.loc[df['IsRemodeled'] == 0, 'YearsSinceRemod_WhenRemodeled'] = df['YearsSinceBuilt']\\n\\n# (Area of Garage as percentage of Total Living Area)\\n# Usefulness: Ratio of garage space to overall living area. This can indicate how much a property emphasizes utility/vehicle space versus pure living space, potentially appealing to different buyer segments.\\n# Input samples: 'GarageArea': [264, 796, 281], 'GrLivArea': [1144, 2520, 1520]\\ndf['GarageRatioToGrLivArea'] = df['GarageArea'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Ratio of Above Grade Rooms to Bedrooms)\\n# Usefulness: Indicates the proportion of common living spaces (excluding bathrooms) relative to bedrooms. A higher ratio might imply more open or dedicated non-sleeping areas.\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]\\ndf['RmsToBedRatio'] = df['TotRmsAbvGrd'] / (df['BedroomAbvGr'] + 1e-6)\\n\\n# (BsmtFinSF1 Ratio to Total Basement SF)\\n# Usefulness: Represents the proportion of high-quality finished basement space. A larger portion of \\\"Type 1 finished\\\" space can increase value and livability of the basement.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1'] / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1Ratio'].fillna(0) # For houses without basement\\n\\n# (Overall Quality Multiplied by Basement Quality)\\n# Usefulness: An interaction feature that combines the general quality of the house with the quality of its basement. A high-quality basement in a high-quality house is a strong value driver.\\n# Input samples: 'OverallQual': [5, 8, 5], 'BsmtQual_Enc': [3, 4, 3]\\ndf['OverallQual_BsmtQual'] = df['OverallQual'] * df['BsmtQual_Enc']\\n\\n# (Overall Quality Multiplied by Kitchen Quality)\\n# Usefulness: Represents the combined impact of the overall house quality and the kitchen quality, which is often a focal point for buyers and a strong predictor of value.\\n# Input samples: 'OverallQual': [5, 8, 5], 'KitchenQual_Enc': [3, 4, 3]\\ndf['OverallQual_KitchenQual'] = df['OverallQual'] * df['KitchenQual_Enc']\\n\\n# (MasVnrArea Binned)\\n# Usefulness: Converts continuous 'MasVnrArea' into categorical bins. This captures non-linear effects, e.g., small veneer areas might add some value, while very large areas add disproportionately more or are grouped differently. `fillna(0)` handles missing MasVnrArea as no veneer.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea_Binned'] = pd.cut(df['MasVnrArea'].fillna(0), bins=[-1, 1, 100, 500, np.inf], labels=[0, 1, 2, 3], right=True, include_lowest=True).astype(int)\\n\\n# (MSZoning: Is Residential Low Density/Floating Village Residential)\\n# Usefulness: Combines common desirable residential zoning types ('RL', 'FV') into a binary feature, potentially highlighting more attractive neighborhood characteristics compared to commercial or industrial zones.\\n# Input samples: 'MSZoning': ['RL', 'RL', 'RH']\\ndf['IsResidentialPopularZone'] = ((df['MSZoning'] == 'RL') | (df['MSZoning'] == 'FV')).astype(int)\\n\\n# (Total Room SF: GrLivArea divided by Total Rooms Above Ground)\\n# Usefulness: Average square footage per room above ground. This can reveal whether rooms are generally spacious or smaller and numerous.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AvgRoomSizeGrLiv'] = df['GrLivArea'] / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Age Category from YearBuilt relative to average build year)\\n# Usefulness: Categorizes houses as 'old' or 'new' relative to a common average build year (e.g., median build year). This could capture market preferences for certain eras.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932]\\nmedian_year_built = df['YearBuilt'].median()\\ndf['AgeCategory_RelToMedian'] = (df['YearBuilt'] > median_year_built).astype(int)\\n\\n# (Effective Age of House (min of years since built/remodel))\\n# Usefulness: Provides a single 'effective age' by taking the minimum of `YearsSinceBuilt` and `YearsSinceRemodel`. This captures the perceived newness of the most significant recent update to the house.\\n# Input samples: 'YearsSinceBuilt': [48, 13, 77], 'YearsSinceRemodel': [26, 13, 9]\\ndf['EffectiveHouseAge'] = df[['YearsSinceBuilt', 'YearsSinceRemodel']].min(axis=1)\\n\\n# (Has Deck and Open Porch)\\n# Usefulness: Binary feature indicating the presence of both a wooden deck and an open porch. This combo signifies substantial outdoor relaxation/entertaining space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0]\\ndf['HasDeckAndOpenPorch'] = ((df['WoodDeckSF'] > 0) & (df['OpenPorchSF'] > 0)).astype(int)\\n\\n# (Electrical System Encoded: Standard Circuit Breakers vs Others)\\n# Usefulness: Classifies the electrical system into 'modern standard' or 'older/less desirable'. 'SBrkr' indicates a contemporary system, suggesting less risk for buyers.\\n# Input samples: 'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']\\ndf['Electrical_Modern'] = (df['Electrical'] == 'SBrkr').astype(int)\\n\\n# (LandContour: Hillside or Low vs Flat)\\n# Usefulness: Aggregates properties with significant slope or depression. These features can imply more complex landscaping, drainage issues, or unique views, influencing cost and appeal.\\n# Input samples: 'LandContour': ['Lvl', 'Lvl', 'Bnk']\\ndf['LandContour_NotLevel'] = ((df['LandContour'] == 'Bnk') | (df['LandContour'] == 'HLS') | (df['LandContour'] == 'Low')).astype(int)\\n\\n# (Exterior Wall Type Combined Score)\\n# Usefulness: Assigns a subjective numerical score to `Exterior1st` (primary exterior covering) based on common material perception (e.g., Vinyl/Cement are often seen as modern and durable, Asbestos as undesirable). This attempts to capture general quality.\\n# Input samples: 'Exterior1st': ['HdBoard', 'MetalSd', 'VinylSd']\\nexterior_materials_ranking = {\\n    'VinylSd': 5, 'CemntBd': 5, 'Stucco': 4, 'BrkFace': 4, 'Stone': 4, 'ImStucc': 3,\\n    'HdBoard': 3, 'MetalSd': 3, 'Wd Sdng': 3, 'WdShing': 3, 'Plywood': 2,\\n    'BrkComm': 2, 'CBlock': 1, 'AsbShng': 1, 'AsphShn': 1, 'PreCast': 1, 'Other': 1\\n}\\ndf['ExteriorMaterialScore'] = df['Exterior1st'].map(exterior_materials_ranking).fillna(1).astype(int)\\n\\n# (Year of last major modification: Garage or Remodel/Built)\\n# Usefulness: Combines `GarageYrBlt` and `YearRemodAdd` (or `YearBuilt` if no remodel) to get the most recent 'new' year for major parts of the property. This reflects overall perceived modernity.\\n# Input samples: 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['LastMajorModification'] = df[['GarageYrBlt', 'YearRemodAdd']].max(axis=1)\\ndf['LastMajorModification'] = df['LastMajorModification'].fillna(df['YearBuilt'])\\ndf['YearsSinceLastMajorMod'] = df['YrSold'] - df['LastMajorModification']\"]}, \"score\": -0.26622041426932386, \"memory_update\": \"import pandas as pd\\nimport numpy as np\\n\\n# (Central Air Conditioning - Binary)\\n# Usefulness: A binary indicator for whether the house has central air conditioning, a highly desirable feature that significantly impacts comfort and often sale price.\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Has Fence - Binary)\\n# Usefulness: Indicates the presence of a fence. A fence provides privacy and security, which can be appealing to buyers and thus influence the sale price. 'NA' means no fence.\\n# Input samples: 'Fence': ['GdWo', nan, nan]\\ndf['HasFence'] = (~df['Fence'].isna()).astype(int)\\n\\n# (Has Miscellaneous Feature - Binary)\\n# Usefulness: Denotes the presence of any miscellaneous feature not covered elsewhere. While 'MiscVal' provides the value, this binary feature flags the existence of an additional special feature, which could be an attractive point. 'NA' means no miscellaneous feature.\\n# Input samples: 'MiscFeature': ['Shed', nan, nan]\\ndf['HasMiscFeature'] = (~df['MiscFeature'].isna()).astype(int)\\n\\n# (Basement Present - Binary)\\n# Usefulness: A simple indicator of whether the house has a basement. Basements add considerable square footage and storage, influencing the perceived value and utility.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Garage Present - Binary)\\n# Usefulness: Flags the existence of a garage. Garages are essential for vehicle storage and often for extra utility space, greatly affecting a home's functionality and market value.\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Functional - Good/Typical vs Minor/Major Deductions)\\n# Usefulness: Simplifies the 'Functional' categorical feature into a binary indicating whether the house is of typical functionality or has significant issues. Major deductions imply repair costs and lower appeal.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\ndf['Functional_Good'] = (df['Functional'].isin(['Typ', 'Min1', 'Min2'])).astype(int)\\n\\n# (Age of house when sold for remodelled homes - interaction term)\\n# Usefulness: Captures the 'modernity' effect, especially relevant for remodelled homes. Houses that were remodelled more recently relative to their original construction might be valued differently. This applies 'YearsSinceRemodel' only when a remodel has happened.\\n# Input samples: 'YearsSinceRemod_OrigBuilt_Diff': [48-26, 13-0, 77-68] --> [22, 13, 9] (assuming remodelled dates given are correct)\\ndf['YearsSinceRemod_WhenRemodeled'] = df['YearsSinceRemodel'].copy()\\ndf.loc[df['IsRemodeled'] == 0, 'YearsSinceRemod_WhenRemodeled'] = df['YearsSinceBuilt']\\n\\n# (Area of Garage as percentage of Total Living Area)\\n# Usefulness: Ratio of garage space to overall living area. This can indicate how much a property emphasizes utility/vehicle space versus pure living space, potentially appealing to different buyer segments.\\n# Input samples: 'GarageArea': [264, 796, 281], 'GrLivArea': [1144, 2520, 1520]\\ndf['GarageRatioToGrLivArea'] = df['GarageArea'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Ratio of Above Grade Rooms to Bedrooms)\\n# Usefulness: Indicates the proportion of common living spaces (excluding bathrooms) relative to bedrooms. A higher ratio might imply more open or dedicated non-sleeping areas.\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]\\ndf['RmsToBedRatio'] = df['TotRmsAbvGrd'] / (df['BedroomAbvGr'] + 1e-6)\\n\\n# (BsmtFinSF1 Ratio to Total Basement SF)\\n# Usefulness: Represents the proportion of high-quality finished basement space. A larger portion of \\\"Type 1 finished\\\" space can increase value and livability of the basement.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1'] / (df['TotalBsmtSF'] + 1e-6)\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1Ratio'].fillna(0) # For houses without basement\\n\\n# (Overall Quality Multiplied by Basement Quality)\\n# Usefulness: An interaction feature that combines the general quality of the house with the quality of its basement. A high-quality basement in a high-quality house is a strong value driver.\\n# Input samples: 'OverallQual': [5, 8, 5], 'BsmtQual_Enc': [3, 4, 3]\\ndf['OverallQual_BsmtQual'] = df['OverallQual'] * df['BsmtQual_Enc']\\n\\n# (Overall Quality Multiplied by Kitchen Quality)\\n# Usefulness: Represents the combined impact of the overall house quality and the kitchen quality, which is often a focal point for buyers and a strong predictor of value.\\n# Input samples: 'OverallQual': [5, 8, 5], 'KitchenQual_Enc': [3, 4, 3]\\ndf['OverallQual_KitchenQual'] = df['OverallQual'] * df['KitchenQual_Enc']\\n\\n# (MasVnrArea Binned)\\n# Usefulness: Converts continuous 'MasVnrArea' into categorical bins. This captures non-linear effects, e.g., small veneer areas might add some value, while very large areas add disproportionately more or are grouped differently. `fillna(0)` handles missing MasVnrArea as no veneer.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea_Binned'] = pd.cut(df['MasVnrArea'].fillna(0), bins=[-1, 1, 100, 500, np.inf], labels=[0, 1, 2, 3], right=True, include_lowest=True).astype(int)\\n\\n# (MSZoning: Is Residential Low Density/Floating Village Residential)\\n# Usefulness: Combines common desirable residential zoning types ('RL', 'FV') into a binary feature, potentially highlighting more attractive neighborhood characteristics compared to commercial or industrial zones.\\n# Input samples: 'MSZoning': ['RL', 'RL', 'RH']\\ndf['IsResidentialPopularZone'] = ((df['MSZoning'] == 'RL') | (df['MSZoning'] == 'FV')).astype(int)\\n\\n# (Total Room SF: GrLivArea divided by Total Rooms Above Ground)\\n# Usefulness: Average square footage per room above ground. This can reveal whether rooms are generally spacious or smaller and numerous.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AvgRoomSizeGrLiv'] = df['GrLivArea'] / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Age Category from YearBuilt relative to average build year)\\n# Usefulness: Categorizes houses as 'old' or 'new' relative to a common average build year (e.g., median build year). This could capture market preferences for certain eras.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932]\\nmedian_year_built = df['YearBuilt'].median()\\ndf['AgeCategory_RelToMedian'] = (df['YearBuilt'] > median_year_built).astype(int)\\n\\n# (Effective Age of House (min of years since built/remodel))\\n# Usefulness: Provides a single 'effective age' by taking the minimum of `YearsSinceBuilt` and `YearsSinceRemodel`. This captures the perceived newness of the most significant recent update to the house.\\n# Input samples: 'YearsSinceBuilt': [48, 13, 77], 'YearsSinceRemodel': [26, 13, 9]\\ndf['EffectiveHouseAge'] = df[['YearsSinceBuilt', 'YearsSinceRemodel']].min(axis=1)\\n\\n# (Has Deck and Open Porch)\\n# Usefulness: Binary feature indicating the presence of both a wooden deck and an open porch. This combo signifies substantial outdoor relaxation/entertaining space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0]\\ndf['HasDeckAndOpenPorch'] = ((df['WoodDeckSF'] > 0) & (df['OpenPorchSF'] > 0)).astype(int)\\n\\n# (Electrical System Encoded: Standard Circuit Breakers vs Others)\\n# Usefulness: Classifies the electrical system into 'modern standard' or 'older/less desirable'. 'SBrkr' indicates a contemporary system, suggesting less risk for buyers.\\n# Input samples: 'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']\\ndf['Electrical_Modern'] = (df['Electrical'] == 'SBrkr').astype(int)\\n\\n# (LandContour: Hillside or Low vs Flat)\\n# Usefulness: Aggregates properties with significant slope or depression. These features can imply more complex landscaping, drainage issues, or unique views, influencing cost and appeal.\\n# Input samples: 'LandContour': ['Lvl', 'Lvl', 'Bnk']\\ndf['LandContour_NotLevel'] = ((df['LandContour'] == 'Bnk') | (df['LandContour'] == 'HLS') | (df['LandContour'] == 'Low')).astype(int)\\n\\n# (Exterior Wall Type Combined Score)\\n# Usefulness: Assigns a subjective numerical score to `Exterior1st` (primary exterior covering) based on common material perception (e.g., Vinyl/Cement are often seen as modern and durable, Asbestos as undesirable). This attempts to capture general quality.\\n# Input samples: 'Exterior1st': ['HdBoard', 'MetalSd', 'VinylSd']\\nexterior_materials_ranking = {\\n    'VinylSd': 5, 'CemntBd': 5, 'Stucco': 4, 'BrkFace': 4, 'Stone': 4, 'ImStucc': 3,\\n    'HdBoard': 3, 'MetalSd': 3, 'Wd Sdng': 3, 'WdShing': 3, 'Plywood': 2,\\n    'BrkComm': 2, 'CBlock': 1, 'AsbShng': 1, 'AsphShn': 1, 'PreCast': 1, 'Other': 1\\n}\\ndf['ExteriorMaterialScore'] = df['Exterior1st'].map(exterior_materials_ranking).fillna(1).astype(int)\\n\\n# (Year of last major modification: Garage or Remodel/Built)\\n# Usefulness: Combines `GarageYrBlt` and `YearRemodAdd` (or `YearBuilt` if no remodel) to get the most recent 'new' year for major parts of the property. This reflects overall perceived modernity.\\n# Input samples: 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['LastMajorModification'] = df[['GarageYrBlt', 'YearRemodAdd']].max(axis=1)\\ndf['LastMajorModification'] = df['LastMajorModification'].fillna(df['YearBuilt'])\\ndf['YearsSinceLastMajorMod'] = df['YrSold'] - df['LastMajorModification']\"}, {\"search_node\": {\"trial\": 12, \"parent_trial\": 2, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}], \"predefined_state\": null, \"parent_score\": -0.11561350952648, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\"]}, \"score\": -0.11322638968093002, \"memory_update\": \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\"}, {\"search_node\": {\"trial\": 13, \"parent_trial\": 12, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"score\": -0.11322638968093002}], \"predefined_state\": null, \"parent_score\": -0.11322638968093002, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"import pandas as pd\\nimport numpy as np\\n\\n# Helper function for ordinal mapping of quality/condition ratings\\ndef map_quality_condition(series, mapping_dict):\\n    return series.map(mapping_dict).fillna(0).astype(int)\\n\\n# Mapping dictionary for 'Ex', 'Gd', 'TA', 'Fa', 'Po' values. 'NA' will be handled via fillna(0) for categorical columns.\\nqual_map_values = {\\n    'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1\\n}\\n\\n# (LivAreaPerRoom: Above grade living area per total rooms above grade)\\n# Usefulness: Provides insight into the spaciousness of individual rooms, indicating potential luxury or efficiency of floor plan, which can impact desirability and price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, assuming 0 rooms above grade is not practical and impute to 1 for calculation stability.\\n\\n# (FinishedBsmtRatio: Proportion of finished basement area to total basement area)\\n# Usefulness: A higher ratio suggests more of the basement space is functional and finished for living, adding to the usable square footage and overall value of the property.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]\\ndf['FinishedBsmtRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / df['TotalBsmtSF'].replace(0, 1)\\ndf['FinishedBsmtRatio'] = df['FinishedBsmtRatio'].fillna(0) # Handles cases where TotalBsmtSF was originally 0 or NaN\\n\\n# (YearsSinceGarageBuilt: The age of the garage when the house was sold)\\n# Usefulness: Indicates the recency of the garage construction or remodel, which affects its condition and modern appeal, influencing buyer interest and value. NaNs are treated as 'no garage', making its contribution to age 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\n# Fills NaN GarageYrBlt with YrSold for those entries that truly have no garage (and hence no age contribution), making YearsSinceGarageBuilt zero for them.\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (HasMasVnr: Binary indicator if the property has any masonry veneer)\\n# Usefulness: Masonry veneer (e.g., brick, stone) often enhances the home's exterior aesthetic, durability, and perceived value, indicating higher construction or finish quality.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]\\n# Fills NaNs in MasVnrType with 'None' and MasVnrArea with 0 before evaluation.\\ndf['MasVnrType_temp'] = df['MasVnrType'].fillna('None')\\ndf['MasVnrArea_temp'] = df['MasVnrArea'].fillna(0.0)\\ndf['HasMasVnr'] = ((df['MasVnrArea_temp'] > 0) | (df['MasVnrType_temp'] != 'None')).astype(int)\\ndf.drop(['MasVnrType_temp', 'MasVnrArea_temp'], axis=1, inplace=True)\\n\\n# (ExterQual_num: Numerical representation of Exterior Quality)\\n# Usefulness: Converts the qualitative rating of exterior material quality into an ordinal numerical scale, which directly informs models about the build quality impacting price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_num'] = map_quality_condition(df['ExterQual'], qual_map_values)\\n\\n# (KitchenQual_num: Numerical representation of Kitchen Quality)\\n# Usefulness: Kitchen quality is a key selling point. This feature provides a numerical grade, making its significant impact on price accessible to regression algorithms.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_num'] = map_quality_condition(df['KitchenQual'], qual_map_values)\\n\\n# (BsmtQual_num: Numerical representation of Basement Quality)\\n# Usefulness: Ordinally scales the quality (height) of the basement, with 'NA' correctly implying no basement (score of 0), reflecting its contribution to livability and value.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_num'] = map_quality_condition(df['BsmtQual'], {**qual_map_values, 'NA': 0})\\n\\n# (HeatingQC_num: Numerical representation of Heating Quality and Condition)\\n# Usefulness: Translates the categorical heating system quality into an ordinal score, directly feeding into model evaluation of HVAC system efficiency and condition.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_num'] = map_quality_condition(df['HeatingQC'], qual_map_values)\\n\\n# (GarageQual_num: Numerical representation of Garage Quality)\\n# Usefulness: Provides a numerical grade for garage quality, where 'NA' (no garage) maps to 0, offering insight into its contribution to the overall property value.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_num'] = map_quality_condition(df['GarageQual'], {**qual_map_values, 'NA': 0})\\n\\n# (FireplaceQu_num: Numerical representation of Fireplace Quality)\\n# Usefulness: Ranks fireplace quality numerically, with 'NA' (no fireplace) indicating absence, to capture its impact as a desirable amenity influencing sale price.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', np.nan]\\ndf['FireplaceQu_num'] = map_quality_condition(df['FireplaceQu'], {**qual_map_values, 'NA': 0})\\n\\n# (TotalMajorQuality: Aggregate score of several key quality indicators)\\n# Usefulness: A composite score that sums the numerical grades of critical structural and aesthetic components (exterior, kitchen, basement, heating, garage, fireplace, and overall quality), offering a holistic measure of the property's general standing and finish quality.\\n# Input samples: 'ExterQual_num': [3, 4, 3], 'KitchenQual_num': [3, 4, 3], 'BsmtQual_num': [3, 4, 3], 'HeatingQC_num': [5, 5, 5], 'GarageQual_num': [3, 3, 3], 'FireplaceQu_num': [3, 3, 0], 'OverallQual': [5, 8, 5]\\ndf['TotalMajorQuality'] = df['ExterQual_num'] + df['KitchenQual_num'] + df['BsmtQual_num'] + \\\\\\n                          df['HeatingQC_num'] + df['GarageQual_num'] + df['FireplaceQu_num'] + df['OverallQual']\"]}, \"score\": -0.11630963203173136, \"memory_update\": \"import pandas as pd\\nimport numpy as np\\n\\n# Helper function for ordinal mapping of quality/condition ratings\\ndef map_quality_condition(series, mapping_dict):\\n    return series.map(mapping_dict).fillna(0).astype(int)\\n\\n# Mapping dictionary for 'Ex', 'Gd', 'TA', 'Fa', 'Po' values. 'NA' will be handled via fillna(0) for categorical columns.\\nqual_map_values = {\\n    'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1\\n}\\n\\n# (LivAreaPerRoom: Above grade living area per total rooms above grade)\\n# Usefulness: Provides insight into the spaciousness of individual rooms, indicating potential luxury or efficiency of floor plan, which can impact desirability and price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, assuming 0 rooms above grade is not practical and impute to 1 for calculation stability.\\n\\n# (FinishedBsmtRatio: Proportion of finished basement area to total basement area)\\n# Usefulness: A higher ratio suggests more of the basement space is functional and finished for living, adding to the usable square footage and overall value of the property.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]\\ndf['FinishedBsmtRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / df['TotalBsmtSF'].replace(0, 1)\\ndf['FinishedBsmtRatio'] = df['FinishedBsmtRatio'].fillna(0) # Handles cases where TotalBsmtSF was originally 0 or NaN\\n\\n# (YearsSinceGarageBuilt: The age of the garage when the house was sold)\\n# Usefulness: Indicates the recency of the garage construction or remodel, which affects its condition and modern appeal, influencing buyer interest and value. NaNs are treated as 'no garage', making its contribution to age 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\n# Fills NaN GarageYrBlt with YrSold for those entries that truly have no garage (and hence no age contribution), making YearsSinceGarageBuilt zero for them.\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (HasMasVnr: Binary indicator if the property has any masonry veneer)\\n# Usefulness: Masonry veneer (e.g., brick, stone) often enhances the home's exterior aesthetic, durability, and perceived value, indicating higher construction or finish quality.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]\\n# Fills NaNs in MasVnrType with 'None' and MasVnrArea with 0 before evaluation.\\ndf['MasVnrType_temp'] = df['MasVnrType'].fillna('None')\\ndf['MasVnrArea_temp'] = df['MasVnrArea'].fillna(0.0)\\ndf['HasMasVnr'] = ((df['MasVnrArea_temp'] > 0) | (df['MasVnrType_temp'] != 'None')).astype(int)\\ndf.drop(['MasVnrType_temp', 'MasVnrArea_temp'], axis=1, inplace=True)\\n\\n# (ExterQual_num: Numerical representation of Exterior Quality)\\n# Usefulness: Converts the qualitative rating of exterior material quality into an ordinal numerical scale, which directly informs models about the build quality impacting price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_num'] = map_quality_condition(df['ExterQual'], qual_map_values)\\n\\n# (KitchenQual_num: Numerical representation of Kitchen Quality)\\n# Usefulness: Kitchen quality is a key selling point. This feature provides a numerical grade, making its significant impact on price accessible to regression algorithms.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_num'] = map_quality_condition(df['KitchenQual'], qual_map_values)\\n\\n# (BsmtQual_num: Numerical representation of Basement Quality)\\n# Usefulness: Ordinally scales the quality (height) of the basement, with 'NA' correctly implying no basement (score of 0), reflecting its contribution to livability and value.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_num'] = map_quality_condition(df['BsmtQual'], {**qual_map_values, 'NA': 0})\\n\\n# (HeatingQC_num: Numerical representation of Heating Quality and Condition)\\n# Usefulness: Translates the categorical heating system quality into an ordinal score, directly feeding into model evaluation of HVAC system efficiency and condition.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_num'] = map_quality_condition(df['HeatingQC'], qual_map_values)\\n\\n# (GarageQual_num: Numerical representation of Garage Quality)\\n# Usefulness: Provides a numerical grade for garage quality, where 'NA' (no garage) maps to 0, offering insight into its contribution to the overall property value.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_num'] = map_quality_condition(df['GarageQual'], {**qual_map_values, 'NA': 0})\\n\\n# (FireplaceQu_num: Numerical representation of Fireplace Quality)\\n# Usefulness: Ranks fireplace quality numerically, with 'NA' (no fireplace) indicating absence, to capture its impact as a desirable amenity influencing sale price.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', np.nan]\\ndf['FireplaceQu_num'] = map_quality_condition(df['FireplaceQu'], {**qual_map_values, 'NA': 0})\\n\\n# (TotalMajorQuality: Aggregate score of several key quality indicators)\\n# Usefulness: A composite score that sums the numerical grades of critical structural and aesthetic components (exterior, kitchen, basement, heating, garage, fireplace, and overall quality), offering a holistic measure of the property's general standing and finish quality.\\n# Input samples: 'ExterQual_num': [3, 4, 3], 'KitchenQual_num': [3, 4, 3], 'BsmtQual_num': [3, 4, 3], 'HeatingQC_num': [5, 5, 5], 'GarageQual_num': [3, 3, 3], 'FireplaceQu_num': [3, 3, 0], 'OverallQual': [5, 8, 5]\\ndf['TotalMajorQuality'] = df['ExterQual_num'] + df['KitchenQual_num'] + df['BsmtQual_num'] + \\\\\\n                          df['HeatingQC_num'] + df['GarageQual_num'] + df['FireplaceQu_num'] + df['OverallQual']\"}, {\"search_node\": {\"trial\": 14, \"parent_trial\": 12, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"score\": -0.11322638968093002}], \"predefined_state\": null, \"parent_score\": -0.11322638968093002, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"# (HasRemodeled: Binary indicator if the house underwent any remodeling.)\\n# Usefulness: Indicates significant updates or renovations, suggesting a potentially more modern or well-maintained property which often commands a higher price.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['HasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAgeAtSale: The age of the garage when the house was sold, 0 if no garage.)\\n# Usefulness: Captures the relative age of the garage structure, influencing its condition, modernity, and associated value. A non-existent garage is represented by age 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageArea': [264, 796, 281], 'YearBuilt': [1961, 1993, 1932], 'GarageType': ['Attchd', 'Attchd', 'Detchd']\\n# First, identify properties with no garage (GarageType is NaN). Their age is 0.\\nhas_garage_mask = df['GarageType'].notna()\\ndf['GarageAgeAtSale'] = pd.Series(0, index=df.index)\\n\\n# For properties that have a garage:\\n# Calculate age as YrSold - GarageYrBlt.\\n# If GarageYrBlt is NaN but a garage exists, assume garage was built the same year as the house (YearBuilt).\\ngarage_year_built_effective = df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[has_garage_mask, 'GarageAgeAtSale'] = df['YrSold'] - garage_year_built_effective.loc[has_garage_mask]\\n\\n# Ensure no negative ages result from imputations or data inconsistencies\\ndf['GarageAgeAtSale'] = df['GarageAgeAtSale'].clip(lower=0).astype(int)\\n\\n\\n# (DensityRatio: Ratio of above ground living area to the total lot area.)\\n# Usefulness: Indicates how much of the property's land is dedicated to the house footprint, providing insight into lot spaciousness relative to house size.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 793]\\ndf['DensityRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (CombinedOverallQuality: A sum of mapped ordinal quality features (Exterior, Kitchen, Basement, Heating).)\\n# Usefulness: Aggregates several key quality indicators into a single score, reflecting the overall perceived condition and finish of essential parts of the home, strongly impacting sale price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA'], 'HeatingQC': ['Ex', 'Ex', 'Ex']\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n\\n# Create temporary columns by mapping categorical qualities to numerical scores\\ndf['ExterQual_Mapped'] = df['ExterQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['KitchenQual_Mapped'] = df['KitchenQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['BsmtQual_Mapped'] = df['BsmtQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['HeatingQC_Mapped'] = df['HeatingQC'].map(quality_mapping).fillna(0).astype(int)\\n\\n# Sum the mapped scores to create the combined quality feature\\ndf['CombinedOverallQuality'] = (\\n    df['ExterQual_Mapped'] +\\n    df['KitchenQual_Mapped'] +\\n    df['BsmtQual_Mapped'] +\\n    df['HeatingQC_Mapped']\\n)\\n\\n# Remove the temporary mapped columns\\ndf.drop(['ExterQual_Mapped', 'KitchenQual_Mapped', 'BsmtQual_Mapped', 'HeatingQC_Mapped'], axis=1, inplace=True)\"]}, \"score\": -0.11449730936589271, \"memory_update\": \"# (HasRemodeled: Binary indicator if the house underwent any remodeling.)\\n# Usefulness: Indicates significant updates or renovations, suggesting a potentially more modern or well-maintained property which often commands a higher price.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['HasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAgeAtSale: The age of the garage when the house was sold, 0 if no garage.)\\n# Usefulness: Captures the relative age of the garage structure, influencing its condition, modernity, and associated value. A non-existent garage is represented by age 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageArea': [264, 796, 281], 'YearBuilt': [1961, 1993, 1932], 'GarageType': ['Attchd', 'Attchd', 'Detchd']\\n# First, identify properties with no garage (GarageType is NaN). Their age is 0.\\nhas_garage_mask = df['GarageType'].notna()\\ndf['GarageAgeAtSale'] = pd.Series(0, index=df.index)\\n\\n# For properties that have a garage:\\n# Calculate age as YrSold - GarageYrBlt.\\n# If GarageYrBlt is NaN but a garage exists, assume garage was built the same year as the house (YearBuilt).\\ngarage_year_built_effective = df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[has_garage_mask, 'GarageAgeAtSale'] = df['YrSold'] - garage_year_built_effective.loc[has_garage_mask]\\n\\n# Ensure no negative ages result from imputations or data inconsistencies\\ndf['GarageAgeAtSale'] = df['GarageAgeAtSale'].clip(lower=0).astype(int)\\n\\n\\n# (DensityRatio: Ratio of above ground living area to the total lot area.)\\n# Usefulness: Indicates how much of the property's land is dedicated to the house footprint, providing insight into lot spaciousness relative to house size.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 793]\\ndf['DensityRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (CombinedOverallQuality: A sum of mapped ordinal quality features (Exterior, Kitchen, Basement, Heating).)\\n# Usefulness: Aggregates several key quality indicators into a single score, reflecting the overall perceived condition and finish of essential parts of the home, strongly impacting sale price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA'], 'HeatingQC': ['Ex', 'Ex', 'Ex']\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n\\n# Create temporary columns by mapping categorical qualities to numerical scores\\ndf['ExterQual_Mapped'] = df['ExterQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['KitchenQual_Mapped'] = df['KitchenQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['BsmtQual_Mapped'] = df['BsmtQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['HeatingQC_Mapped'] = df['HeatingQC'].map(quality_mapping).fillna(0).astype(int)\\n\\n# Sum the mapped scores to create the combined quality feature\\ndf['CombinedOverallQuality'] = (\\n    df['ExterQual_Mapped'] +\\n    df['KitchenQual_Mapped'] +\\n    df['BsmtQual_Mapped'] +\\n    df['HeatingQC_Mapped']\\n)\\n\\n# Remove the temporary mapped columns\\ndf.drop(['ExterQual_Mapped', 'KitchenQual_Mapped', 'BsmtQual_Mapped', 'HeatingQC_Mapped'], axis=1, inplace=True)\"}, {\"search_node\": {\"trial\": 15, \"parent_trial\": 7, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\", \"score\": -0.11380374429092432}], \"predefined_state\": null, \"parent_score\": -0.11380374429092432, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\", \"import numpy as np\\nimport pandas as pd\\n\\n# Mappings for categorical features with inherent order\\nquality_map_extended = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0, 'NA': 0}\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, np.nan: 0, 'NA': 0}\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\npaved_drive_map = {'Y': 2, 'P': 1, 'N': 0}\\n\\n\\n# (Total Exterior Quality and Condition)\\n# Usefulness: Combines `ExterQual` and `ExterCond` into a single score representing the overall quality and current condition of the house's exterior materials, impacting curb appeal and long-term maintenance.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Rating'] = df['ExterQual'].map(quality_map_extended) + df['ExterCond'].map(quality_map_extended)\\n\\n# (Basement Finish Quality Score)\\n# Usefulness: Provides a combined score for the quality of the primary and secondary finished basement areas, indicating the functional value and desirability of the basement space.\\n# Input samples: {'BsmtFinType1': ['BLQ', 'GLQ', 'Rec'], 'BsmtFinType2': ['Unf', 'Unf', 'Unf']}\\ndf['TotalBsmtFinQual'] = df['BsmtFinType1'].map(bsmt_fin_type_map) + df['BsmtFinType2'].map(bsmt_fin_type_map)\\n\\n# (Remodeled (Binary))\\n# Usefulness: Indicates if the house has ever been remodeled (YearRemodAdd different from YearBuilt). Remodeling often brings a property up to modern standards, increasing appeal.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['IsRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Has Masonry Veneer (Binary))\\n# Usefulness: A binary flag indicating the presence of masonry veneer. Masonry veneers often enhance a home's aesthetic appeal and perceived quality, impacting its market value.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Total Number of Floors above Ground)\\n# Usefulness: Aggregates the number of full and half baths, providing a holistic count of bathroom facilities, a key driver of property value and functionality.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloors'] = df.apply(lambda row: 2 if row['2ndFlrSF'] > 0 else 1, axis=1)\\n\\n# (Basement Finished to Total Basement Ratio)\\n# Usefulness: Calculates the proportion of finished basement space relative to the total basement area. A higher ratio indicates more usable finished living space below grade.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / (df['TotalBsmtSF'] + 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Log-transformed LotFrontage)\\n# Usefulness: Log transformation of `LotFrontage` to normalize its distribution and capture the non-linear relationship with sale price, especially beneficial for skewed data. Missing values are filled with the median.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (Paved Driveway Quality Score)\\n# Usefulness: Converts the ordinal `PavedDrive` feature into a numerical score, reflecting the convenience and maintenance level of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Score'] = df['PavedDrive'].map(paved_drive_map)\\n\\n# (Exterior Wall Similarity - Binary)\\n# Usefulness: Indicates if the primary (`Exterior1st`) and secondary (`Exterior2nd`) exterior coverings are the same. Differences might suggest additions, repairs, or variations in design that could impact value.\\n# Input samples: {'Exterior1st': ['HdBoard', 'MetalSd', 'VinylSd'], 'Exterior2nd': ['HdBoard', 'MetalSd', 'Stucco']}\\ndf['ExteriorSame'] = (df['Exterior1st'] == df['Exterior2nd']).astype(int)\\n\\n# (Average Room Size Above Ground)\\n# Usefulness: Divides the above-ground living area by the total number of rooms above grade. This metric provides insight into the spaciousness of rooms, with larger average rooms potentially suggesting a more premium property.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSizeAbvGrd'] = df['GrLivArea'] / (df['TotRmsAbvGrd'].replace(0, 1))\\n\\n# (Neighborhood interaction with Overall Quality)\\n# Usefulness: Interacts the categorical 'Neighborhood' with the ordinal 'OverallQual'. This feature could highlight neighborhoods where high-quality homes command a greater premium, or poor-quality homes face larger discounts due to local market perception.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU'], 'OverallQual': [5, 8, 5]}\\ndf['Neighborhood_Qual_Interaction'] = df['Neighborhood'] + '_' + df['OverallQual'].astype(str) # This will create a new categorical feature, suitable for one-hot encoding or target encoding in downstream tasks.\\n\\n# (Total Area with Basement + 1st floor)\\n# Usefulness: Captures a combined footprint of the entire building, potentially reflecting the foundation and basic structure's cost and size impact.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793], '1stFlrSF': [1144, 1352, 848]}\\ndf['BsmtAnd1stFlrSF'] = df['TotalBsmtSF'] + df['1stFlrSF']\\n\\n# (Count of Bathrooms vs. Bedrooms)\\n# Usefulness: A simple ratio of bathrooms to bedrooms, useful for determining the convenience factor of a house. More bathrooms per bedroom often indicates higher luxury.\\n# Input samples: {'Total_Weighted_Bathrooms': [2.0, 3.5, 1.0], 'BedroomAbvGr': [3, 5, 3]}\\ndf['BathsPerBed'] = df['Total_Weighted_Bathrooms'] / (df['BedroomAbvGr'].replace(0, 1))\\n\\n# (Property Has Fence)\\n# Usefulness: Binary indicator if the property has a fence. Fences provide privacy and security, often a valued amenity for homeowners with children or pets.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['HasFence'] = (~df['Fence'].isna()).astype(int)\\n\\n# (Property Has Miscellaneous Feature)\\n# Usefulness: Binary indicator if the property has a miscellaneous feature. These could be unique additions that differentiate a property.\\n# Input samples: {'MiscFeature': ['Shed', np.nan, np.nan]}\\ndf['HasMiscFeature'] = (~df['MiscFeature'].isna()).astype(int)\"]}, \"score\": -0.11440101531633078, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Mappings for categorical features with inherent order\\nquality_map_extended = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0, 'NA': 0}\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, np.nan: 0, 'NA': 0}\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\npaved_drive_map = {'Y': 2, 'P': 1, 'N': 0}\\n\\n\\n# (Total Exterior Quality and Condition)\\n# Usefulness: Combines `ExterQual` and `ExterCond` into a single score representing the overall quality and current condition of the house's exterior materials, impacting curb appeal and long-term maintenance.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Rating'] = df['ExterQual'].map(quality_map_extended) + df['ExterCond'].map(quality_map_extended)\\n\\n# (Basement Finish Quality Score)\\n# Usefulness: Provides a combined score for the quality of the primary and secondary finished basement areas, indicating the functional value and desirability of the basement space.\\n# Input samples: {'BsmtFinType1': ['BLQ', 'GLQ', 'Rec'], 'BsmtFinType2': ['Unf', 'Unf', 'Unf']}\\ndf['TotalBsmtFinQual'] = df['BsmtFinType1'].map(bsmt_fin_type_map) + df['BsmtFinType2'].map(bsmt_fin_type_map)\\n\\n# (Remodeled (Binary))\\n# Usefulness: Indicates if the house has ever been remodeled (YearRemodAdd different from YearBuilt). Remodeling often brings a property up to modern standards, increasing appeal.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['IsRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Has Masonry Veneer (Binary))\\n# Usefulness: A binary flag indicating the presence of masonry veneer. Masonry veneers often enhance a home's aesthetic appeal and perceived quality, impacting its market value.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Total Number of Floors above Ground)\\n# Usefulness: Aggregates the number of full and half baths, providing a holistic count of bathroom facilities, a key driver of property value and functionality.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloors'] = df.apply(lambda row: 2 if row['2ndFlrSF'] > 0 else 1, axis=1)\\n\\n# (Basement Finished to Total Basement Ratio)\\n# Usefulness: Calculates the proportion of finished basement space relative to the total basement area. A higher ratio indicates more usable finished living space below grade.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / (df['TotalBsmtSF'] + 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Log-transformed LotFrontage)\\n# Usefulness: Log transformation of `LotFrontage` to normalize its distribution and capture the non-linear relationship with sale price, especially beneficial for skewed data. Missing values are filled with the median.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (Paved Driveway Quality Score)\\n# Usefulness: Converts the ordinal `PavedDrive` feature into a numerical score, reflecting the convenience and maintenance level of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Score'] = df['PavedDrive'].map(paved_drive_map)\\n\\n# (Exterior Wall Similarity - Binary)\\n# Usefulness: Indicates if the primary (`Exterior1st`) and secondary (`Exterior2nd`) exterior coverings are the same. Differences might suggest additions, repairs, or variations in design that could impact value.\\n# Input samples: {'Exterior1st': ['HdBoard', 'MetalSd', 'VinylSd'], 'Exterior2nd': ['HdBoard', 'MetalSd', 'Stucco']}\\ndf['ExteriorSame'] = (df['Exterior1st'] == df['Exterior2nd']).astype(int)\\n\\n# (Average Room Size Above Ground)\\n# Usefulness: Divides the above-ground living area by the total number of rooms above grade. This metric provides insight into the spaciousness of rooms, with larger average rooms potentially suggesting a more premium property.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSizeAbvGrd'] = df['GrLivArea'] / (df['TotRmsAbvGrd'].replace(0, 1))\\n\\n# (Neighborhood interaction with Overall Quality)\\n# Usefulness: Interacts the categorical 'Neighborhood' with the ordinal 'OverallQual'. This feature could highlight neighborhoods where high-quality homes command a greater premium, or poor-quality homes face larger discounts due to local market perception.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU'], 'OverallQual': [5, 8, 5]}\\ndf['Neighborhood_Qual_Interaction'] = df['Neighborhood'] + '_' + df['OverallQual'].astype(str) # This will create a new categorical feature, suitable for one-hot encoding or target encoding in downstream tasks.\\n\\n# (Total Area with Basement + 1st floor)\\n# Usefulness: Captures a combined footprint of the entire building, potentially reflecting the foundation and basic structure's cost and size impact.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793], '1stFlrSF': [1144, 1352, 848]}\\ndf['BsmtAnd1stFlrSF'] = df['TotalBsmtSF'] + df['1stFlrSF']\\n\\n# (Count of Bathrooms vs. Bedrooms)\\n# Usefulness: A simple ratio of bathrooms to bedrooms, useful for determining the convenience factor of a house. More bathrooms per bedroom often indicates higher luxury.\\n# Input samples: {'Total_Weighted_Bathrooms': [2.0, 3.5, 1.0], 'BedroomAbvGr': [3, 5, 3]}\\ndf['BathsPerBed'] = df['Total_Weighted_Bathrooms'] / (df['BedroomAbvGr'].replace(0, 1))\\n\\n# (Property Has Fence)\\n# Usefulness: Binary indicator if the property has a fence. Fences provide privacy and security, often a valued amenity for homeowners with children or pets.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['HasFence'] = (~df['Fence'].isna()).astype(int)\\n\\n# (Property Has Miscellaneous Feature)\\n# Usefulness: Binary indicator if the property has a miscellaneous feature. These could be unique additions that differentiate a property.\\n# Input samples: {'MiscFeature': ['Shed', np.nan, np.nan]}\\ndf['HasMiscFeature'] = (~df['MiscFeature'].isna()).astype(int)\"}, {\"search_node\": {\"trial\": 16, \"parent_trial\": 4, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# (TotalSF)\\n# Usefulness: Represents the combined total finished square footage of the above-grade living area and the basement, which is a major determinant of house value.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Represents the total number of bathrooms, including full and half, and distinguishing between above-grade and basement bathrooms by assigning half bathrooms a weight of 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Indicates how old the house was at the time of sale. Older houses might command different prices or require more maintenance.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Indicates the time elapsed since the last major remodel or addition. More recent remodels generally increase house value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (HasBsmt)\\n# Usefulness: A binary indicator if the property has a basement, which adds significant utility and storage space.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (HasFireplace)\\n# Usefulness: A binary indicator if the property has a fireplace, often considered a desirable amenity.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (HasGarage)\\n# Usefulness: A binary indicator if the property has a garage, which adds value for parking and storage.\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (HasPool)\\n# Usefulness: A binary indicator if the property has a pool, a high-value amenity though less common.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (TotalPorchArea)\\n# Usefulness: Combines all types of outdoor porch and deck areas, representing additional living or leisure space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Remodeled)\\n# Usefulness: A binary indicator if the house has undergone remodeling since its original construction, which often correlates with improved condition and higher value.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAge)\\n# Usefulness: The age of the garage at the time of sale. An older garage might be in poorer condition or of outdated construction. NaN values for GarageYrBlt are imputed with the House Age (if there is a garage), else 0 if no garage, and the AgeAtSale used for comparison. If GarageYrBlt is NaN and there is a garage (GarageCars>0), use YearBuilt, else use 0. If GarageCars is 0, set to 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageCars': [1, 3, 1]\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[df['GarageCars'] == 0, 'GarageAge'] = 0 # No garage means age 0\\n\\n# Define mappings for ordinal categorical features\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\nbsmt_quality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nexposure_mapping = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nbsmt_fin_type_mapping = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\ngarage_finish_mapping = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no garage, treated as 0 score\\n\\n# (ExterQual_Score)\\n# Usefulness: Converts the ordinal categorical exterior quality into a numerical scale, allowing it to be used directly in regression models. 'NA' means no information/zero quality.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_mapping).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Converts the ordinal categorical exterior condition into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_mapping).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Converts the ordinal categorical kitchen quality into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_mapping).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Converts the ordinal categorical basement height quality into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Converts the ordinal categorical basement condition into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Converts the ordinal categorical heating quality into a numerical scale.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_mapping).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Converts the ordinal categorical fireplace quality into a numerical scale, with 'NA' mapping to 0 for no fireplace.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageQual_Score)\\n# Usefulness: Converts the ordinal categorical garage quality into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Score'] = df['GarageQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageCond_Score)\\n# Usefulness: Converts the ordinal categorical garage condition into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Score'] = df['GarageCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts the ordinal categorical pool quality into a numerical scale. Given 'PoolQC' has NaN-freq [100%], if the column exists, it will correctly map NaNs to 0. If it doesn't exist, this statement should implicitly handle it if the environment is strict about non-existent columns. As it failed before, explicitly setting a default is safer for error handling.\\n# Input samples: 'PoolQC': [nan, nan, nan]\\n# Corrected handling: Since 'PoolQC' has 100% NaN frequency and caused KeyError, it will be skipped from being explicitly mapped to avoid the error. This effectively means 'PoolQC_Score' remains at a default of 0 if the column truly isn't available, or will effectively be 0 for all rows if it does exist and only contains NaNs.\\n# Assuming the intention for a 100% NaN column is for it to effectively contribute zero, this omission achieves the same outcome while resolving the error.\\nif 'PoolQC' in df.columns: # Check explicitly for column existence\\n    df['PoolQC_Score'] = df['PoolQC'].map(bsmt_quality_mapping).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0 # Default to 0 if the column is entirely absent or contains no information\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Converts the ordinal categorical basement exposure into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_mapping).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 1 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (BsmtFinType2_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 2 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Score'] = df['BsmtFinType2'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Converts the ordinal categorical garage interior finish into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_mapping).fillna(0)\\n\\n# (Neighborhood_Quality_Interaction)\\n# Usefulness: Combines the house's overall quality rating with its neighborhood, assuming some neighborhoods inherently have higher quality expectations. This captures interaction effects between two important factors.\\n# Input samples: 'OverallQual': [5, 8, 5], 'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']\\nneighborhood_quality_mapping = df.groupby('Neighborhood')['OverallQual'].transform('mean')\\ndf['Neighborhood_Quality_Interaction'] = df['OverallQual'] * neighborhood_quality_mapping\\n\\n# (LotSizeProduct)\\n# Usefulness: Combines the linear feet of street connection with the total lot area, which might indicate more prominent or accessible properties with larger plots.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0], 'LotArea': [10000, 14541, 4500]\\ndf['LotSizeProduct'] = df['LotFrontage'].fillna(0) * df['LotArea']\\n\\n# (TotalFlrSF)\\n# Usefulness: Represents the total square footage across all floors (1st, 2nd, and low quality finished), offering a comprehensive measure of usable living space above ground.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'LowQualFinSF': [0, 0, 0]\\ndf['TotalFlrSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['LowQualFinSF']\\n\\n# (ExteriorQualCond)\\n# Usefulness: Combines the quality and condition of the exterior materials, offering a holistic view of the outside's state, which impacts curb appeal and maintenance costs.\\n# Input samples: 'ExterQual_Score': [3, 4, 3], 'ExterCond_Score': [3, 4, 3]\\ndf['ExteriorQualCond'] = df['ExterQual_Score'] + df['ExterCond_Score']\\n\\n# (HasMasVnr)\\n# Usefulness: A binary indicator if the house has masonry veneer, which can be an aesthetic upgrade and contribute to a higher appraisal value.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Quality_Overall_Ratio)\\n# Usefulness: Divides the general overall quality by the overall condition, highlighting houses where quality might be higher than current condition (implying potential for restoration) or vice-versa.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Quality_Overall_Ratio'] = df['OverallQual'] / df['OverallCond']\\n\\n# (AvgRoomSF)\\n# Usefulness: Calculates the average square footage per room above grade (excluding bathrooms). This gives a sense of room spaciousness.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd']\\n# Replace infinite values (if TotRmsAbvGrd is 0) with 0 for meaningful representation in a regression context.\\ndf['AvgRoomSF'] = df['AvgRoomSF'].replace([np.inf, -np.inf], 0).fillna(0)\\n\\n# (YearBuiltCategory)\\n# Usefulness: Categorizes houses into broader age groups (e.g., 'New', 'Recent', 'Old', 'VeryOld') which might capture generational architectural styles or construction standards, and simplify a potentially non-linear relationship.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932]\\ndf['YearBuiltCategory'] = pd.cut(df['YearBuilt'], bins=[0, 1940, 1970, 1995, 2010, np.inf], labels=['Pre1940', '1940-1969', '1970-1994', '1995-2009', 'Post2010'])\\n\\n# (BedroomBathroomRatio)\\n# Usefulness: Indicates the proportion of bedrooms to bathrooms. This might be important for family homes or larger properties where an equal balance or specific ratio is preferred.\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotalBathrooms': [2.0, 3.5, 1.0]\\ndf['BedroomBathroomRatio'] = df['BedroomAbvGr'] / df['TotalBathrooms']\\ndf['BedroomBathroomRatio'] = df['BedroomBathroomRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where TotalBathrooms might be 0\\n\\n# (GarageDensity)\\n# Usefulness: Represents the car capacity per square foot of garage area, which can indicate if a garage is more compact or spacious per vehicle.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageDensity'] = df['GarageCars'] / df['GarageArea']\\ndf['GarageDensity'] = df['GarageDensity'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GarageArea might be 0\\n\\n# (PorchToGrLivRatio)\\n# Usefulness: Relates the total porch/deck area to the above-grade living area, providing insight into the relative outdoor living space compared to indoor living space.\\n# Input samples: 'TotalPorchArea': [165, 264, 56], 'GrLivArea': [1144, 2520, 1520]\\ndf['PorchToGrLivRatio'] = df['TotalPorchArea'] / df['GrLivArea']\\ndf['PorchToGrLivRatio'] = df['PorchToGrLivRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (FireplacesPerGrLivArea)\\n# Usefulness: The ratio of fireplaces to the living area. This can indicate luxury or architectural features for the given size of the house.\\n# Input samples: 'Fireplaces': [1, 1, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['FireplacesPerGrLivArea'] = df['Fireplaces'] / df['GrLivArea']\\ndf['FireplacesPerGrLivArea'] = df['FireplacesPerGrLivArea'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (IsNewBuild)\\n# Usefulness: A binary indicator for houses sold in the same year they were built, often commanding premium prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YrSold': [2009, 2006, 2009]\\ndf['IsNewBuild'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: A binary indicator for properties having a second floor. This greatly impacts the house's style, footprint, and potentially value.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalSquareFootageRank)\\n# Usefulness: Ranks houses based on their total square footage. This helps capture non-linear effects of size by categorizing it relative to other houses.\\n# Input samples: 'TotalSF': [864, 1338, 793]\\ndf['TotalSquareFootageRank'] = df['TotalSF'].rank(method='dense')\\n\\n# (BsmtFinSF1Ratio)\\n# Usefulness: The ratio of finished basement area Type 1 to the total basement area. Indicates how much of the basement is dedicated to higher quality finished living space.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1'] / df['TotalBsmtSF']\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1Ratio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\\n# (LivAreaToLotAreaRatio)\\n# Usefulness: Represents the proportion of above-grade living area to the total lot area, which can indicate building density on the plot or remaining yard space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\ndf['LivAreaToLotAreaRatio'] = df['LivAreaToLotAreaRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\", \"score\": -0.13104060995676203}], \"predefined_state\": null, \"parent_score\": -0.13104060995676203, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# (Impute_LotFrontage_NaNs)\\n# Usefulness: Replaces NaN values in 'LotFrontage' with 0. Given that LotFrontage can sometimes mean 'no street connection' or be truly missing, treating NaN as 0 ensures numerical operations proceed without errors. Alternative: median imputation might be more accurate but could interact negatively with `LotArea` features if some missing are truly 0 frontage. Using 0 for this context keeps it consistent.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0]\\ndf['LotFrontage'] = df['LotFrontage'].fillna(0)\\n\\n# (Impute_MasVnrArea_NaNs)\\n# Usefulness: Replaces NaN values in 'MasVnrArea' with 0. The description of 'MasVnrType' includes 'None', which would naturally correspond to 0 'MasVnrArea'. This aligns NaNs with the 'None' type, indicating no masonry veneer.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea'] = df['MasVnrArea'].fillna(0)\\n\\n# (TotalSF)\\n# Usefulness: Sums the total living area (above grade) and total basement area to represent the overall enclosed habitable space, a primary driver of house price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Combines all bathroom counts (full and half, above and below grade) into a single, comprehensive numerical feature. Half baths are weighted at 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Calculates the age of the house at the time of sale. Older properties might have lower value or higher renovation costs, while new properties command a premium.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Computes the number of years since the last remodel. Recent remodels often indicate better condition and higher value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (TotalOutdoorSF)\\n# Usefulness: Aggregates all outdoor areas (wood deck, open porch, enclosed porch, 3-season porch, screen porch) into a single feature, representing total external living/recreational space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (HasMasVnr)\\n# Usefulness: Binary flag indicating if the house has masonry veneer. This can signify an aesthetic upgrade.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: Binary flag for the presence of a second floor, which impacts dwelling style and total usable area distribution.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (HasAlleyAccess)\\n# Usefulness: Binary flag indicating whether the property has alley access. This could be relevant for property utility or desirability. NaN and 'NA' are treated as no access.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or str(x) == 'NA' else 1)\\n\\n# (Remodeled)\\n# Usefulness: Binary flag indicating if the house has been remodeled at some point (YearBuilt != YearRemodAdd). Remodeled homes often fetch higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n\\n# Ordinal quality mappings\\nquality_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0} # General quality (ExterQual, HeatingQC, KitchenQual)\\nbsmt_gar_fp_pool_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # Quality for Bsmt, Garage, Fireplace, Pool where 'NA' means no item\\nexposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # Basement exposure\\nbsmt_fin_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Basement finish type\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Garage finish\\n\\n\\n# (ExterQual_Score)\\n# Usefulness: Numerical representation of the exterior material quality, important for curb appeal and durability.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Numerical representation of the exterior material condition.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Numerical score for basement height/quality, mapping 'NA' (no basement) to 0.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Numerical score for basement general condition, mapping 'NA' to 0.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Numerical score for basement walkout or garden level walls, mapping 'NA' to 0.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_map).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Numerical score for rating of basement finished area type 1, mapping 'NA' to 0.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_map).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Numerical score for heating quality and condition, crucial for comfort and energy efficiency.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Numerical score for kitchen quality, a significant factor in home desirability and value.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Numerical score for fireplace quality, mapping 'NA' (no fireplace) to 0.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Numerical score for interior finish of the garage, mapping 'NA' (no garage) to 0.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log_LotArea)\\n# Usefulness: Log-transformation often normalizes skewed distributions like 'LotArea', making relationships more linear and improving model performance. Using np.log1p handles zero values gracefully.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log_GrLivArea)\\n# Usefulness: Log-transformation of the above-grade living area to address its potentially skewed distribution and improve linearity.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Log_TotalBsmtSF)\\n# Usefulness: Log-transformation of total basement square footage, handling zero values with np.log1p, useful for skewed distributions.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['Log_TotalBsmtSF'] = np.log1p(df['TotalBsmtSF'])\\n\"]}, \"score\": -0.11292848029975126, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# (Impute_LotFrontage_NaNs)\\n# Usefulness: Replaces NaN values in 'LotFrontage' with 0. Given that LotFrontage can sometimes mean 'no street connection' or be truly missing, treating NaN as 0 ensures numerical operations proceed without errors. Alternative: median imputation might be more accurate but could interact negatively with `LotArea` features if some missing are truly 0 frontage. Using 0 for this context keeps it consistent.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0]\\ndf['LotFrontage'] = df['LotFrontage'].fillna(0)\\n\\n# (Impute_MasVnrArea_NaNs)\\n# Usefulness: Replaces NaN values in 'MasVnrArea' with 0. The description of 'MasVnrType' includes 'None', which would naturally correspond to 0 'MasVnrArea'. This aligns NaNs with the 'None' type, indicating no masonry veneer.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea'] = df['MasVnrArea'].fillna(0)\\n\\n# (TotalSF)\\n# Usefulness: Sums the total living area (above grade) and total basement area to represent the overall enclosed habitable space, a primary driver of house price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Combines all bathroom counts (full and half, above and below grade) into a single, comprehensive numerical feature. Half baths are weighted at 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Calculates the age of the house at the time of sale. Older properties might have lower value or higher renovation costs, while new properties command a premium.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Computes the number of years since the last remodel. Recent remodels often indicate better condition and higher value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (TotalOutdoorSF)\\n# Usefulness: Aggregates all outdoor areas (wood deck, open porch, enclosed porch, 3-season porch, screen porch) into a single feature, representing total external living/recreational space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (HasMasVnr)\\n# Usefulness: Binary flag indicating if the house has masonry veneer. This can signify an aesthetic upgrade.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: Binary flag for the presence of a second floor, which impacts dwelling style and total usable area distribution.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (HasAlleyAccess)\\n# Usefulness: Binary flag indicating whether the property has alley access. This could be relevant for property utility or desirability. NaN and 'NA' are treated as no access.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or str(x) == 'NA' else 1)\\n\\n# (Remodeled)\\n# Usefulness: Binary flag indicating if the house has been remodeled at some point (YearBuilt != YearRemodAdd). Remodeled homes often fetch higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n\\n# Ordinal quality mappings\\nquality_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0} # General quality (ExterQual, HeatingQC, KitchenQual)\\nbsmt_gar_fp_pool_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # Quality for Bsmt, Garage, Fireplace, Pool where 'NA' means no item\\nexposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # Basement exposure\\nbsmt_fin_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Basement finish type\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Garage finish\\n\\n\\n# (ExterQual_Score)\\n# Usefulness: Numerical representation of the exterior material quality, important for curb appeal and durability.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Numerical representation of the exterior material condition.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Numerical score for basement height/quality, mapping 'NA' (no basement) to 0.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Numerical score for basement general condition, mapping 'NA' to 0.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Numerical score for basement walkout or garden level walls, mapping 'NA' to 0.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_map).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Numerical score for rating of basement finished area type 1, mapping 'NA' to 0.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_map).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Numerical score for heating quality and condition, crucial for comfort and energy efficiency.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Numerical score for kitchen quality, a significant factor in home desirability and value.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Numerical score for fireplace quality, mapping 'NA' (no fireplace) to 0.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Numerical score for interior finish of the garage, mapping 'NA' (no garage) to 0.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log_LotArea)\\n# Usefulness: Log-transformation often normalizes skewed distributions like 'LotArea', making relationships more linear and improving model performance. Using np.log1p handles zero values gracefully.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log_GrLivArea)\\n# Usefulness: Log-transformation of the above-grade living area to address its potentially skewed distribution and improve linearity.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Log_TotalBsmtSF)\\n# Usefulness: Log-transformation of total basement square footage, handling zero values with np.log1p, useful for skewed distributions.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['Log_TotalBsmtSF'] = np.log1p(df['TotalBsmtSF'])\\n\"}, {\"search_node\": {\"trial\": 17, \"parent_trial\": 6, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\", \"score\": -0.1149670157247227}], \"predefined_state\": null, \"parent_score\": -0.1149670157247227, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (re-added for robustness even if already present from previous execution)\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES (ONLY IF THEY WERE NOT IN THE LAST *KEPT* BLOCK, OTHERWISE, THEY ARE ALREADY IN `df`) ---\\n# Based on analysis of previous response and Kaggle's evaluation logic, the features explicitly defined in the *last submitted block* were kept.\\n# However, features from the very *first* accepted block (before the discard operation) that were NOT explicitly re-defined in the second block should be\\n# re-created here for robustness if new features rely on them.\\n\\n# (Total Number of Bathrooms) - Recreating from initial good block for safe usage in current features\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Total Porch and Deck Area) - Recreating from initial good block for safe usage in current features\\n# Usefulness: Sums all exterior recreational spaces, enhancing a property's appeal and functionality.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Has Garage) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a garage, a major convenience.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a basement, providing additional space.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a fireplace, often a desirable amenity.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a pool, a luxury feature.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (ExterQual_Score, KitchenQual_Score, BsmtQual_mapped, HeatingQC_Score, Functional_Score, GarageFinish_Score etc.)\\n# All _Score and _mapped features created in the LAST SUCCESSFUL block (performance -0.11497) are presumed to exist in 'df'.\\n# For this codeblock, they will be used directly.\\n\\n# --- NEW FEATURES FOR THIS BLOCK ---\\n\\n# (CentralAir_Numeric)\\n# Usefulness: Converts the binary 'CentralAir' feature into a numerical representation (0 for No, 1 for Yes). Central air is a critical comfort feature that impacts house desirability and price.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['CentralAir_Numeric'] = df['CentralAir'].map({'N': 0, 'Y': 1})\\n\\n# (Alley_Presence)\\n# Usefulness: Creates a binary indicator (1 if alley access, 0 if no alley or 'NA'). Alley access can be a convenience or a drawback, influencing property layout and privacy.\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Alley_Presence'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (LotShape_Score)\\n# Usefulness: Assigns an ordinal score to 'LotShape', where 'Reg' (regular) is the highest value. Regular-shaped lots are typically more desirable for building and landscaping.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map({'IR3': 1, 'IR2': 2, 'IR1': 3, 'Reg': 4})\\n\\n# (GarageAreaPerCar)\\n# Usefulness: Divides the total garage area by the number of car capacities to gauge the average space per car. This indicates spaciousness or tightness of the garage, affecting convenience. Handle division by zero if no cars.\\n# Input samples: {'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]}\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars'].replace(0, 1)\\n\\n# (BathroomPerBedroomRatio)\\n# Usefulness: Ratio of total bathrooms to above-ground bedrooms. A higher ratio might indicate a more luxurious or comfortable living space. Handle division by zero for bedrooms.\\n# Input samples: {'BedroomAbvGr': [3, 5, 3], 'TotalBath': [1.0, 3.5, 1.0]}\\ndf['BathroomPerBedroomRatio'] = df['TotalBath'] / df['BedroomAbvGr'].replace(0, 1)\\n\\n# (TotalFloorAreaPerLotArea)\\n# Usefulness: Ratio of combined 1st and 2nd floor square footage to the total lot area. Indicates building footprint density on the lot, reflecting how much of the lot is occupied by the main structure.\\n# Input samples: {'TotalFloorSF': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]}\\ndf['TotalFloorAreaPerLotArea'] = df['TotalFloorSF'] / df['LotArea'].replace(0, 1e-6)\\n\\n# (GrLivArea_x_OverallQual)\\n# Usefulness: An interaction feature multiplying the living area with the overall quality. This emphasizes the value of higher quality in larger homes.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]}\\ndf['GrLivArea_x_OverallQual'] = df['GrLivArea'] * df['OverallQual']\\n\\n# (MasVnrType_Presence)\\n# Usefulness: Binary indicator for whether the house has masonry veneer. This can denote a higher-quality exterior finish, influencing aesthetic appeal. 'NA' means No Masonry veneer.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan]}\\ndf['MasVnrType_Presence'] = df['MasVnrType'].apply(lambda x: 0 if pd.isna(x) or x == 'None' else 1)\\n\\n# (LotConfig_IsCorner)\\n# Usefulness: Binary feature to flag corner lots. Corner lots often offer more light, privacy, or yard space, which can increase value.\\n# Input samples: {'LotConfig': ['Corner', 'Corner', 'Inside']}\\ndf['LotConfig_IsCorner'] = (df['LotConfig'] == 'Corner').astype(int)\\n\\n# (Heating_GasA_Flag)\\n# Usefulness: Binary flag indicating if the heating type is GasA (Gas forced warm air furnace), which is the most common and often preferred type.\\n# Input samples: {'Heating': ['GasA', 'GasA', 'GasA']}\\ndf['Heating_GasA_Flag'] = (df['Heating'] == 'GasA').astype(int)\\n\\n# (Foundation_PConc_Flag)\\n# Usefulness: Binary flag for properties with a Poured Concrete foundation. Poured concrete is often associated with newer construction and better stability.\\n# Input samples: {'Foundation': ['CBlock', 'PConc', 'BrkTil']}\\ndf['Foundation_PConc_Flag'] = (df['Foundation'] == 'PConc').astype(int)\\n\\n# (OverallQualityTimesLivingArea_plus_Bsmt)\\n# Usefulness: Combines overall quality with total living area (above grade + basement). This feature directly correlates quality to the usable square footage.\\n# Input samples: {'OverallQual': [5, 8, 5], 'TotalLivAreaSF': [2008, 3858, 2313]}\\ndf['OverallQualityTimesLivingArea_plus_Bsmt'] = df['OverallQual'] * df['TotalLivAreaSF']\\n\\n# (Condition1_Norm_Flag)\\n# Usefulness: Binary flag for houses in 'Normal' proximity to various conditions. Being normal could imply less noise/traffic/hazards, making the property more desirable.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm']}\\ndf['Condition1_Norm_Flag'] = (df['Condition1'] == 'Norm').astype(int)\\n\\n# (IsResidentialZone)\\n# Usefulness: Aggregates several residential zoning classifications into a single binary feature. Identifying if a property is strictly for residential use (vs. commercial/industrial) can filter by purpose and expected market.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\nresidential_zones = ['RL', 'RM', 'RH', 'RP', 'FV']\\ndf['IsResidentialZone'] = df['MSZoning'].apply(lambda x: 1 if x in residential_zones else 0)\\n\\n# (LowQualityAreaRatio)\\n# Usefulness: Ratio of low-quality finished square feet to the total living area. This can penalize homes with significant portions of low-quality finished space.\\n# Input samples: {'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]}\\ndf['LowQualityAreaRatio'] = df['LowQualFinSF'] / (df['GrLivArea'].replace(0, 1e-6))\\n\\n# (RoomsVsBedrooms)\\n# Usefulness: Ratio of total rooms above grade to bedrooms. This can indicate room spaciousness or alternative use rooms (e.g., studies, family rooms that aren't bedrooms).\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]}\\ndf['RoomsVsBedrooms'] = df['TotRmsAbvGrd'] / df['BedroomAbvGr'].replace(0, 1)\\n\\n# (ExteriorHasVinylOrCementSiding)\\n# Usefulness: A binary flag indicating the presence of durable and low-maintenance exterior sidings (VinylSd or CemntBd), which are often associated with modern homes and lower maintenance costs.\\n# Input samples: {'Exterior1st': ['HdBoard', 'MetalSd', 'VinylSd'], 'Exterior2nd': ['HdBoard', 'MetalSd', 'Stucco']}\\ndf['ExteriorHasVinylOrCementSiding'] = ((df['Exterior1st'] == 'VinylSd') | (df['Exterior1st'] == 'CemntBd') |\\n                                        (df['Exterior2nd'] == 'VinylSd') | (df['Exterior2nd'] == 'CemntBd')).astype(int)\"]}, \"score\": -0.1147040783059701, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (re-added for robustness even if already present from previous execution)\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES (ONLY IF THEY WERE NOT IN THE LAST *KEPT* BLOCK, OTHERWISE, THEY ARE ALREADY IN `df`) ---\\n# Based on analysis of previous response and Kaggle's evaluation logic, the features explicitly defined in the *last submitted block* were kept.\\n# However, features from the very *first* accepted block (before the discard operation) that were NOT explicitly re-defined in the second block should be\\n# re-created here for robustness if new features rely on them.\\n\\n# (Total Number of Bathrooms) - Recreating from initial good block for safe usage in current features\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Total Porch and Deck Area) - Recreating from initial good block for safe usage in current features\\n# Usefulness: Sums all exterior recreational spaces, enhancing a property's appeal and functionality.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Has Garage) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a garage, a major convenience.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a basement, providing additional space.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a fireplace, often a desirable amenity.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool) - Recreating from initial good block for safe usage in current features\\n# Usefulness: A binary indicator for the presence of a pool, a luxury feature.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (ExterQual_Score, KitchenQual_Score, BsmtQual_mapped, HeatingQC_Score, Functional_Score, GarageFinish_Score etc.)\\n# All _Score and _mapped features created in the LAST SUCCESSFUL block (performance -0.11497) are presumed to exist in 'df'.\\n# For this codeblock, they will be used directly.\\n\\n# --- NEW FEATURES FOR THIS BLOCK ---\\n\\n# (CentralAir_Numeric)\\n# Usefulness: Converts the binary 'CentralAir' feature into a numerical representation (0 for No, 1 for Yes). Central air is a critical comfort feature that impacts house desirability and price.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['CentralAir_Numeric'] = df['CentralAir'].map({'N': 0, 'Y': 1})\\n\\n# (Alley_Presence)\\n# Usefulness: Creates a binary indicator (1 if alley access, 0 if no alley or 'NA'). Alley access can be a convenience or a drawback, influencing property layout and privacy.\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Alley_Presence'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (LotShape_Score)\\n# Usefulness: Assigns an ordinal score to 'LotShape', where 'Reg' (regular) is the highest value. Regular-shaped lots are typically more desirable for building and landscaping.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map({'IR3': 1, 'IR2': 2, 'IR1': 3, 'Reg': 4})\\n\\n# (GarageAreaPerCar)\\n# Usefulness: Divides the total garage area by the number of car capacities to gauge the average space per car. This indicates spaciousness or tightness of the garage, affecting convenience. Handle division by zero if no cars.\\n# Input samples: {'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]}\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars'].replace(0, 1)\\n\\n# (BathroomPerBedroomRatio)\\n# Usefulness: Ratio of total bathrooms to above-ground bedrooms. A higher ratio might indicate a more luxurious or comfortable living space. Handle division by zero for bedrooms.\\n# Input samples: {'BedroomAbvGr': [3, 5, 3], 'TotalBath': [1.0, 3.5, 1.0]}\\ndf['BathroomPerBedroomRatio'] = df['TotalBath'] / df['BedroomAbvGr'].replace(0, 1)\\n\\n# (TotalFloorAreaPerLotArea)\\n# Usefulness: Ratio of combined 1st and 2nd floor square footage to the total lot area. Indicates building footprint density on the lot, reflecting how much of the lot is occupied by the main structure.\\n# Input samples: {'TotalFloorSF': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]}\\ndf['TotalFloorAreaPerLotArea'] = df['TotalFloorSF'] / df['LotArea'].replace(0, 1e-6)\\n\\n# (GrLivArea_x_OverallQual)\\n# Usefulness: An interaction feature multiplying the living area with the overall quality. This emphasizes the value of higher quality in larger homes.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]}\\ndf['GrLivArea_x_OverallQual'] = df['GrLivArea'] * df['OverallQual']\\n\\n# (MasVnrType_Presence)\\n# Usefulness: Binary indicator for whether the house has masonry veneer. This can denote a higher-quality exterior finish, influencing aesthetic appeal. 'NA' means No Masonry veneer.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan]}\\ndf['MasVnrType_Presence'] = df['MasVnrType'].apply(lambda x: 0 if pd.isna(x) or x == 'None' else 1)\\n\\n# (LotConfig_IsCorner)\\n# Usefulness: Binary feature to flag corner lots. Corner lots often offer more light, privacy, or yard space, which can increase value.\\n# Input samples: {'LotConfig': ['Corner', 'Corner', 'Inside']}\\ndf['LotConfig_IsCorner'] = (df['LotConfig'] == 'Corner').astype(int)\\n\\n# (Heating_GasA_Flag)\\n# Usefulness: Binary flag indicating if the heating type is GasA (Gas forced warm air furnace), which is the most common and often preferred type.\\n# Input samples: {'Heating': ['GasA', 'GasA', 'GasA']}\\ndf['Heating_GasA_Flag'] = (df['Heating'] == 'GasA').astype(int)\\n\\n# (Foundation_PConc_Flag)\\n# Usefulness: Binary flag for properties with a Poured Concrete foundation. Poured concrete is often associated with newer construction and better stability.\\n# Input samples: {'Foundation': ['CBlock', 'PConc', 'BrkTil']}\\ndf['Foundation_PConc_Flag'] = (df['Foundation'] == 'PConc').astype(int)\\n\\n# (OverallQualityTimesLivingArea_plus_Bsmt)\\n# Usefulness: Combines overall quality with total living area (above grade + basement). This feature directly correlates quality to the usable square footage.\\n# Input samples: {'OverallQual': [5, 8, 5], 'TotalLivAreaSF': [2008, 3858, 2313]}\\ndf['OverallQualityTimesLivingArea_plus_Bsmt'] = df['OverallQual'] * df['TotalLivAreaSF']\\n\\n# (Condition1_Norm_Flag)\\n# Usefulness: Binary flag for houses in 'Normal' proximity to various conditions. Being normal could imply less noise/traffic/hazards, making the property more desirable.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm']}\\ndf['Condition1_Norm_Flag'] = (df['Condition1'] == 'Norm').astype(int)\\n\\n# (IsResidentialZone)\\n# Usefulness: Aggregates several residential zoning classifications into a single binary feature. Identifying if a property is strictly for residential use (vs. commercial/industrial) can filter by purpose and expected market.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\nresidential_zones = ['RL', 'RM', 'RH', 'RP', 'FV']\\ndf['IsResidentialZone'] = df['MSZoning'].apply(lambda x: 1 if x in residential_zones else 0)\\n\\n# (LowQualityAreaRatio)\\n# Usefulness: Ratio of low-quality finished square feet to the total living area. This can penalize homes with significant portions of low-quality finished space.\\n# Input samples: {'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]}\\ndf['LowQualityAreaRatio'] = df['LowQualFinSF'] / (df['GrLivArea'].replace(0, 1e-6))\\n\\n# (RoomsVsBedrooms)\\n# Usefulness: Ratio of total rooms above grade to bedrooms. This can indicate room spaciousness or alternative use rooms (e.g., studies, family rooms that aren't bedrooms).\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]}\\ndf['RoomsVsBedrooms'] = df['TotRmsAbvGrd'] / df['BedroomAbvGr'].replace(0, 1)\\n\\n# (ExteriorHasVinylOrCementSiding)\\n# Usefulness: A binary flag indicating the presence of durable and low-maintenance exterior sidings (VinylSd or CemntBd), which are often associated with modern homes and lower maintenance costs.\\n# Input samples: {'Exterior1st': ['HdBoard', 'MetalSd', 'VinylSd'], 'Exterior2nd': ['HdBoard', 'MetalSd', 'Stucco']}\\ndf['ExteriorHasVinylOrCementSiding'] = ((df['Exterior1st'] == 'VinylSd') | (df['Exterior1st'] == 'CemntBd') |\\n                                        (df['Exterior2nd'] == 'VinylSd') | (df['Exterior2nd'] == 'CemntBd')).astype(int)\"}, {\"search_node\": {\"trial\": 18, \"parent_trial\": 14, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"score\": -0.11322638968093002}, {\"update\": \"# (HasRemodeled: Binary indicator if the house underwent any remodeling.)\\n# Usefulness: Indicates significant updates or renovations, suggesting a potentially more modern or well-maintained property which often commands a higher price.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['HasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAgeAtSale: The age of the garage when the house was sold, 0 if no garage.)\\n# Usefulness: Captures the relative age of the garage structure, influencing its condition, modernity, and associated value. A non-existent garage is represented by age 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageArea': [264, 796, 281], 'YearBuilt': [1961, 1993, 1932], 'GarageType': ['Attchd', 'Attchd', 'Detchd']\\n# First, identify properties with no garage (GarageType is NaN). Their age is 0.\\nhas_garage_mask = df['GarageType'].notna()\\ndf['GarageAgeAtSale'] = pd.Series(0, index=df.index)\\n\\n# For properties that have a garage:\\n# Calculate age as YrSold - GarageYrBlt.\\n# If GarageYrBlt is NaN but a garage exists, assume garage was built the same year as the house (YearBuilt).\\ngarage_year_built_effective = df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[has_garage_mask, 'GarageAgeAtSale'] = df['YrSold'] - garage_year_built_effective.loc[has_garage_mask]\\n\\n# Ensure no negative ages result from imputations or data inconsistencies\\ndf['GarageAgeAtSale'] = df['GarageAgeAtSale'].clip(lower=0).astype(int)\\n\\n\\n# (DensityRatio: Ratio of above ground living area to the total lot area.)\\n# Usefulness: Indicates how much of the property's land is dedicated to the house footprint, providing insight into lot spaciousness relative to house size.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 793]\\ndf['DensityRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (CombinedOverallQuality: A sum of mapped ordinal quality features (Exterior, Kitchen, Basement, Heating).)\\n# Usefulness: Aggregates several key quality indicators into a single score, reflecting the overall perceived condition and finish of essential parts of the home, strongly impacting sale price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA'], 'HeatingQC': ['Ex', 'Ex', 'Ex']\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n\\n# Create temporary columns by mapping categorical qualities to numerical scores\\ndf['ExterQual_Mapped'] = df['ExterQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['KitchenQual_Mapped'] = df['KitchenQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['BsmtQual_Mapped'] = df['BsmtQual'].map(quality_mapping).fillna(0).astype(int)\\ndf['HeatingQC_Mapped'] = df['HeatingQC'].map(quality_mapping).fillna(0).astype(int)\\n\\n# Sum the mapped scores to create the combined quality feature\\ndf['CombinedOverallQuality'] = (\\n    df['ExterQual_Mapped'] +\\n    df['KitchenQual_Mapped'] +\\n    df['BsmtQual_Mapped'] +\\n    df['HeatingQC_Mapped']\\n)\\n\\n# Remove the temporary mapped columns\\ndf.drop(['ExterQual_Mapped', 'KitchenQual_Mapped', 'BsmtQual_Mapped', 'HeatingQC_Mapped'], axis=1, inplace=True)\", \"score\": -0.11449730936589271}], \"predefined_state\": null, \"parent_score\": -0.11449730936589271, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"# BasementFinRatio: Proportion of total basement area that is finished.\\n# Usefulness: A higher proportion of finished basement area typically indicates more usable living space, directly contributing to higher home value and appealing to buyers.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalBsmtFinSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\ndf['BasementFinRatio'] = df['TotalBsmtFinSF'] / df['TotalBsmtSF'].replace(0, np.nan)\\ndf['BasementFinRatio'] = df['BasementFinRatio'].fillna(0) # Houses with no basement (TotalBsmtSF=0) get a ratio of 0.0\\n\\n# FrontagePerLotArea: Ratio of linear feet of street connected to property to total lot size.\\n# Usefulness: This ratio can indicate the accessibility, shape, or subdividability of a lot. A larger frontage relative to area might imply a more desirable or visible plot, or more direct access to services, which can enhance value.\\n# Input samples: 'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]\\n# Impute LotFrontage NaNs using median specific to the Neighborhood, falling back to overall median if neighborhood has no frontage data.\\ndf['LotFrontage_filled'] = df.groupby('Neighborhood')['LotFrontage'].transform(lambda x: x.fillna(x.median()))\\ndf['LotFrontage_filled'] = df['LotFrontage_filled'].fillna(df['LotFrontage'].median())\\n\\n# Calculate ratio, handling potential division by zero for LotArea (though LotArea is usually non-zero positive).\\ndf['FrontagePerLotArea'] = df['LotFrontage_filled'] / df['LotArea'].replace(0, np.nan)\\ndf['FrontagePerLotArea'] = df['FrontagePerLotArea'].fillna(0) # For any resulting NaN (e.g., from LotArea originally being 0)\\ndf.drop('LotFrontage_filled', axis=1, inplace=True)\\n\\n# OverallQualityComposite: A combined numerical score representing the overall quality of several key components of the house.\\n# Usefulness: Provides a single, holistic measure of quality for critical areas like exterior, kitchen, basement, heating, fireplace, and garage. These components collectively have a strong influence on home desirability and perceived value.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA'], 'HeatingQC': ['Ex', 'Ex', 'Ex'], 'FireplaceQu': ['TA', 'TA', np.nan], 'GarageQual': ['TA', 'TA', 'TA']\\nquality_map_scores = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0} # Mapping ordinal qualities to numerical scores\\n\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_scores).fillna(0)\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_scores).fillna(0)\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(quality_map_scores).fillna(0)\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_scores).fillna(0)\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(quality_map_scores).fillna(0)\\ndf['GarageQual_Score'] = df['GarageQual'].map(quality_map_scores).fillna(0)\\n\\ndf['OverallQualityComposite'] = (\\n    df['ExterQual_Score'] +\\n    df['KitchenQual_Score'] +\\n    df['BsmtQual_Score'] +\\n    df['HeatingQC_Score'] +\\n    df['FireplaceQu_Score'] +\\n    df['GarageQual_Score']\\n)\\n\\n# Drop intermediate score columns and temporary 'TotalBsmtFinSF' column\\ndf.drop([\\n    'ExterQual_Score', 'KitchenQual_Score', 'BsmtQual_Score',\\n    'HeatingQC_Score', 'FireplaceQu_Score', 'GarageQual_Score', 'TotalBsmtFinSF'\\n], axis=1, inplace=True)\\n\"]}, \"score\": -0.11419079527833291, \"memory_update\": \"# BasementFinRatio: Proportion of total basement area that is finished.\\n# Usefulness: A higher proportion of finished basement area typically indicates more usable living space, directly contributing to higher home value and appealing to buyers.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalBsmtFinSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\ndf['BasementFinRatio'] = df['TotalBsmtFinSF'] / df['TotalBsmtSF'].replace(0, np.nan)\\ndf['BasementFinRatio'] = df['BasementFinRatio'].fillna(0) # Houses with no basement (TotalBsmtSF=0) get a ratio of 0.0\\n\\n# FrontagePerLotArea: Ratio of linear feet of street connected to property to total lot size.\\n# Usefulness: This ratio can indicate the accessibility, shape, or subdividability of a lot. A larger frontage relative to area might imply a more desirable or visible plot, or more direct access to services, which can enhance value.\\n# Input samples: 'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]\\n# Impute LotFrontage NaNs using median specific to the Neighborhood, falling back to overall median if neighborhood has no frontage data.\\ndf['LotFrontage_filled'] = df.groupby('Neighborhood')['LotFrontage'].transform(lambda x: x.fillna(x.median()))\\ndf['LotFrontage_filled'] = df['LotFrontage_filled'].fillna(df['LotFrontage'].median())\\n\\n# Calculate ratio, handling potential division by zero for LotArea (though LotArea is usually non-zero positive).\\ndf['FrontagePerLotArea'] = df['LotFrontage_filled'] / df['LotArea'].replace(0, np.nan)\\ndf['FrontagePerLotArea'] = df['FrontagePerLotArea'].fillna(0) # For any resulting NaN (e.g., from LotArea originally being 0)\\ndf.drop('LotFrontage_filled', axis=1, inplace=True)\\n\\n# OverallQualityComposite: A combined numerical score representing the overall quality of several key components of the house.\\n# Usefulness: Provides a single, holistic measure of quality for critical areas like exterior, kitchen, basement, heating, fireplace, and garage. These components collectively have a strong influence on home desirability and perceived value.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA'], 'HeatingQC': ['Ex', 'Ex', 'Ex'], 'FireplaceQu': ['TA', 'TA', np.nan], 'GarageQual': ['TA', 'TA', 'TA']\\nquality_map_scores = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0} # Mapping ordinal qualities to numerical scores\\n\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_scores).fillna(0)\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_scores).fillna(0)\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(quality_map_scores).fillna(0)\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_scores).fillna(0)\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(quality_map_scores).fillna(0)\\ndf['GarageQual_Score'] = df['GarageQual'].map(quality_map_scores).fillna(0)\\n\\ndf['OverallQualityComposite'] = (\\n    df['ExterQual_Score'] +\\n    df['KitchenQual_Score'] +\\n    df['BsmtQual_Score'] +\\n    df['HeatingQC_Score'] +\\n    df['FireplaceQu_Score'] +\\n    df['GarageQual_Score']\\n)\\n\\n# Drop intermediate score columns and temporary 'TotalBsmtFinSF' column\\ndf.drop([\\n    'ExterQual_Score', 'KitchenQual_Score', 'BsmtQual_Score',\\n    'HeatingQC_Score', 'FireplaceQu_Score', 'GarageQual_Score', 'TotalBsmtFinSF'\\n], axis=1, inplace=True)\\n\"}, {\"search_node\": {\"trial\": 19, \"parent_trial\": 15, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\", \"score\": -0.11380374429092432}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Mappings for categorical features with inherent order\\nquality_map_extended = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0, 'NA': 0}\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, np.nan: 0, 'NA': 0}\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\npaved_drive_map = {'Y': 2, 'P': 1, 'N': 0}\\n\\n\\n# (Total Exterior Quality and Condition)\\n# Usefulness: Combines `ExterQual` and `ExterCond` into a single score representing the overall quality and current condition of the house's exterior materials, impacting curb appeal and long-term maintenance.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Rating'] = df['ExterQual'].map(quality_map_extended) + df['ExterCond'].map(quality_map_extended)\\n\\n# (Basement Finish Quality Score)\\n# Usefulness: Provides a combined score for the quality of the primary and secondary finished basement areas, indicating the functional value and desirability of the basement space.\\n# Input samples: {'BsmtFinType1': ['BLQ', 'GLQ', 'Rec'], 'BsmtFinType2': ['Unf', 'Unf', 'Unf']}\\ndf['TotalBsmtFinQual'] = df['BsmtFinType1'].map(bsmt_fin_type_map) + df['BsmtFinType2'].map(bsmt_fin_type_map)\\n\\n# (Remodeled (Binary))\\n# Usefulness: Indicates if the house has ever been remodeled (YearRemodAdd different from YearBuilt). Remodeling often brings a property up to modern standards, increasing appeal.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['IsRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Has Masonry Veneer (Binary))\\n# Usefulness: A binary flag indicating the presence of masonry veneer. Masonry veneers often enhance a home's aesthetic appeal and perceived quality, impacting its market value.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Total Number of Floors above Ground)\\n# Usefulness: Aggregates the number of full and half baths, providing a holistic count of bathroom facilities, a key driver of property value and functionality.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloors'] = df.apply(lambda row: 2 if row['2ndFlrSF'] > 0 else 1, axis=1)\\n\\n# (Basement Finished to Total Basement Ratio)\\n# Usefulness: Calculates the proportion of finished basement space relative to the total basement area. A higher ratio indicates more usable finished living space below grade.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / (df['TotalBsmtSF'] + 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Log-transformed LotFrontage)\\n# Usefulness: Log transformation of `LotFrontage` to normalize its distribution and capture the non-linear relationship with sale price, especially beneficial for skewed data. Missing values are filled with the median.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (Paved Driveway Quality Score)\\n# Usefulness: Converts the ordinal `PavedDrive` feature into a numerical score, reflecting the convenience and maintenance level of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Score'] = df['PavedDrive'].map(paved_drive_map)\\n\\n# (Exterior Wall Similarity - Binary)\\n# Usefulness: Indicates if the primary (`Exterior1st`) and secondary (`Exterior2nd`) exterior coverings are the same. Differences might suggest additions, repairs, or variations in design that could impact value.\\n# Input samples: {'Exterior1st': ['HdBoard', 'MetalSd', 'VinylSd'], 'Exterior2nd': ['HdBoard', 'MetalSd', 'Stucco']}\\ndf['ExteriorSame'] = (df['Exterior1st'] == df['Exterior2nd']).astype(int)\\n\\n# (Average Room Size Above Ground)\\n# Usefulness: Divides the above-ground living area by the total number of rooms above grade. This metric provides insight into the spaciousness of rooms, with larger average rooms potentially suggesting a more premium property.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSizeAbvGrd'] = df['GrLivArea'] / (df['TotRmsAbvGrd'].replace(0, 1))\\n\\n# (Neighborhood interaction with Overall Quality)\\n# Usefulness: Interacts the categorical 'Neighborhood' with the ordinal 'OverallQual'. This feature could highlight neighborhoods where high-quality homes command a greater premium, or poor-quality homes face larger discounts due to local market perception.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU'], 'OverallQual': [5, 8, 5]}\\ndf['Neighborhood_Qual_Interaction'] = df['Neighborhood'] + '_' + df['OverallQual'].astype(str) # This will create a new categorical feature, suitable for one-hot encoding or target encoding in downstream tasks.\\n\\n# (Total Area with Basement + 1st floor)\\n# Usefulness: Captures a combined footprint of the entire building, potentially reflecting the foundation and basic structure's cost and size impact.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793], '1stFlrSF': [1144, 1352, 848]}\\ndf['BsmtAnd1stFlrSF'] = df['TotalBsmtSF'] + df['1stFlrSF']\\n\\n# (Count of Bathrooms vs. Bedrooms)\\n# Usefulness: A simple ratio of bathrooms to bedrooms, useful for determining the convenience factor of a house. More bathrooms per bedroom often indicates higher luxury.\\n# Input samples: {'Total_Weighted_Bathrooms': [2.0, 3.5, 1.0], 'BedroomAbvGr': [3, 5, 3]}\\ndf['BathsPerBed'] = df['Total_Weighted_Bathrooms'] / (df['BedroomAbvGr'].replace(0, 1))\\n\\n# (Property Has Fence)\\n# Usefulness: Binary indicator if the property has a fence. Fences provide privacy and security, often a valued amenity for homeowners with children or pets.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['HasFence'] = (~df['Fence'].isna()).astype(int)\\n\\n# (Property Has Miscellaneous Feature)\\n# Usefulness: Binary indicator if the property has a miscellaneous feature. These could be unique additions that differentiate a property.\\n# Input samples: {'MiscFeature': ['Shed', np.nan, np.nan]}\\ndf['HasMiscFeature'] = (~df['MiscFeature'].isna()).astype(int)\", \"score\": -0.11440101531633078}], \"predefined_state\": null, \"parent_score\": -0.11440101531633078, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define a mapping for general quality/condition ratings (e.g., Ex, Gd, TA, Fa, Po, NA)\\nquality_map_general = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# Define a mapping for BsmtExposure\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0}\\n# Define a mapping for GarageFinish\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0}\\n# Define a mapping for Functional\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\n\\n\\n# (Age of House at Sale)\\n# Usefulness: Calculates how many years have passed since the original construction, indicating the inherent age-related wear, potential for outdated styles, or historical value of the property.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge_at_Sale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Age of Last Remodel/Addition at Sale)\\n# Usefulness: Indicates how recently the property has been renovated or had major additions. A smaller value suggests a more modern or well-maintained home which typically correlates with higher value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodelAge_at_Sale'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Usable Square Footage)\\n# Usefulness: Combines above ground living area with total basement square footage to provide a holistic measure of the interior usable space. This is a primary driver for house prices.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['Total_Livable_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Weighted Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement), assigning half baths a weight of 0.5. This provides a comprehensive and practical measure of a home's bathroom amenities.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['Total_Weighted_Bathrooms'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (Overall Property Quality & Condition Index)\\n# Usefulness: An interaction feature combining the `OverallQual` (material and finish) and `OverallCond` (current condition) ratings. A higher score reflects a property that is both well-built/finished and well-maintained.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['Overall_Quality_Condition_Index'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Overall Exterior Quality and Condition Score)\\n# Usefulness: Translates the ordinal 'ExterQual' and 'ExterCond' into numerical scores and sums them. This provides a single metric for the curb appeal and external durability of the house.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['Overall_Exter_Score'] = df['ExterQual'].map(quality_map_general) + df['ExterCond'].map(quality_map_general)\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Maps the 'KitchenQual' ordinal rating to a numerical score. The kitchen's quality is a primary selling point for most homes due to its central role and potential renovation costs.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['Kitchen_Quality_Score'] = df['KitchenQual'].map(quality_map_general)\\n\\n# (Overall Basement Comprehensive Score)\\n# Usefulness: Combines 'BsmtQual', 'BsmtCond', and 'BsmtExposure' into a single numerical score. This represents the structural integrity, dryness, and desirability of the basement space.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA'], 'BsmtCond': ['TA', 'Gd', 'TA'], 'BsmtExposure': ['No', 'No', 'No']}\\ndf['Overall_Basement_Score'] = df['BsmtQual'].map(quality_map_general) + df['BsmtCond'].map(quality_map_general) + df['BsmtExposure'].map(bsmt_exposure_map)\\n\\n# (Overall Garage Comprehensive Score)\\n# Usefulness: Consolidates the quality, condition, and interior finish of the garage into one numerical score. A well-maintained and finished garage is a significant asset to a home.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['Overall_Garage_Score'] = df['GarageQual'].map(quality_map_general) + df['GarageCond'].map(quality_map_general) + df['GarageFinish'].map(garage_finish_map)\\n\\n# (Has Garage Indicator)\\n# Usefulness: A binary flag indicating whether the property includes a garage. Garages are highly sought-after amenities providing parking and storage.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['Has_Garage_Binary'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement Indicator)\\n# Usefulness: A binary flag for the presence of a basement. Basements offer crucial additional space for various uses (e.g., storage, utilities, potential for finishing).\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['Has_Basement_Binary'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace Indicator)\\n# Usefulness: A binary flag indicating if the house has one or more fireplaces. Fireplaces are often considered a luxury or desirable aesthetic feature.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['Has_Fireplace_Binary'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Log-transformed LotArea)\\n# Usefulness: Applies a log transformation (log1p to handle zeros) to LotArea. This helps normalize its often skewed distribution, making it more amenable for linear models and reflecting diminishing returns on larger lot sizes.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log-transformed GrLivArea)\\n# Usefulness: Applies a log transformation to GrLivArea. Similar to LotArea, above ground living area often benefits from log transformation to address skewness and improve model performance.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520]}\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Converts the 'HeatingQC' ordinal rating to a numerical score. High-quality heating systems provide comfort and energy efficiency, impacting buyer satisfaction and operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Heating_Quality_Score'] = df['HeatingQC'].map(quality_map_general)\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Maps 'FireplaceQu' to a numerical score. This is relevant only if a fireplace exists, indicating the quality of this specific amenity.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['Fireplace_Quality_Score'] = df['FireplaceQu'].map(quality_map_general)\\n\\n# (Alley Access Indicator)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can offer convenience (e.g., for garbage pickup, additional parking access).\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Has_Alley_Access_Binary'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or x == 'NA' else 1)\\n\\n# (Functional Rating Score)\\n# Usefulness: Converts 'Functional' (home functionality) into an ordinal numerical score. This quantifies the perceived functional condition of the home, from typical to severely damaged.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map(functional_map)\\n\\n# (Total Number of Rooms per GrLivArea)\\n# Usefulness: A density metric representing how many rooms are within the above-grade living area. This can distinguish between open-plan vs. highly partitioned layouts.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['Rooms_per_GrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Add small epsilon to prevent division by zero\\n\\n# (Overall Condition Times Area of Total Living Space)\\n# Usefulness: Interaction between overall condition and total living area. This provides a combined view where both spaciousness and good condition are weighted together, strongly influencing desirability and price.\\n# Input samples: {'OverallCond': [6, 7, 5], 'Total_Livable_SF': [2008, 3858, 2313]}\\ndf['Cond_x_TotalLivArea'] = df['OverallCond'] * df['Total_Livable_SF'] # Fixed typo here\\n\\n# (Has Central Air Conditioning - Binary)\\n# Usefulness: Converts the 'CentralAir' feature into a binary (1/0) indicator. Central air conditioning is a standard and highly valued amenity in many climates.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['HasCentralAir_Binary'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Total Exterior Porch / Deck Area)\\n# Usefulness: Sums all exterior wood deck, open porch, enclosed porch, 3-season porch, and screen porch areas. Large or multiple outdoor spaces can add significant value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['Total_Outdoor_Living_SF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Age of Garage at Sale)\\n# Usefulness: Calculates the age of the garage, if present. A newer garage may indicate better condition, more modern features, and potentially higher construction quality. If no garage, assume it's as old as the sale year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['GarageAge_at_Sale'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (Masonry Veneer - Is None or Missing)\\n# Usefulness: Creates a binary flag for whether there is no masonry veneer or the type information is missing, often indicating a simpler exterior which could influence aesthetics and cost.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['MasVnrType_None_Binary'] = ((df['MasVnrType'].isna()) | (df['MasVnrType'] == 'None')).astype(int)\\n\", \"import numpy as np\\nimport pandas as pd\\n\\n# Mappings for categorical features with inherent order\\nquality_map_extended = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0, 'NA': 0}\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, np.nan: 0, 'NA': 0}\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0, 'NA': 0}\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0} # NA from description -> nan handled by fillna(0)\\npool_qc_map = {'Ex': 4, 'Gd': 3, 'TA': 2, 'Fa': 1, np.nan: 0, 'NA': 0}\\nfireplace_qu_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0, 'NA': 0}\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1, np.nan: 0, 'NA': 0}\\nalley_map = {'Pave': 2, 'Grvl': 1, np.nan: 0, 'NA': 0}\\npaved_drive_map = {'Y': 2, 'P': 1, 'N': 0}\\nelectrical_map = {'SBrkr': 5, 'FuseA': 4, 'FuseF': 3, 'FuseP': 2, 'Mix': 1, np.nan: 0} # Added np.nan mapping as Electrical has small number of NA\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\n\\n# Helper to get a column, gracefully handle missing columns by returning Series of NaN\\n# This prevents KeyError if a column truly isn't in df, allowing map().fillna(0) to then work\\ndef get_column_or_nan_series(df_local, col_name, dtype='object'):\\n    if col_name not in df_local.columns:\\n        # print(f\\\"Warning: Column '{col_name}' not found. Defaulting to NaN Series.\\\")\\n        return pd.Series(np.nan, index=df_local.index, dtype=dtype)\\n    return df_local[col_name]\\n\\n\\n# (Total House Condition Score)\\n# Usefulness: A composite score combining various condition metrics of the house: overall condition, exterior condition, heating quality, and basement condition. This provides a detailed assessment of the property's state.\\n# Input samples: {'OverallCond': [6, 7, 5], 'ExterCond': ['TA', 'Gd', 'TA'], 'HeatingQC': ['Ex', 'Ex', 'Ex'], 'BsmtCond': ['TA', 'Gd', 'TA']}\\ndf['Total_House_Condition_Score'] = df['OverallCond'] + df['ExterCond'].map(quality_map_extended) + \\\\\\n                                      df['HeatingQC'].map(quality_map_extended) + df['BsmtCond'].map(quality_map_extended)\\n\\n# (Has Any Porch or Deck)\\n# Usefulness: A binary feature indicating if the house has any form of exterior recreational space. The presence of such amenities is generally desirable and adds to perceived value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['HasAnyOutdoorSpace'] = ((df['WoodDeckSF'] > 0) | (df['OpenPorchSF'] > 0) | (df['EnclosedPorch'] > 0) |\\n                           (df['3SsnPorch'] > 0) | (df['ScreenPorch'] > 0)).astype(int)\\n\\n# (Pool Quality Score)\\n# Usefulness: Assigns a numerical score to the pool's quality. This is particularly relevant for homes with pools, as quality can heavily influence desirability. No pool maps to 0.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\ndf['Pool_Quality_Score'] = get_column_or_nan_series(df, 'PoolQC').map(pool_qc_map)\\n\\n# (Garage Quality & Condition Interaction)\\n# Usefulness: An interaction feature that multiplies garage quality, condition, and finish score. A higher value indicates a garage that is not only spacious but also well-built and maintained, impacting its value contribution.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf'], 'GarageArea': [264, 796, 281]}\\ndf['Garage_Composite_Score'] = df['GarageQual'].map(quality_map_extended) * \\\\\\n                               df['GarageCond'].map(quality_map_extended) * \\\\\\n                               df['GarageFinish'].map(garage_finish_map)\\n\\n# (Luxury Amenities Score - Fireplace and Pool Quality)\\n# Usefulness: Combines quality ratings for fireplaces and pools, if present. These features are often considered luxury items that can significantly boost a home's appeal and price.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan], 'PoolQC': [np.nan, np.nan, np.nan]}\\ndf['LuxuryAmenitiesScore'] = df['FireplaceQu'].map(fireplace_qu_map) + \\\\\\n                             get_column_or_nan_series(df, 'PoolQC').map(pool_qc_map)\\n\\n# (Total Fin/Unfin Basement Area Interaction with Basement Quality)\\n# Usefulness: Multiplies the total basement area (finished and unfinished) by its quality score. This captures that larger, higher-quality basements are more valuable.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793], 'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['TotalBsmtSF_x_BsmtQual'] = df['TotalBsmtSF'] * df['BsmtQual'].map(quality_map_extended)\\n\\n# (Years Since Last Major Change)\\n# Usefulness: Calculates the time elapsed since either the last remodel/addition or the original construction, whichever is more recent. A lower value indicates a more updated or new property.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000], 'YrSold': [2009, 2006, 2009]}\\ndf['YearsSinceLastMajorChange'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Lot Shape Score)\\n# Usefulness: Converts `LotShape` from a categorical description to an ordinal score. Regular lots are often preferred, making this an indicator of land desirability.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map(lot_shape_map)\\n\\n# (Central Air & Heating Quality Interaction)\\n# Usefulness: An interaction between the presence of central air conditioning and the quality of the heating system. Both contribute significantly to interior comfort and energy efficiency.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y'], 'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Comfort_System_Score'] = df['CentralAir'].map({'Y': 1, 'N': 0}) * df['HeatingQC'].map(quality_map_extended)\\n\\n# (Overall Area to Lot Area Ratio)\\n# Usefulness: Measures the density of the dwelling relative to its plot size by combining total livable area (above and basement) and lot area. High ratios can imply efficiency or potentially overcrowding on smaller lots.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'LotArea': [10000, 14541, 4500]}\\ndf['LivArea_Per_LotArea'] = (df['GrLivArea'] + df['TotalBsmtSF']) / (df['LotArea'] + 1e-6) # add small epsilon for safety\\n\\n# (Electrical System Quality Score)\\n# Usefulness: Converts `Electrical` from categorical to an ordinal score. The quality of the electrical system is a key safety and functional aspect of a home.\\n# Input samples: {'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']}\\ndf['Electrical_Score'] = df['Electrical'].map(electrical_map)\\n\\n# (Log-transformed GrLivArea by Overall Quality)\\n# Usefulness: Interaction between the log-transformed above-grade living area and overall quality. This emphasizes that larger, higher-quality homes are proportionally more valuable.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]}\\ndf['Log_GrLivArea_x_OverallQual'] = np.log1p(df['GrLivArea']) * df['OverallQual']\\n\\n# (Count of Full Bathrooms, a simple count, distinct from weighted total)\\n# Usefulness: Provides a direct integer count of full bathrooms (above and below grade). Some buyers might specifically care about this metric.\\n# Input samples: {'FullBath': [1, 2, 1], 'BsmtFullBath': [1, 1, 0]}\\ndf['NumFullBaths'] = df['FullBath'] + df['BsmtFullBath']\\n\\n# (Exterior Quality combined with MasVnr Area)\\n# Usefulness: Combines the general exterior quality score with the presence and size of masonry veneer. This feature aims to capture the premium aspect of certain exterior finishes.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['ExterQual_x_MasVnrArea'] = df['ExterQual'].map(quality_map_extended) * df['MasVnrArea'].fillna(0)\\n\\n# (Has Duplex or Townhouse Building Type)\\n# Usefulness: Binary feature to identify properties that are duplexes or townhouses, as these dwelling types may have different market dynamics and appeal compared to single-family homes.\\n# Input samples: {'BldgType': ['1Fam', '1Fam', '1Fam']}\\ndf['IsMultiFamily_or_Townhouse'] = df['BldgType'].isin(['Duplx', 'TwnhsE', 'TwnhsI', '2FmCon']).astype(int)\\n\\n# (Has a Specific High-Value Neighborhood)\\n# Usefulness: Binary flag for being in a commonly perceived 'high-value' neighborhood based on real estate knowledge. Specific desirable neighborhoods can fetch higher prices. For example: Northridge, Northridge Heights, Stone Brook, Somerst.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['InHighValueNeighborhood'] = df['Neighborhood'].isin(['NoRidge', 'NridgHt', 'StoneBr', 'Somerst']).astype(int)\\n\\n# (Average Basement Finished SF per Basement Finish Type 1 Score)\\n# Usefulness: An interaction that may capture how effectively good quality finished basement areas contribute to total basement space, possibly indicating well-utilized and valuable basement finishing.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']}\\ndf['BsmtFinSF1_x_BsmtFinType1Qual'] = df['BsmtFinSF1'] * df['BsmtFinType1'].map(bsmt_fin_type_map)\\n\\n# (Overall Condition multiplied by the Total Number of Rooms Above Grade)\\n# Usefulness: Represents an interaction between the house's general condition and the number of rooms, where more rooms in a better condition house implies higher overall quality and spaciousness.\\n# Input samples: {'OverallCond': [6, 7, 5], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['Cond_x_TotRmsAbvGrd'] = df['OverallCond'] * df['TotRmsAbvGrd']\\n\\n# (Has Second Floor)\\n# Usefulness: A binary indicator to denote if the house has a second floor. This distinguishes multi-story homes from single-story ones, affecting both area distribution and structural type.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Garage Quality normalized by Area)\\n# Usefulness: Provides an indication of how much the garage quality (composite score) contributes per square foot. This allows differentiation between small, high-quality garages and large, lower-quality ones.\\n# Input samples: {'Garage_Composite_Score': [8, 12, 3], 'GarageArea': [264, 796, 281]}\\ndf['GarageQual_Per_SqFt'] = df['Garage_Composite_Score'] / (df['GarageArea'] + 1e-6)\\n\\n# (Total Area (above + basement + garage))\\n# Usefulness: A comprehensive metric representing the total covered functional space of the property, combining living area, basement space, and garage area. This is a robust indicator of the property's size and utility.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]}\\ndf['TotalBuiltAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# (Age of Remodel Relative to Construction)\\n# Usefulness: Calculates how many years after initial construction a remodel/addition took place. A higher value suggests a significantly later update, potentially indicating different renovation philosophies or greater updates needed. If no remodel, it's 0.\\n# Input samples: {'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]}\\ndf['RemodelDelay'] = df['YearRemodAdd'] - df['YearBuilt']\\ndf.loc[df['RemodelDelay'] < 0, 'RemodelDelay'] = 0 # Ensure no negative values if YearRemodAdd is before YearBuilt accidentally/for new build where no remodel\\n\\n# (Density of Finished Basement Area)\\n# Usefulness: Ratio of total finished basement area to total basement area. A higher value indicates a more utilized and integrated basement space for living, adding more value than unfinished space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['FinishedBsmtRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / (df['TotalBsmtSF'] + 1e-6) # add small epsilon for safety\\n\\n# (Zoning Quality)\\n# Usefulness: Ordinal encoding of `MSZoning` to reflect common market value perceptions. Residential Low Density ('RL', 'FV') is generally preferred.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\nms_zoning_map = {'A': 1, 'C': 1, 'RM': 2, 'RH': 2, 'RL': 3, 'FV': 4, 'RP': 3} # RP is 'Residential Low Density Park', assigning same as RL. Assume higher is better.\\ndf['MSZoning_Score'] = df['MSZoning'].map(ms_zoning_map).fillna(0) # Fill NaN in case of unseen categories\"]}, \"score\": -0.11226719711938424, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Mappings for categorical features with inherent order\\nquality_map_extended = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0, 'NA': 0}\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, np.nan: 0, 'NA': 0}\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, np.nan: 0, 'NA': 0}\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, np.nan: 0} # NA from description -> nan handled by fillna(0)\\npool_qc_map = {'Ex': 4, 'Gd': 3, 'TA': 2, 'Fa': 1, np.nan: 0, 'NA': 0}\\nfireplace_qu_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0, 'NA': 0}\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1, np.nan: 0, 'NA': 0}\\nalley_map = {'Pave': 2, 'Grvl': 1, np.nan: 0, 'NA': 0}\\npaved_drive_map = {'Y': 2, 'P': 1, 'N': 0}\\nelectrical_map = {'SBrkr': 5, 'FuseA': 4, 'FuseF': 3, 'FuseP': 2, 'Mix': 1, np.nan: 0} # Added np.nan mapping as Electrical has small number of NA\\nfunctional_map = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\n\\n# Helper to get a column, gracefully handle missing columns by returning Series of NaN\\n# This prevents KeyError if a column truly isn't in df, allowing map().fillna(0) to then work\\ndef get_column_or_nan_series(df_local, col_name, dtype='object'):\\n    if col_name not in df_local.columns:\\n        # print(f\\\"Warning: Column '{col_name}' not found. Defaulting to NaN Series.\\\")\\n        return pd.Series(np.nan, index=df_local.index, dtype=dtype)\\n    return df_local[col_name]\\n\\n\\n# (Total House Condition Score)\\n# Usefulness: A composite score combining various condition metrics of the house: overall condition, exterior condition, heating quality, and basement condition. This provides a detailed assessment of the property's state.\\n# Input samples: {'OverallCond': [6, 7, 5], 'ExterCond': ['TA', 'Gd', 'TA'], 'HeatingQC': ['Ex', 'Ex', 'Ex'], 'BsmtCond': ['TA', 'Gd', 'TA']}\\ndf['Total_House_Condition_Score'] = df['OverallCond'] + df['ExterCond'].map(quality_map_extended) + \\\\\\n                                      df['HeatingQC'].map(quality_map_extended) + df['BsmtCond'].map(quality_map_extended)\\n\\n# (Has Any Porch or Deck)\\n# Usefulness: A binary feature indicating if the house has any form of exterior recreational space. The presence of such amenities is generally desirable and adds to perceived value.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['HasAnyOutdoorSpace'] = ((df['WoodDeckSF'] > 0) | (df['OpenPorchSF'] > 0) | (df['EnclosedPorch'] > 0) |\\n                           (df['3SsnPorch'] > 0) | (df['ScreenPorch'] > 0)).astype(int)\\n\\n# (Pool Quality Score)\\n# Usefulness: Assigns a numerical score to the pool's quality. This is particularly relevant for homes with pools, as quality can heavily influence desirability. No pool maps to 0.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\ndf['Pool_Quality_Score'] = get_column_or_nan_series(df, 'PoolQC').map(pool_qc_map)\\n\\n# (Garage Quality & Condition Interaction)\\n# Usefulness: An interaction feature that multiplies garage quality, condition, and finish score. A higher value indicates a garage that is not only spacious but also well-built and maintained, impacting its value contribution.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA'], 'GarageFinish': ['RFn', 'RFn', 'Unf'], 'GarageArea': [264, 796, 281]}\\ndf['Garage_Composite_Score'] = df['GarageQual'].map(quality_map_extended) * \\\\\\n                               df['GarageCond'].map(quality_map_extended) * \\\\\\n                               df['GarageFinish'].map(garage_finish_map)\\n\\n# (Luxury Amenities Score - Fireplace and Pool Quality)\\n# Usefulness: Combines quality ratings for fireplaces and pools, if present. These features are often considered luxury items that can significantly boost a home's appeal and price.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan], 'PoolQC': [np.nan, np.nan, np.nan]}\\ndf['LuxuryAmenitiesScore'] = df['FireplaceQu'].map(fireplace_qu_map) + \\\\\\n                             get_column_or_nan_series(df, 'PoolQC').map(pool_qc_map)\\n\\n# (Total Fin/Unfin Basement Area Interaction with Basement Quality)\\n# Usefulness: Multiplies the total basement area (finished and unfinished) by its quality score. This captures that larger, higher-quality basements are more valuable.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793], 'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['TotalBsmtSF_x_BsmtQual'] = df['TotalBsmtSF'] * df['BsmtQual'].map(quality_map_extended)\\n\\n# (Years Since Last Major Change)\\n# Usefulness: Calculates the time elapsed since either the last remodel/addition or the original construction, whichever is more recent. A lower value indicates a more updated or new property.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000], 'YrSold': [2009, 2006, 2009]}\\ndf['YearsSinceLastMajorChange'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Lot Shape Score)\\n# Usefulness: Converts `LotShape` from a categorical description to an ordinal score. Regular lots are often preferred, making this an indicator of land desirability.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map(lot_shape_map)\\n\\n# (Central Air & Heating Quality Interaction)\\n# Usefulness: An interaction between the presence of central air conditioning and the quality of the heating system. Both contribute significantly to interior comfort and energy efficiency.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y'], 'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['Comfort_System_Score'] = df['CentralAir'].map({'Y': 1, 'N': 0}) * df['HeatingQC'].map(quality_map_extended)\\n\\n# (Overall Area to Lot Area Ratio)\\n# Usefulness: Measures the density of the dwelling relative to its plot size by combining total livable area (above and basement) and lot area. High ratios can imply efficiency or potentially overcrowding on smaller lots.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'LotArea': [10000, 14541, 4500]}\\ndf['LivArea_Per_LotArea'] = (df['GrLivArea'] + df['TotalBsmtSF']) / (df['LotArea'] + 1e-6) # add small epsilon for safety\\n\\n# (Electrical System Quality Score)\\n# Usefulness: Converts `Electrical` from categorical to an ordinal score. The quality of the electrical system is a key safety and functional aspect of a home.\\n# Input samples: {'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']}\\ndf['Electrical_Score'] = df['Electrical'].map(electrical_map)\\n\\n# (Log-transformed GrLivArea by Overall Quality)\\n# Usefulness: Interaction between the log-transformed above-grade living area and overall quality. This emphasizes that larger, higher-quality homes are proportionally more valuable.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]}\\ndf['Log_GrLivArea_x_OverallQual'] = np.log1p(df['GrLivArea']) * df['OverallQual']\\n\\n# (Count of Full Bathrooms, a simple count, distinct from weighted total)\\n# Usefulness: Provides a direct integer count of full bathrooms (above and below grade). Some buyers might specifically care about this metric.\\n# Input samples: {'FullBath': [1, 2, 1], 'BsmtFullBath': [1, 1, 0]}\\ndf['NumFullBaths'] = df['FullBath'] + df['BsmtFullBath']\\n\\n# (Exterior Quality combined with MasVnr Area)\\n# Usefulness: Combines the general exterior quality score with the presence and size of masonry veneer. This feature aims to capture the premium aspect of certain exterior finishes.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'MasVnrArea': [0.0, 0.0, 0.0]}\\ndf['ExterQual_x_MasVnrArea'] = df['ExterQual'].map(quality_map_extended) * df['MasVnrArea'].fillna(0)\\n\\n# (Has Duplex or Townhouse Building Type)\\n# Usefulness: Binary feature to identify properties that are duplexes or townhouses, as these dwelling types may have different market dynamics and appeal compared to single-family homes.\\n# Input samples: {'BldgType': ['1Fam', '1Fam', '1Fam']}\\ndf['IsMultiFamily_or_Townhouse'] = df['BldgType'].isin(['Duplx', 'TwnhsE', 'TwnhsI', '2FmCon']).astype(int)\\n\\n# (Has a Specific High-Value Neighborhood)\\n# Usefulness: Binary flag for being in a commonly perceived 'high-value' neighborhood based on real estate knowledge. Specific desirable neighborhoods can fetch higher prices. For example: Northridge, Northridge Heights, Stone Brook, Somerst.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['InHighValueNeighborhood'] = df['Neighborhood'].isin(['NoRidge', 'NridgHt', 'StoneBr', 'Somerst']).astype(int)\\n\\n# (Average Basement Finished SF per Basement Finish Type 1 Score)\\n# Usefulness: An interaction that may capture how effectively good quality finished basement areas contribute to total basement space, possibly indicating well-utilized and valuable basement finishing.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']}\\ndf['BsmtFinSF1_x_BsmtFinType1Qual'] = df['BsmtFinSF1'] * df['BsmtFinType1'].map(bsmt_fin_type_map)\\n\\n# (Overall Condition multiplied by the Total Number of Rooms Above Grade)\\n# Usefulness: Represents an interaction between the house's general condition and the number of rooms, where more rooms in a better condition house implies higher overall quality and spaciousness.\\n# Input samples: {'OverallCond': [6, 7, 5], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['Cond_x_TotRmsAbvGrd'] = df['OverallCond'] * df['TotRmsAbvGrd']\\n\\n# (Has Second Floor)\\n# Usefulness: A binary indicator to denote if the house has a second floor. This distinguishes multi-story homes from single-story ones, affecting both area distribution and structural type.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Garage Quality normalized by Area)\\n# Usefulness: Provides an indication of how much the garage quality (composite score) contributes per square foot. This allows differentiation between small, high-quality garages and large, lower-quality ones.\\n# Input samples: {'Garage_Composite_Score': [8, 12, 3], 'GarageArea': [264, 796, 281]}\\ndf['GarageQual_Per_SqFt'] = df['Garage_Composite_Score'] / (df['GarageArea'] + 1e-6)\\n\\n# (Total Area (above + basement + garage))\\n# Usefulness: A comprehensive metric representing the total covered functional space of the property, combining living area, basement space, and garage area. This is a robust indicator of the property's size and utility.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]}\\ndf['TotalBuiltAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# (Age of Remodel Relative to Construction)\\n# Usefulness: Calculates how many years after initial construction a remodel/addition took place. A higher value suggests a significantly later update, potentially indicating different renovation philosophies or greater updates needed. If no remodel, it's 0.\\n# Input samples: {'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]}\\ndf['RemodelDelay'] = df['YearRemodAdd'] - df['YearBuilt']\\ndf.loc[df['RemodelDelay'] < 0, 'RemodelDelay'] = 0 # Ensure no negative values if YearRemodAdd is before YearBuilt accidentally/for new build where no remodel\\n\\n# (Density of Finished Basement Area)\\n# Usefulness: Ratio of total finished basement area to total basement area. A higher value indicates a more utilized and integrated basement space for living, adding more value than unfinished space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['FinishedBsmtRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / (df['TotalBsmtSF'] + 1e-6) # add small epsilon for safety\\n\\n# (Zoning Quality)\\n# Usefulness: Ordinal encoding of `MSZoning` to reflect common market value perceptions. Residential Low Density ('RL', 'FV') is generally preferred.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\nms_zoning_map = {'A': 1, 'C': 1, 'RM': 2, 'RH': 2, 'RL': 3, 'FV': 4, 'RP': 3} # RP is 'Residential Low Density Park', assigning same as RL. Assume higher is better.\\ndf['MSZoning_Score'] = df['MSZoning'].map(ms_zoning_map).fillna(0) # Fill NaN in case of unseen categories\"}, {\"search_node\": {\"trial\": 20, \"parent_trial\": 4, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# (TotalSF)\\n# Usefulness: Represents the combined total finished square footage of the above-grade living area and the basement, which is a major determinant of house value.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Represents the total number of bathrooms, including full and half, and distinguishing between above-grade and basement bathrooms by assigning half bathrooms a weight of 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Indicates how old the house was at the time of sale. Older houses might command different prices or require more maintenance.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Indicates the time elapsed since the last major remodel or addition. More recent remodels generally increase house value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (HasBsmt)\\n# Usefulness: A binary indicator if the property has a basement, which adds significant utility and storage space.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (HasFireplace)\\n# Usefulness: A binary indicator if the property has a fireplace, often considered a desirable amenity.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (HasGarage)\\n# Usefulness: A binary indicator if the property has a garage, which adds value for parking and storage.\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (HasPool)\\n# Usefulness: A binary indicator if the property has a pool, a high-value amenity though less common.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (TotalPorchArea)\\n# Usefulness: Combines all types of outdoor porch and deck areas, representing additional living or leisure space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Remodeled)\\n# Usefulness: A binary indicator if the house has undergone remodeling since its original construction, which often correlates with improved condition and higher value.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAge)\\n# Usefulness: The age of the garage at the time of sale. An older garage might be in poorer condition or of outdated construction. NaN values for GarageYrBlt are imputed with the House Age (if there is a garage), else 0 if no garage, and the AgeAtSale used for comparison. If GarageYrBlt is NaN and there is a garage (GarageCars>0), use YearBuilt, else use 0. If GarageCars is 0, set to 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageCars': [1, 3, 1]\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[df['GarageCars'] == 0, 'GarageAge'] = 0 # No garage means age 0\\n\\n# Define mappings for ordinal categorical features\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\nbsmt_quality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nexposure_mapping = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nbsmt_fin_type_mapping = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\ngarage_finish_mapping = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no garage, treated as 0 score\\n\\n# (ExterQual_Score)\\n# Usefulness: Converts the ordinal categorical exterior quality into a numerical scale, allowing it to be used directly in regression models. 'NA' means no information/zero quality.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_mapping).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Converts the ordinal categorical exterior condition into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_mapping).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Converts the ordinal categorical kitchen quality into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_mapping).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Converts the ordinal categorical basement height quality into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Converts the ordinal categorical basement condition into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Converts the ordinal categorical heating quality into a numerical scale.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_mapping).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Converts the ordinal categorical fireplace quality into a numerical scale, with 'NA' mapping to 0 for no fireplace.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageQual_Score)\\n# Usefulness: Converts the ordinal categorical garage quality into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Score'] = df['GarageQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageCond_Score)\\n# Usefulness: Converts the ordinal categorical garage condition into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Score'] = df['GarageCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts the ordinal categorical pool quality into a numerical scale. Given 'PoolQC' has NaN-freq [100%], if the column exists, it will correctly map NaNs to 0. If it doesn't exist, this statement should implicitly handle it if the environment is strict about non-existent columns. As it failed before, explicitly setting a default is safer for error handling.\\n# Input samples: 'PoolQC': [nan, nan, nan]\\n# Corrected handling: Since 'PoolQC' has 100% NaN frequency and caused KeyError, it will be skipped from being explicitly mapped to avoid the error. This effectively means 'PoolQC_Score' remains at a default of 0 if the column truly isn't available, or will effectively be 0 for all rows if it does exist and only contains NaNs.\\n# Assuming the intention for a 100% NaN column is for it to effectively contribute zero, this omission achieves the same outcome while resolving the error.\\nif 'PoolQC' in df.columns: # Check explicitly for column existence\\n    df['PoolQC_Score'] = df['PoolQC'].map(bsmt_quality_mapping).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0 # Default to 0 if the column is entirely absent or contains no information\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Converts the ordinal categorical basement exposure into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_mapping).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 1 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (BsmtFinType2_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 2 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Score'] = df['BsmtFinType2'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Converts the ordinal categorical garage interior finish into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_mapping).fillna(0)\\n\\n# (Neighborhood_Quality_Interaction)\\n# Usefulness: Combines the house's overall quality rating with its neighborhood, assuming some neighborhoods inherently have higher quality expectations. This captures interaction effects between two important factors.\\n# Input samples: 'OverallQual': [5, 8, 5], 'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']\\nneighborhood_quality_mapping = df.groupby('Neighborhood')['OverallQual'].transform('mean')\\ndf['Neighborhood_Quality_Interaction'] = df['OverallQual'] * neighborhood_quality_mapping\\n\\n# (LotSizeProduct)\\n# Usefulness: Combines the linear feet of street connection with the total lot area, which might indicate more prominent or accessible properties with larger plots.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0], 'LotArea': [10000, 14541, 4500]\\ndf['LotSizeProduct'] = df['LotFrontage'].fillna(0) * df['LotArea']\\n\\n# (TotalFlrSF)\\n# Usefulness: Represents the total square footage across all floors (1st, 2nd, and low quality finished), offering a comprehensive measure of usable living space above ground.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'LowQualFinSF': [0, 0, 0]\\ndf['TotalFlrSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['LowQualFinSF']\\n\\n# (ExteriorQualCond)\\n# Usefulness: Combines the quality and condition of the exterior materials, offering a holistic view of the outside's state, which impacts curb appeal and maintenance costs.\\n# Input samples: 'ExterQual_Score': [3, 4, 3], 'ExterCond_Score': [3, 4, 3]\\ndf['ExteriorQualCond'] = df['ExterQual_Score'] + df['ExterCond_Score']\\n\\n# (HasMasVnr)\\n# Usefulness: A binary indicator if the house has masonry veneer, which can be an aesthetic upgrade and contribute to a higher appraisal value.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Quality_Overall_Ratio)\\n# Usefulness: Divides the general overall quality by the overall condition, highlighting houses where quality might be higher than current condition (implying potential for restoration) or vice-versa.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Quality_Overall_Ratio'] = df['OverallQual'] / df['OverallCond']\\n\\n# (AvgRoomSF)\\n# Usefulness: Calculates the average square footage per room above grade (excluding bathrooms). This gives a sense of room spaciousness.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd']\\n# Replace infinite values (if TotRmsAbvGrd is 0) with 0 for meaningful representation in a regression context.\\ndf['AvgRoomSF'] = df['AvgRoomSF'].replace([np.inf, -np.inf], 0).fillna(0)\\n\\n# (YearBuiltCategory)\\n# Usefulness: Categorizes houses into broader age groups (e.g., 'New', 'Recent', 'Old', 'VeryOld') which might capture generational architectural styles or construction standards, and simplify a potentially non-linear relationship.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932]\\ndf['YearBuiltCategory'] = pd.cut(df['YearBuilt'], bins=[0, 1940, 1970, 1995, 2010, np.inf], labels=['Pre1940', '1940-1969', '1970-1994', '1995-2009', 'Post2010'])\\n\\n# (BedroomBathroomRatio)\\n# Usefulness: Indicates the proportion of bedrooms to bathrooms. This might be important for family homes or larger properties where an equal balance or specific ratio is preferred.\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotalBathrooms': [2.0, 3.5, 1.0]\\ndf['BedroomBathroomRatio'] = df['BedroomAbvGr'] / df['TotalBathrooms']\\ndf['BedroomBathroomRatio'] = df['BedroomBathroomRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where TotalBathrooms might be 0\\n\\n# (GarageDensity)\\n# Usefulness: Represents the car capacity per square foot of garage area, which can indicate if a garage is more compact or spacious per vehicle.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageDensity'] = df['GarageCars'] / df['GarageArea']\\ndf['GarageDensity'] = df['GarageDensity'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GarageArea might be 0\\n\\n# (PorchToGrLivRatio)\\n# Usefulness: Relates the total porch/deck area to the above-grade living area, providing insight into the relative outdoor living space compared to indoor living space.\\n# Input samples: 'TotalPorchArea': [165, 264, 56], 'GrLivArea': [1144, 2520, 1520]\\ndf['PorchToGrLivRatio'] = df['TotalPorchArea'] / df['GrLivArea']\\ndf['PorchToGrLivRatio'] = df['PorchToGrLivRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (FireplacesPerGrLivArea)\\n# Usefulness: The ratio of fireplaces to the living area. This can indicate luxury or architectural features for the given size of the house.\\n# Input samples: 'Fireplaces': [1, 1, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['FireplacesPerGrLivArea'] = df['Fireplaces'] / df['GrLivArea']\\ndf['FireplacesPerGrLivArea'] = df['FireplacesPerGrLivArea'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (IsNewBuild)\\n# Usefulness: A binary indicator for houses sold in the same year they were built, often commanding premium prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YrSold': [2009, 2006, 2009]\\ndf['IsNewBuild'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: A binary indicator for properties having a second floor. This greatly impacts the house's style, footprint, and potentially value.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalSquareFootageRank)\\n# Usefulness: Ranks houses based on their total square footage. This helps capture non-linear effects of size by categorizing it relative to other houses.\\n# Input samples: 'TotalSF': [864, 1338, 793]\\ndf['TotalSquareFootageRank'] = df['TotalSF'].rank(method='dense')\\n\\n# (BsmtFinSF1Ratio)\\n# Usefulness: The ratio of finished basement area Type 1 to the total basement area. Indicates how much of the basement is dedicated to higher quality finished living space.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1'] / df['TotalBsmtSF']\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1Ratio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\\n# (LivAreaToLotAreaRatio)\\n# Usefulness: Represents the proportion of above-grade living area to the total lot area, which can indicate building density on the plot or remaining yard space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\ndf['LivAreaToLotAreaRatio'] = df['LivAreaToLotAreaRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\", \"score\": -0.13104060995676203}], \"predefined_state\": null, \"parent_score\": -0.13104060995676203, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Functional_Score)\\n# Usefulness: Converts the ordinal 'Functional' property into a numerical score, where higher scores indicate better functionality, capturing an important aspect of the house's livability.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\nfunctional_mapping = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\ndf['Functional_Score'] = df['Functional'].map(functional_mapping).fillna(0)\\n\\n# (PavedDrive_Score)\\n# Usefulness: Converts the 'PavedDrive' ordinal categorical into a numerical scale, reflecting the quality and convenience of the driveway.\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y']\\npaved_drive_mapping = {'Y': 3, 'P': 2, 'N': 1}\\ndf['PavedDrive_Score'] = df['PavedDrive'].map(paved_drive_mapping).fillna(0)\\n\\n# (OverallScore)\\n# Usefulness: Combines the overall material/finish quality and overall condition into a single aggregated score, providing a general measure of the house's inherent value and maintenance level.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallScore'] = df['OverallQual'] + df['OverallCond']\\n\\n# (HasAlleyAccess)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can be a unique feature, impacting property usage or desirability. NaN implies no alley access.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = df['Alley'].apply(lambda x: 1 if pd.notna(x) else 0)\\n\\n# (NewConstruction)\\n# Usefulness: A binary flag indicating if the sale type corresponds to a newly constructed home, which typically correlates with higher sale prices.\\n# Input samples: 'SaleType': ['WD', 'WD', 'WD']\\ndf['NewConstruction'] = (df['SaleType'] == 'New').astype(int)\\n\\n# (CentralAir_Encoded)\\n# Usefulness: Converts the binary 'CentralAir' feature into a numerical representation (1 for Yes, 0 for No), making it directly usable by numerical models. Central air is a significant comfort feature.\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y']\\ndf['CentralAir_Encoded'] = df['CentralAir'].map({'Y': 1, 'N': 0}).fillna(0)\\n\\n# (Bedroom_Plus_FullBath)\\n# Usefulness: Represents a simple count of key primary living spaces - bedrooms and full bathrooms. This can be a strong indicator of a house's capacity for residents.\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'FullBath': [1, 2, 1]\\ndf['Bedroom_Plus_FullBath'] = df['BedroomAbvGr'] + df['FullBath']\"]}, \"score\": -0.11357228976790075, \"memory_update\": \"# (Functional_Score)\\n# Usefulness: Converts the ordinal 'Functional' property into a numerical score, where higher scores indicate better functionality, capturing an important aspect of the house's livability.\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ']\\nfunctional_mapping = {'Typ': 8, 'Min1': 7, 'Min2': 6, 'Mod': 5, 'Maj1': 4, 'Maj2': 3, 'Sev': 2, 'Sal': 1}\\ndf['Functional_Score'] = df['Functional'].map(functional_mapping).fillna(0)\\n\\n# (PavedDrive_Score)\\n# Usefulness: Converts the 'PavedDrive' ordinal categorical into a numerical scale, reflecting the quality and convenience of the driveway.\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y']\\npaved_drive_mapping = {'Y': 3, 'P': 2, 'N': 1}\\ndf['PavedDrive_Score'] = df['PavedDrive'].map(paved_drive_mapping).fillna(0)\\n\\n# (OverallScore)\\n# Usefulness: Combines the overall material/finish quality and overall condition into a single aggregated score, providing a general measure of the house's inherent value and maintenance level.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallScore'] = df['OverallQual'] + df['OverallCond']\\n\\n# (HasAlleyAccess)\\n# Usefulness: A binary indicator for whether the property has alley access. Alley access can be a unique feature, impacting property usage or desirability. NaN implies no alley access.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = df['Alley'].apply(lambda x: 1 if pd.notna(x) else 0)\\n\\n# (NewConstruction)\\n# Usefulness: A binary flag indicating if the sale type corresponds to a newly constructed home, which typically correlates with higher sale prices.\\n# Input samples: 'SaleType': ['WD', 'WD', 'WD']\\ndf['NewConstruction'] = (df['SaleType'] == 'New').astype(int)\\n\\n# (CentralAir_Encoded)\\n# Usefulness: Converts the binary 'CentralAir' feature into a numerical representation (1 for Yes, 0 for No), making it directly usable by numerical models. Central air is a significant comfort feature.\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y']\\ndf['CentralAir_Encoded'] = df['CentralAir'].map({'Y': 1, 'N': 0}).fillna(0)\\n\\n# (Bedroom_Plus_FullBath)\\n# Usefulness: Represents a simple count of key primary living spaces - bedrooms and full bathrooms. This can be a strong indicator of a house's capacity for residents.\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'FullBath': [1, 2, 1]\\ndf['Bedroom_Plus_FullBath'] = df['BedroomAbvGr'] + df['FullBath']\"}, {\"search_node\": {\"trial\": 21, \"parent_trial\": 10, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house, which is a primary driver of sale price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Aggregates all full and half bathrooms (both above grade and in basement) into a single, intuitive metric representing bathroom utility, heavily influencing desirability and price. Half baths are weighted at 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value. Older houses might command lower prices unless historically significant, while newer ones are often more valuable.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition. More recent remodels generally indicate better condition and modern amenities, leading to higher sale prices.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Total Porch and Deck Area)\\n# Usefulness: Sums all exterior recreational spaces like wood decks, open porches, enclosed porches, three-season porches, and screen porches. The total area of these amenities can significantly enhance a property's appeal and functionality, thus impacting sale price.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`. This can capture a stronger impact on sale price when both quality and condition are high, rather than just summing them.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Has Garage)\\n# Usefulness: A binary indicator (1 if has garage, 0 otherwise). The presence of a garage is a major convenience and value add for most homebuyers, directly influencing the property's desirability and price.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Has Basement)\\n# Usefulness: A binary indicator (1 if has basement, 0 otherwise). Basements provide additional space and storage, and their presence can significantly affect a home's functionality and value.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Fireplace)\\n# Usefulness: A binary indicator (1 if has a fireplace, 0 otherwise). Fireplaces are often considered desirable amenities for aesthetics and warmth, potentially increasing a home's perceived value.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Has Pool)\\n# Usefulness: A binary indicator (1 if has a pool, 0 otherwise). While not universally desirable, a pool can be a luxury feature that boosts a property's appeal and price in certain markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Quality Rating Interaction)\\n# Usefulness: Interacts `ExterQual` with `KitchenQual` and `BsmtQual`. High quality in these visible areas collectively indicates a well-maintained and desirable home. Categorical quality ratings are mapped to numerical scores.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA'], 'KitchenQual': ['TA', 'Gd', 'TA'], 'BsmtQual': ['TA', 'Gd', 'TA']}\\nquality_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\ndf['ExterQual_mapped'] = df['ExterQual'].map(quality_map).fillna(0)\\ndf['KitchenQual_mapped'] = df['KitchenQual'].map(quality_map).fillna(0)\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map).fillna(0)\\ndf['OverallQualityRatings'] = df['ExterQual_mapped'] + df['KitchenQual_mapped'] + df['BsmtQual_mapped']\\n\\n# (Above Grade Rooms Per Square Foot)\\n# Usefulness: A density measure, showing how many rooms are packed into the above-ground living area. This might indicate efficiency of space usage or unique floorplans that impact appeal.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]}\\ndf['RoomsPerSqFt'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6) # Adding a small epsilon to avoid division by zero\\n\\n# (Log Transformation of LotArea)\\n# Usefulness: LotArea is often skewed, and a log transformation can help normalize its distribution, making it more suitable for linear models and potentially capturing its effect on SalePrice more effectively.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Years Since Last Renovation Or Construction if No Renovation)\\n# Usefulness: Captures the time elapsed since the property was either newly built or last underwent a significant renovation. This metric reflects the freshness and modernity of the property. If no remodel, it's just `HouseAge`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Living Area per Room Above Grade)\\n# Usefulness: This feature captures the average size of rooms above grade. Larger room sizes generally indicate a more spacious and luxurious feel, potentially commanding a higher price.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, min rooms is 1 for GrLivArea > 0.\", \"score\": -0.11564900906267117}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\", \"score\": -0.1149670157247227}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality map for categorical ordinal features where 'NA' means 'no item'\\nquality_rating_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Pool specific quality map where 'NA' means 'no pool'\\npool_quality_map = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\n# Fence specific quality map where 'NA' means 'no fence'\\nfence_quality_map = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- Features from previous blocks (re-created due to error state reset) ---\\n\\n# (Total Living Area SF)\\n# Usefulness: Sum of above-grade living area and total basement square footage. Represents the primary usable living space.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Consolidates all full and half bathrooms into a single metric, valuing half baths as 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age at Sale)\\n# Usefulness: The age of the house when it was sold. Newer homes often command higher prices due to modern design and less wear.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel)\\n# Usefulness: The number of years since the last remodeling. Recent remodels usually increase home value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: Multiplies OverallQual by OverallCond to capture a synergistic effect. Higher values reflect exceptionally well-maintained high-quality homes.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Log-transformed Lot Area)\\n# Usefulness: A log transform reduces skewness in 'LotArea', making its relationship with sale price more linear.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Presence of a Fireplace)\\n# Usefulness: A binary flag for whether the property has any fireplaces, often seen as a desirable amenity.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Presence of a Basement)\\n# Usefulness: Binary flag indicating if the house includes a basement, which adds storage and potential finished space.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Presence of a Garage)\\n# Usefulness: Binary flag for the presence of any garage space. A crucial feature for most homeowners.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Total Exterior Porch and Deck Area)\\n# Usefulness: Sums all square footage from various outdoor covered/deck areas. More outdoor living space generally increases appeal.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Exterior Quality Score)\\n# Usefulness: Numerical conversion of `ExterQual`, reflecting the quality of exterior materials. Good exterior quality enhances curb appeal and perceived value.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Numerical conversion of `KitchenQual`. The kitchen is a key selling point, so its quality heavily influences buyer interest.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Basement Quality Score)\\n# Usefulness: Numerical conversion of `BsmtQual`. Indicates basement quality and functionality, where 'NA' (no basement) maps to 0.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Numerical conversion of `HeatingQC`. High-quality heating contributes to comfort and lower utility costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Numerical conversion of `FireplaceQu`. Quality of fireplaces adds to luxury feel; 'NA' (no fireplace) maps to 0.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Combined Garage Quality Score)\\n# Usefulness: Sums `GarageQual` and `GarageCond` numerical scores. Represents the overall condition and quality of the garage, where 'NA' means no garage (scores 0).\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_Score'] = df['GarageQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['GarageCond_Score'] = df['GarageCond'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['TotalGarageQualityScore'] = df['GarageQual_Score'] + df['GarageCond_Score']\\n\\n# (Age Since Garage Update)\\n# Usefulness: Calculates the years since the garage was built or last extensively remodeled (using max of GarageYrBlt and YearRemodAdd). Newer updates typically indicate better condition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['GarageYrBlt_filled'] = df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt_filled'], df['YearRemodAdd'])\\n\\n# (Home Functionality Score)\\n# Usefulness: Ordinal numerical score for `Functional` status, with 'Typ' being the highest. Reflects the general functionality and repair needs of the house.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7)\\n\\n# (Presence of Masonry Veneer)\\n# Usefulness: A binary flag indicating whether the house has any masonry veneer (brick, stone, etc.). This feature often adds to a home's aesthetic appeal and durability. `MasVnrArea` NaNs are filled with 0.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]}\\ndf['HasMasonryVeneer'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Log-transformed Lot Frontage)\\n# Usefulness: A log transform normalizes the skewed distribution of 'LotFrontage' and smooths its relationship with SalePrice. Missing values are filled with the median.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (Proximity to Positive Off-site Features)\\n# Usefulness: Binary flag if the property is near or adjacent to desirable features like parks. Such locations typically increase property value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['IsNearPositiveFeature'] = ((df['Condition1'].str.contains('Pos')) | (df['Condition2'].str.contains('Pos'))).astype(int)\\n\\n# (Ratio of Garage Area to Car Capacity)\\n# Usefulness: Calculates the average square footage per car in the garage. This might indicate whether a garage offers more than just parking space. Handles cases where GarageCars is zero by making the ratio 0.\\n# Input samples: {'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]}\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars'].replace(0, 1)\\n\\n# (Indicates Near Major Traffic or Railroad)\\n# Usefulness: Binary flag if the property is close to sources of noise or inconvenience like arterial streets or railroads, which can negatively affect value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['NearMajorTrafficRail'] = (\\n    (df['Condition1'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe'])) |\\n    (df['Condition2'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe']))\\n).astype(int)\\n\\n# (Presence of a Pool)\\n# Usefulness: A binary flag indicating if the property includes a pool. Pools are a luxury feature that can increase value in suitable climates/markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Pool Quality Score)\\n# Usefulness: Numerical conversion of `PoolQC`. High-quality pools are more desirable; 'NA' (no pool) maps to 0. Handles potential absence of the 'PoolQC' column.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map).fillna(pool_quality_map['NA'])\\nelse:\\n    # If PoolQC column is not present, assume no pool quality, mapping to 0\\n    df['PoolQC_Score'] = 0\\n\\n# (Remodeled More Recently Than Built)\\n# Usefulness: Binary flag indicating if the `YearRemodAdd` is later than `YearBuilt`. This shows whether the house has undergone a significant modernization.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodeledRecently'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Is Residential)\\n# Usefulness: Binary flag indicating if the property's zoning is residential ('RL', 'RH', 'RM', 'FV', 'RP'). Residential properties are the most common type for single-family homes and may have different price dynamics.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\ndf['IsResidential'] = df['MSZoning'].isin(['RL', 'RH', 'RM', 'FV', 'RP']).astype(int)\\n\\n# (Lot Shape Irregularity Score)\\n# Usefulness: Maps lot shape to an ordinal score, where 'Reg' is most regular (lowest score) and 'IR3' is most irregular (highest score). Irregular lots can sometimes be less desirable or harder to develop.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map({'Reg': 0, 'IR1': 1, 'IR2': 2, 'IR3': 3}).fillna(0)\\n\\n# (Has Utilities for All Public Services)\\n# Usefulness: Binary flag for properties with 'AllPub' utilities. Indicates full standard utility access, a basic expectation that might have a floor effect on value. If 'Utilities' is missing, assume not 'AllPub'.\\n# Input samples: {'Utilities': ['AllPub', 'AllPub', 'AllPub']}\\nif 'Utilities' in df.columns:\\n    df['HasAllPublicUtilities'] = (df['Utilities'] == 'AllPub').astype(int)\\nelse:\\n    df['HasAllPublicUtilities'] = 1 # Assume all public utilities if column missing, as AllPub is dominant in samples.\\n\\n# (Total Baths * OverallQual)\\n# Usefulness: Interaction term combining the total number of bathrooms with overall quality. More baths in a higher quality home indicates higher luxury.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'OverallQual': [5, 8, 5]}\\ndf['TotalBath_x_OverallQual'] = df['TotalBath'] * df['OverallQual']\", \"score\": -0.11434282337426378}], \"predefined_state\": null, \"parent_score\": -0.11434282337426378, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality maps early (needed by BsmtQual, ExterQual, KitchenQual etc.)\\n# Using a common map name for consistency across quality features\\nquality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Garage specific maps might be the same, but kept separate for conceptual clarity/future divergence\\ngarage_quality_map_numeric = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\npool_quality_map_numeric = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\nfence_quality_map_numeric = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- RE-CREATE DEPENDENT FEATURES FROM PREVIOUS BLOCKS DUE TO DISCARDED CHANGES ---\\n# These features are prerequisites for other features within this block or subsequent blocks.\\n\\n# (House Age)\\n# Usefulness: Calculates the age of the house at the time of sale, capturing the depreciation or appreciation effect of age on value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel/Add)\\n# Usefulness: Determines how many years have passed since the house was last remodeled or had an addition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: An interaction feature that multiplies the `OverallQual` and `OverallCond`.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Total Living Area)\\n# Usefulness: Combines above ground and basement finished areas to represent the total living space of the house.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (BsmtQual_mapped)\\n# Usefulness: Numerical mapping of basement quality, necessary for CombinedQual, handles 'NA' for no basement.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_mapped'] = df['BsmtQual'].map(quality_map_numeric).fillna(0)\\n\\n# --- START OF NEW FEATURES AND EXISTING FEATURES FROM THE PROBLEMTAIC BLOCK ---\\n\\n# (PavedDrive_Numeric)\\n# Usefulness: Converts the ordinal categorical feature PavedDrive into a numerical scale reflecting the quality of the driveway.\\n# Input samples: {'PavedDrive': ['Y', 'Y', 'Y']}\\ndf['PavedDrive_Numeric'] = df['PavedDrive'].map({'N': 0, 'P': 1, 'Y': 2}).fillna(0) # Filling NA with 0 if any (unlikely per description but for safety)\\n\\n# (Has2ndFloor)\\n# Usefulness: Creates a binary indicator for houses with a second floor. This structural characteristic can impact design, utility, and price.\\n# Input samples: {'2ndFlrSF': [0, 1168, 672]}\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalFloorSF)\\n# Usefulness: Sums the square footage of the first and second floors, representing the primary above-ground living space, useful for price prediction.\\n# Input samples: {'1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672]}\\ndf['TotalFloorSF'] = df['1stFlrSF'] + df['2ndFlrSF']\\n\\n# (TotalFinBsmtSF)\\n# Usefulness: Combines the finished square footage from both basement finishing types, giving a total measure of functional finished basement space.\\n# Input samples: {'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]}\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (YearsSinceGarageBuilt)\\n# Usefulness: Calculates the age of the garage at the time of sale. An older garage might require more maintenance or upgrades, affecting value. 'NA' means no garage, which is handled implicitly by filling the NaNs in `GarageYrBlt` prior to calculation.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]}\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt']) # Assume garage built same year as house if missing\\n\\n# (BsmtFinRatio)\\n# Usefulness: Calculates the ratio of finished basement area to total basement area. A higher ratio might indicate better utilization of basement space for living purposes.\\n# Input samples: {'TotalFinBsmtSF': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['BsmtFinRatio'] = df['TotalFinBsmtSF'] / df['TotalBsmtSF'].replace(0, 1e-6) # Avoid division by zero\\n\\n# (LogLotFrontage)\\n# Usefulness: Applies a log transformation to 'LotFrontage' to handle potential skewness in the distribution, making it more suitable for linear models and reducing the impact of outliers. NaN values are filled with the median before transformation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (AvgRoomSF)\\n# Usefulness: Computes the average square footage per room above grade. This metric can indicate the spaciousness of rooms, influencing overall perception of value.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1e-6) # Add epsilon to prevent division by zero\\n\\n# (Functional_Score)\\n# Usefulness: Converts the `Functional` feature into an ordinal numerical score where 'Typ' represents the highest functionality. This helps the model interpret house functionality on a linear scale.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7) # 'Typ' as default if NaN, which is not described to have NaNs.\\n\\n# (HeatingQC_Score)\\n# Usefulness: Maps heating quality and condition to an ordinal numerical scale, from poor to excellent. This directly reflects a crucial aspect of home comfort and potential operating costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterQual_Score)\\n# Usefulness: Translates exterior material quality into an ordinal numerical value. High exterior quality implies better curb appeal and less immediate maintenance for the buyer.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (ExterCond_Score)\\n# Usefulness: Quantifies the current condition of the exterior materials, offering a numerical input for regression that correlates with the perceived upkeep and potential future expenses.\\n# Input samples: {'ExterCond': ['TA', 'Gd', 'TA']}\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (KitchenQual_Score)\\n# Usefulness: Assigns an ordinal score to kitchen quality. The kitchen is a key selling point, and its quality significantly influences buyer interest and perceived value.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map_numeric).fillna(quality_map_numeric.get('TA')) # Default to 'TA' if NaN\\n\\n# (TotalGarageQualityScore)\\n# Usefulness: A composite score for the quality and condition of the garage. High scores indicate a well-maintained and valuable garage asset. 'NA' means no garage, which maps to 0.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_mapped'] = df['GarageQual'].map(garage_quality_map_numeric).fillna(0)\\ndf['GarageCond_mapped'] = df['GarageCond'].map(garage_quality_map_numeric).fillna(0)\\ndf['TotalGarageQualityScore'] = df['GarageQual_mapped'] + df['GarageCond_mapped']\\n\\n# (GarageFinish_Score)\\n# Usefulness: Transforms the ordinal `GarageFinish` into a numerical scale (Unf to Fin). A finished garage suggests higher utility and a more completed look, often boosting value. 'NA' for no garage is mapped to 0.\\n# Input samples: {'GarageFinish': ['RFn', 'RFn', 'Unf']}\\ndf['GarageFinish_Score'] = df['GarageFinish'].map({'Unf': 1, 'RFn': 2, 'Fin': 3, 'NA': 0}).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts pool quality into a numerical score, essential for houses with this luxury feature. 'NA' indicates no pool, correctly mapping to 0 for absence of quality. If the 'PoolQC' column is entirely missing, it implies no pool quality is present.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map_numeric).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0\\n\\n# (Fence_Score)\\n# Usefulness: Ranks fence quality numerically. A higher-quality fence offers more privacy and aesthetic appeal, potentially adding value. 'NA' means no fence.\\n# Input samples: {'Fence': ['GdWo', np.nan, np.nan]}\\ndf['Fence_Score'] = df['Fence'].map(fence_quality_map_numeric).fillna(0)\\n\\n# (Remod_Per_Age_Ratio)\\n# Usefulness: The ratio of `YearsSinceRemod` to `HouseAge`. This can indicate if the house has been frequently updated relative to its total age, which might be a positive or negative sign depending on the remodel types.\\n# Input samples: {'YearsSinceRemod': [26, 13, 9], 'HouseAge': [48, 13, 77]}\\ndf['Remod_Per_Age_Ratio'] = df['YearsSinceRemod'] / (df['HouseAge'].replace(0, 1e-6))\\n\\n# (TotalRoomQualCond)\\n# Usefulness: An interaction feature that combines the count of rooms above ground with the overall quality and condition. This captures the total *valued* space, assuming better quality makes each room more desirable.\\n# Input samples: {'TotRmsAbvGrd': [6, 10, 6], 'OverallQualCond': [30, 56, 25]}\\ndf['TotalRoomQualCond'] = df['TotRmsAbvGrd'] * df['OverallQualCond']\\n\\n# (Neighborhood_HighValue)\\n# Usefulness: Identifies if a property is in a generally high-value neighborhood ('NoRidge', 'NridgHt', 'StoneBr'), which often command higher sale prices. This is a binary flag.\\n# Input samples: {'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']}\\ndf['Neighborhood_HighValue'] = df['Neighborhood'].apply(lambda x: 1 if x in ['NoRidge', 'NridgHt', 'StoneBr'] else 0)\\n\\n# (MSSubClass_Density)\\n# Usefulness: Calculates the ratio of the total living area (GrLivArea + TotalBsmtSF) to the numerical representation of `MSSubClass`. This attempts to normalize house size by type of dwelling. High ratio might mean a very large dwelling for its category.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'MSSubClass': [20, 60, 50]}\\ndf['MSSubClass_Density'] = df['TotalLivAreaSF'] / df['MSSubClass'].replace(0, 1e-6)\\n\\n# (Is_NewConstruction)\\n# Usefulness: A binary flag indicating if the `SaleType` is 'New' or `SaleCondition` is 'Partial' (indicating an unfinished new home). New homes typically sell at higher prices due to modern amenities and lack of wear.\\n# Input samples: {'SaleType': ['WD', 'WD', 'WD'], 'SaleCondition': ['Normal', 'Abnorml', 'Abnorml']}\\ndf['Is_NewConstruction'] = ((df['SaleType'] == 'New') | (df['SaleCondition'] == 'Partial')).astype(int)\\n\\n# (CombinedQual)\\n# Usefulness: Combines `OverallQual`, `ExterQual_Score`, `KitchenQual_Score`, `BsmtQual_mapped`, and `HeatingQC_Score` into a single, comprehensive quality index. This aggregate reflects multiple dimensions of property quality.\\n# Input samples: {'OverallQual': [5, 8, 5], 'ExterQual_Score': [2, 3, 2], 'KitchenQual_Score': [2, 3, 2], 'BsmtQual_mapped': [3, 4, 3], 'HeatingQC_Score': [4, 4, 4]}\\ndf['CombinedQual'] = df['OverallQual'] + df['ExterQual_Score'] + df['KitchenQual_Score'] + df['BsmtQual_mapped'] + df['HeatingQC_Score']\\n\\n# (LotFrontage_Ratio_to_Area)\\n# Usefulness: This ratio can indicate the shape of the lot (e.g., long and narrow vs. wide and shallow). Irregular shapes or less accessible frontages could influence desirability and price. Fill NaN values with the median before ratio calculation.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0], 'LotArea': [10000, 14541, 4500]}\\ndf['LotFrontage_Ratio_to_Area'] = df['LotFrontage'].fillna(df['LotFrontage'].median()) / df['LotArea'].replace(0, 1e-6)\\n\\n# (AgeSinceGarageUpdate)\\n# Usefulness: Captures the time since the garage was either built or significantly remodeled/maintained. Similar to house remodel, a more recently updated garage suggests better condition. Assume house remodel applies to garage if garage year is earlier than remodel year.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt'].fillna(df['YearBuilt']), df['YearRemodAdd'])\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality map for categorical ordinal features where 'NA' means 'no item'\\nquality_rating_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Pool specific quality map where 'NA' means 'no pool'\\npool_quality_map = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\n# Fence specific quality map where 'NA' means 'no fence'\\nfence_quality_map = {'MnWw': 1, 'GdWo': 2, 'MnPrv': 3, 'GdPrv': 4, 'NA': 0}\\n\\n# --- Features from previous blocks (re-created due to error state reset) ---\\n\\n# (Total Living Area SF)\\n# Usefulness: Sum of above-grade living area and total basement square footage. Represents the primary usable living space.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\ndf['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Consolidates all full and half bathrooms into a single metric, valuing half baths as 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\ndf['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age at Sale)\\n# Usefulness: The age of the house when it was sold. Newer homes often command higher prices due to modern design and less wear.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel)\\n# Usefulness: The number of years since the last remodeling. Recent remodels usually increase home value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: Multiplies OverallQual by OverallCond to capture a synergistic effect. Higher values reflect exceptionally well-maintained high-quality homes.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\ndf['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Log-transformed Lot Area)\\n# Usefulness: A log transform reduces skewness in 'LotArea', making its relationship with sale price more linear.\\n# Input samples: {'LotArea': [10000, 14541, 4500]}\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Presence of a Fireplace)\\n# Usefulness: A binary flag for whether the property has any fireplaces, often seen as a desirable amenity.\\n# Input samples: {'Fireplaces': [1, 1, 0]}\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Presence of a Basement)\\n# Usefulness: Binary flag indicating if the house includes a basement, which adds storage and potential finished space.\\n# Input samples: {'TotalBsmtSF': [864, 1338, 793]}\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Presence of a Garage)\\n# Usefulness: Binary flag for the presence of any garage space. A crucial feature for most homeowners.\\n# Input samples: {'GarageArea': [264, 796, 281]}\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Total Exterior Porch and Deck Area)\\n# Usefulness: Sums all square footage from various outdoor covered/deck areas. More outdoor living space generally increases appeal.\\n# Input samples: {'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Exterior Quality Score)\\n# Usefulness: Numerical conversion of `ExterQual`, reflecting the quality of exterior materials. Good exterior quality enhances curb appeal and perceived value.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Numerical conversion of `KitchenQual`. The kitchen is a key selling point, so its quality heavily influences buyer interest.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Basement Quality Score)\\n# Usefulness: Numerical conversion of `BsmtQual`. Indicates basement quality and functionality, where 'NA' (no basement) maps to 0.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Numerical conversion of `HeatingQC`. High-quality heating contributes to comfort and lower utility costs.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Fireplace Quality Score)\\n# Usefulness: Numerical conversion of `FireplaceQu`. Quality of fireplaces adds to luxury feel; 'NA' (no fireplace) maps to 0.\\n# Input samples: {'FireplaceQu': ['TA', 'TA', np.nan]}\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Combined Garage Quality Score)\\n# Usefulness: Sums `GarageQual` and `GarageCond` numerical scores. Represents the overall condition and quality of the garage, where 'NA' means no garage (scores 0).\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\ndf['GarageQual_Score'] = df['GarageQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['GarageCond_Score'] = df['GarageCond'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\ndf['TotalGarageQualityScore'] = df['GarageQual_Score'] + df['GarageCond_Score']\\n\\n# (Age Since Garage Update)\\n# Usefulness: Calculates the years since the garage was built or last extensively remodeled (using max of GarageYrBlt and YearRemodAdd). Newer updates typically indicate better condition.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['GarageYrBlt_filled'] = df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf['AgeSinceGarageUpdate'] = df['YrSold'] - np.maximum(df['GarageYrBlt_filled'], df['YearRemodAdd'])\\n\\n# (Home Functionality Score)\\n# Usefulness: Ordinal numerical score for `Functional` status, with 'Typ' being the highest. Reflects the general functionality and repair needs of the house.\\n# Input samples: {'Functional': ['Typ', 'Typ', 'Typ']}\\ndf['Functional_Score'] = df['Functional'].map({'Sal': 0, 'Sev': 1, 'Maj2': 2, 'Maj1': 3, 'Mod': 4, 'Min2': 5, 'Min1': 6, 'Typ': 7}).fillna(7)\\n\\n# (Presence of Masonry Veneer)\\n# Usefulness: A binary flag indicating whether the house has any masonry veneer (brick, stone, etc.). This feature often adds to a home's aesthetic appeal and durability. `MasVnrArea` NaNs are filled with 0.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]}\\ndf['HasMasonryVeneer'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Log-transformed Lot Frontage)\\n# Usefulness: A log transform normalizes the skewed distribution of 'LotFrontage' and smooths its relationship with SalePrice. Missing values are filled with the median.\\n# Input samples: {'LotFrontage': [80.0, np.nan, 55.0]}\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage'].fillna(df['LotFrontage'].median()))\\n\\n# (Proximity to Positive Off-site Features)\\n# Usefulness: Binary flag if the property is near or adjacent to desirable features like parks. Such locations typically increase property value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['IsNearPositiveFeature'] = ((df['Condition1'].str.contains('Pos')) | (df['Condition2'].str.contains('Pos'))).astype(int)\\n\\n# (Ratio of Garage Area to Car Capacity)\\n# Usefulness: Calculates the average square footage per car in the garage. This might indicate whether a garage offers more than just parking space. Handles cases where GarageCars is zero by making the ratio 0.\\n# Input samples: {'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]}\\ndf['GarageAreaPerCar'] = df['GarageArea'] / df['GarageCars'].replace(0, 1)\\n\\n# (Indicates Near Major Traffic or Railroad)\\n# Usefulness: Binary flag if the property is close to sources of noise or inconvenience like arterial streets or railroads, which can negatively affect value.\\n# Input samples: {'Condition1': ['Feedr', 'Norm', 'Norm'], 'Condition2': ['Norm', 'Norm', 'Norm']}\\ndf['NearMajorTrafficRail'] = (\\n    (df['Condition1'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe'])) |\\n    (df['Condition2'].isin(['Artery', 'Feedr', 'RRAn', 'RRNn', 'RRAe', 'RRNe']))\\n).astype(int)\\n\\n# (Presence of a Pool)\\n# Usefulness: A binary flag indicating if the property includes a pool. Pools are a luxury feature that can increase value in suitable climates/markets.\\n# Input samples: {'PoolArea': [0, 0, 0]}\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Pool Quality Score)\\n# Usefulness: Numerical conversion of `PoolQC`. High-quality pools are more desirable; 'NA' (no pool) maps to 0. Handles potential absence of the 'PoolQC' column.\\n# Input samples: {'PoolQC': [np.nan, np.nan, np.nan]}\\nif 'PoolQC' in df.columns:\\n    df['PoolQC_Score'] = df['PoolQC'].map(pool_quality_map).fillna(pool_quality_map['NA'])\\nelse:\\n    # If PoolQC column is not present, assume no pool quality, mapping to 0\\n    df['PoolQC_Score'] = 0\\n\\n# (Remodeled More Recently Than Built)\\n# Usefulness: Binary flag indicating if the `YearRemodAdd` is later than `YearBuilt`. This shows whether the house has undergone a significant modernization.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\ndf['RemodeledRecently'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Is Residential)\\n# Usefulness: Binary flag indicating if the property's zoning is residential ('RL', 'RH', 'RM', 'FV', 'RP'). Residential properties are the most common type for single-family homes and may have different price dynamics.\\n# Input samples: {'MSZoning': ['RL', 'RL', 'RH']}\\ndf['IsResidential'] = df['MSZoning'].isin(['RL', 'RH', 'RM', 'FV', 'RP']).astype(int)\\n\\n# (Lot Shape Irregularity Score)\\n# Usefulness: Maps lot shape to an ordinal score, where 'Reg' is most regular (lowest score) and 'IR3' is most irregular (highest score). Irregular lots can sometimes be less desirable or harder to develop.\\n# Input samples: {'LotShape': ['Reg', 'IR1', 'IR2']}\\ndf['LotShape_Score'] = df['LotShape'].map({'Reg': 0, 'IR1': 1, 'IR2': 2, 'IR3': 3}).fillna(0)\\n\\n# (Has Utilities for All Public Services)\\n# Usefulness: Binary flag for properties with 'AllPub' utilities. Indicates full standard utility access, a basic expectation that might have a floor effect on value. If 'Utilities' is missing, assume not 'AllPub'.\\n# Input samples: {'Utilities': ['AllPub', 'AllPub', 'AllPub']}\\nif 'Utilities' in df.columns:\\n    df['HasAllPublicUtilities'] = (df['Utilities'] == 'AllPub').astype(int)\\nelse:\\n    df['HasAllPublicUtilities'] = 1 # Assume all public utilities if column missing, as AllPub is dominant in samples.\\n\\n# (Total Baths * OverallQual)\\n# Usefulness: Interaction term combining the total number of bathrooms with overall quality. More baths in a higher quality home indicates higher luxury.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'OverallQual': [5, 8, 5]}\\ndf['TotalBath_x_OverallQual'] = df['TotalBath'] * df['OverallQual']\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality map for categorical ordinal features where 'NA' means 'no item'\\nquality_rating_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Basement Finish Type specific map, 'NA' means no basement\\nbsmt_fin_type_map = {'Unf': 1, 'LwQ': 2, 'Rec': 3, 'BLQ': 4, 'ALQ': 5, 'GLQ': 6, 'NA': 0}\\n# Alley Access Type map, 'NA' means no alley\\nalley_map = {'Grvl': 1, 'Pave': 2, 'NA': 0}\\n# Foundation Type numerical mapping for interaction\\nfoundation_type_score_map = {'BrkTil': 1, 'CBlock': 2, 'PConc': 3, 'Slab': 1, 'Stone': 2, 'Wood': 1}\\n# Pool specific quality map where 'NA' means 'no pool'\\npool_quality_map = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\n\\n# --- IMPORTANT: Ensure necessary prerequisite features from prior successful blocks are present. ---\\n# These checks and recreations are to ensure continuity after previous block failures or state resets.\\n\\n# (Total Living Area SF)\\n# Usefulness: Sum of above-grade living area and total basement square footage. Represents the primary usable living space.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\nif 'TotalLivAreaSF' not in df.columns: # Recreate if lost from previous block's successful execution\\n    df['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Consolidates all full and half bathrooms into a single metric, valuing half baths as 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\nif 'TotalBath' not in df.columns:\\n    df['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age at Sale)\\n# Usefulness: The age of the house when it was sold. Newer homes often command higher prices due to modern design and less wear.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\nif 'HouseAge' not in df.columns:\\n    df['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel)\\n# Usefulness: The number of years since the last remodeling. Recent remodels usually increase home value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\nif 'YearsSinceRemod' not in df.columns:\\n    df['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: Multiplies OverallQual by OverallCond to capture a synergistic effect. Higher values reflect exceptionally well-maintained high-quality homes.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\nif 'OverallQualCond' not in df.columns:\\n    df['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Remodeled More Recently Than Built)\\n# Usefulness: Binary flag indicating if the `YearRemodAdd` is later than `YearBuilt`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\nif 'RemodeledRecently' not in df.columns:\\n    df['RemodeledRecently'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Basement Quality Score)\\n# Usefulness: Numerical conversion of `BsmtQual`. 'NA' maps to 0.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\nif 'BsmtQual_Score' not in df.columns:\\n    df['BsmtQual_Score'] = df['BsmtQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Exterior Quality Score)\\n# Usefulness: Numerical conversion of `ExterQual`.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\nif 'ExterQual_Score' not in df.columns:\\n    df['ExterQual_Score'] = df['ExterQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Numerical conversion of `KitchenQual`.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\nif 'KitchenQual_Score' not in df.columns:\\n    df['KitchenQual_Score'] = df['KitchenQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Numerical conversion of `HeatingQC`.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\nif 'HeatingQC_Score' not in df.columns:\\n    df['HeatingQC_Score'] = df['HeatingQC'].map(quality_rating_map).fillna(quality_rating_map.get('TA'))\\n\\n# (Combined Garage Quality Score)\\n# Usefulness: Sums `GarageQual` and `GarageCond` numerical scores.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\nif 'TotalGarageQualityScore' not in df.columns:\\n    df['GarageQual_Score'] = df['GarageQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n    df['GarageCond_Score'] = df['GarageCond'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n    df['TotalGarageQualityScore'] = df['GarageQual_Score'] + df['GarageCond_Score']\\n\\n# (Age At Sale - most recent of built or remodelled)\\n# Usefulness: Calculates time elapsed since the latest construction or significant update.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\nif 'AgeAtSale' not in df.columns:\\n    df['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (BsmtFinType1 Score)\\n# Usefulness: Converts 'BsmtFinType1' (rating of basement finished area type 1) to an ordinal numeric scale.\\n# Input samples: {'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']}\\nif 'BsmtFinType1_Score' not in df.columns:\\n    df['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (BsmtFinType2 Score)\\n# Usefulness: Converts 'BsmtFinType2' (rating of basement finished area type 2) to an ordinal numeric scale.\\n# Input samples: {'BsmtFinType2': ['Unf', 'Unf', 'Unf']}\\nif 'BsmtFinType2_Score' not in df.columns:\\n    df['BsmtFinType2_Score'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n\\n# --- START OF NEW FEATURES and FIX for 'Street' KeyError ---\\n\\n# (Bathrooms per Bedroom)\\n# Usefulness: Ratio of total bathrooms to bedrooms above grade. Higher ratios often imply more luxury and comfort for residents. Handles zero bedrooms by replacing with a small number.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'BedroomAbvGr': [3, 5, 3]}\\ndf['BathPerBedroom'] = df['TotalBath'] / df['BedroomAbvGr'].replace(0, 1e-6)\\n\\n# (Central Air Conditioning Numeric)\\n# Usefulness: Converts 'CentralAir' from 'Y'/'N' to 1/0. Central air is a significant modern amenity expected by many buyers.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['CentralAir_Numeric'] = df['CentralAir'].map({'N': 0, 'Y': 1}).fillna(0)\\n\\n# (MasVnrType - Is Stone)\\n# Usefulness: Binary flag indicating if the house has a 'Stone' masonry veneer. Stone veneer often suggests a premium or more luxurious finish.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan, 'BrkFace']}\\ndf['MasVnrIsStone'] = (df['MasVnrType'] == 'Stone').astype(int)\\n\\n# (MasVnrType - Is BrickFace)\\n# Usefulness: Binary flag indicating if the house has a 'BrkFace' masonry veneer. Brick face is a common and often desirable exterior finish.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan, 'BrkFace']}\\ndf['MasVnrIsBrickFace'] = (df['MasVnrType'] == 'BrkFace').astype(int)\\n\\n# (Is Poured Concrete Foundation)\\n# Usefulness: Binary flag for houses built with a 'PConc' (Poured Concrete) foundation. This is a common and robust modern foundation type, often preferred.\\n# Input samples: {'Foundation': ['CBlock', 'PConc', 'BrkTil']}\\ndf['IsPouredConcreteFoundation'] = (df['Foundation'] == 'PConc').astype(int)\\n\\n# (Electrical System Quality Score)\\n# Usefulness: Maps the 'Electrical' system quality to an ordinal numeric scale. A modern 'SBrkr' system is highly desirable.\\n# Input samples: {'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']}\\ndf['Electrical_Score'] = df['Electrical'].map({'FuseP': 1, 'FuseF': 2, 'FuseA': 3, 'SBrkr': 4, 'Mix': 2.5}).fillna(4)\\n\\n# (Paved Street Access)\\n# Usefulness: Binary flag indicating if the property has 'Pave' street access. Paved roads are a basic amenity contributing to ease of access and curb appeal.\\n# Input samples: {'Street': ['Pave', 'Pave', 'Pave']}\\n# Defensive check added to address potential KeyError 'Street' from previous run, assuming default 'Pave' if column missing.\\nif 'Street' in df.columns:\\n    df['Street_Paved'] = (df['Street'] == 'Pave').astype(int)\\nelse:\\n    # Based on samples, 'Pave' is overwhelmingly common for 'Street'. Set to 1 if column is mysteriously absent.\\n    df['Street_Paved'] = 1\\n\\n# (Total Usable Square Footage - Living, Basement, Garage)\\n# Usefulness: A more comprehensive total square footage metric, combining above-grade living, total basement, and total garage area. This aims to capture all functional enclosed space.\\n# Input samples: {'TotalLivAreaSF': [2008, 3858, 2313], 'GarageArea': [264, 796, 281]}\\ndf['TotalHomeSF'] = df['TotalLivAreaSF'] + df['GarageArea']\\n\\n# (Age * Overall Quality Interaction)\\n# Usefulness: An interaction feature combining the 'HouseAge' and 'OverallQual'. This can capture how the age of the house impacts value differently based on its overall quality.\\n# Input samples: {'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5]}\\ndf['Age_x_OverallQual'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Remodeled House Quality Increase)\\n# Usefulness: Multiplies `RemodeledRecently` (1 if remodeled after built) with the sum of relevant quality scores. Highlights value gained from high-quality recent renovations.\\n# Input samples: {'RemodeledRecently': [1, 0, 1], 'OverallQual': [5, 8, 5], 'KitchenQual_Score': [3, 4, 3], 'ExterQual_Score': [3, 4, 3]}\\ndf['RemodelEffectQual'] = df['RemodeledRecently'] * (df['OverallQual'] + df['KitchenQual_Score'] + df['ExterQual_Score'])\\n\\n# (Average Room Size)\\n# Usefulness: Represents the average size of rooms above ground. Larger average room size can correlate with a more luxurious or spacious feel. Replaces 0 `TotRmsAbvGrd` to avoid division by zero.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSize'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1)\\n\\n# (Bathroom Density in Gross Living Area)\\n# Usefulness: Represents the density of bathrooms relative to the above-ground living area. High density might indicate a more luxurious or specialized layout.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'GrLivArea': [1144, 2520, 1520]}\\ndf['BathDensityGrLiv'] = df['TotalBath'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Log Transformed Masonry Veneer Area)\\n# Usefulness: Applies a log transform to `MasVnrArea` to normalize its distribution, as it often has a zero-inflated and skewed distribution.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0, 167.0]}\\ndf['LogMasVnrArea'] = np.log1p(df['MasVnrArea'].fillna(0))\\n\\n# (Has Any Porch Area)\\n# Usefulness: Binary flag indicating the presence of *any* type of porch (open, enclosed, 3-season, screen).\\n# Input samples: {'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['HasAnyPorch'] = ((df['OpenPorchSF'] > 0) | (df['EnclosedPorch'] > 0) | (df['3SsnPorch'] > 0) | (df['ScreenPorch'] > 0)).astype(int)\\n\\n# (Years Since House Built or Remodeled, Squared)\\n# Usefulness: Squaring `AgeAtSale` can capture non-linear depreciation patterns.\\n# Input samples: {'AgeAtSale': [48, 13, 77]}\\ndf['AgeAtSale_Sq'] = df['AgeAtSale'] ** 2\\n\\n# (Garage Size multiplied by its Overall Quality Score)\\n# Usefulness: Interaction between garage area and its total quality. A large, high-quality garage is likely more valuable.\\n# Input samples: {'GarageArea': [264, 796, 281], 'TotalGarageQualityScore': [6, 6, 6]}\\ndf['GarageArea_x_Qual'] = df['GarageArea'] * df['TotalGarageQualityScore']\\n\\n# (Lot Configuration indicates Corner or Cul-de-Sac)\\n# Usefulness: Flags whether the property is a corner lot or on a cul-de-sac. These often affect privacy, traffic, and lot utility.\\n# Input samples: {'LotConfig': ['Corner', 'Corner', 'Inside']}\\ndf['LotConfig_Special'] = df['LotConfig'].isin(['Corner', 'CulDSac']).astype(int)\\n\\n# (Average Basement Finished Type Score)\\n# Usefulness: Aggregated metric for the quality of finished basement areas.\\n# Input samples: {'BsmtFinType1_Score': [4, 6, 3], 'BsmtFinType2_Score': [1, 1, 1]}\\ndf['AvgBsmtFinTypeScore'] = (df['BsmtFinType1_Score'] + df['BsmtFinType2_Score']) / df[['BsmtFinType1_Score', 'BsmtFinType2_Score']].apply(lambda x: (x > 0).astype(int).sum() if (x > 0).astype(int).sum() > 0 else 1, axis=1)\\n\\n# (Total Square Footage Excluding Low Quality Finish)\\n# Usefulness: Excludes `LowQualFinSF` from `GrLivArea` to represent more \\\"desirable\\\" above-grade finished space, combined with total basement and garage areas.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'LowQualFinSF': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]}\\ndf['TotalSFExclLowQual'] = (df['GrLivArea'] - df['LowQualFinSF']) + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# (MSSubClass and HouseAge Interaction)\\n# Usefulness: Interaction between dwelling type ('MSSubClass') and 'HouseAge'. Captures type-specific aging effects on value.\\n# Input samples: {'MSSubClass': [20, 60, 50], 'HouseAge': [48, 13, 77]}\\ndf['MSSubClass_x_HouseAge'] = df['MSSubClass'] * df['HouseAge']\\n\\n# (Land Slope is Not Gentle)\\n# Usefulness: Binary flag if 'LandSlope' is 'Mod' (Moderate) or 'Sev' (Severe), impacting usability.\\n# Input samples: {'LandSlope': ['Gtl', 'Gtl', 'Gtl']}\\ndf['LandSlope_NotGtl'] = df['LandSlope'].isin(['Mod', 'Sev']).astype(int)\\n\\n# (Has Unfinished Basement Area)\\n# Usefulness: Binary flag indicating if there is any unfinished basement space.\\n# Input samples: {'BsmtUnfSF': [270, 326, 611]}\\ndf['HasUnfBsmt'] = (df['BsmtUnfSF'] > 0).astype(int)\\n\\n# (Foundation Type Interaction with Overall Quality)\\n# Usefulness: Interaction combining numerical score for 'Foundation' type with 'OverallQual'.\\n# Input samples: {'Foundation': ['CBlock', 'PConc', 'BrkTil'], 'OverallQual': [5, 8, 5]}\\ndf['Foundation_Type_Score'] = df['Foundation'].map(foundation_type_score_map).fillna(1)\\ndf['Foundation_x_OverallQual'] = df['Foundation_Type_Score'] * df['OverallQual']\\n\\n# (Alley Access Numeric Score)\\n# Usefulness: Ordinal numerical representation of 'Alley' access quality, where 'NA' (no alley) is 0.\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Alley_Score'] = df['Alley'].map(alley_map).fillna(0)\\n\\n# (Heating Quality Interaction with Total Living Area)\\n# Usefulness: Interaction between `HeatingQC_Score` and `TotalLivAreaSF`.\\n# Input samples: {'HeatingQC_Score': [5, 5, 5], 'TotalLivAreaSF': [2008, 3858, 2313]}\\ndf['HeatingQual_x_LivArea'] = df['HeatingQC_Score'] * df['TotalLivAreaSF']\"]}, \"score\": -0.27066685945622104, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define shared quality map for categorical ordinal features where 'NA' means 'no item'\\nquality_rating_map = {'Po': 1, 'Fa': 2, 'TA': 3, 'Gd': 4, 'Ex': 5, 'NA': 0}\\n# Basement Finish Type specific map, 'NA' means no basement\\nbsmt_fin_type_map = {'Unf': 1, 'LwQ': 2, 'Rec': 3, 'BLQ': 4, 'ALQ': 5, 'GLQ': 6, 'NA': 0}\\n# Alley Access Type map, 'NA' means no alley\\nalley_map = {'Grvl': 1, 'Pave': 2, 'NA': 0}\\n# Foundation Type numerical mapping for interaction\\nfoundation_type_score_map = {'BrkTil': 1, 'CBlock': 2, 'PConc': 3, 'Slab': 1, 'Stone': 2, 'Wood': 1}\\n# Pool specific quality map where 'NA' means 'no pool'\\npool_quality_map = {'Fa': 1, 'TA': 2, 'Gd': 3, 'Ex': 4, 'NA': 0}\\n\\n# --- IMPORTANT: Ensure necessary prerequisite features from prior successful blocks are present. ---\\n# These checks and recreations are to ensure continuity after previous block failures or state resets.\\n\\n# (Total Living Area SF)\\n# Usefulness: Sum of above-grade living area and total basement square footage. Represents the primary usable living space.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]}\\nif 'TotalLivAreaSF' not in df.columns: # Recreate if lost from previous block's successful execution\\n    df['TotalLivAreaSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total Number of Bathrooms)\\n# Usefulness: Consolidates all full and half bathrooms into a single metric, valuing half baths as 0.5.\\n# Input samples: {'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]}\\nif 'TotalBath' not in df.columns:\\n    df['TotalBath'] = df['FullBath'] + (0.5 * df['HalfBath']) + df['BsmtFullBath'] + (0.5 * df['BsmtHalfBath'])\\n\\n# (House Age at Sale)\\n# Usefulness: The age of the house when it was sold. Newer homes often command higher prices due to modern design and less wear.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]}\\nif 'HouseAge' not in df.columns:\\n    df['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years Since Last Remodel)\\n# Usefulness: The number of years since the last remodeling. Recent remodels usually increase home value.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]}\\nif 'YearsSinceRemod' not in df.columns:\\n    df['YearsSinceRemod'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined Overall Quality and Condition)\\n# Usefulness: Multiplies OverallQual by OverallCond to capture a synergistic effect. Higher values reflect exceptionally well-maintained high-quality homes.\\n# Input samples: {'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]}\\nif 'OverallQualCond' not in df.columns:\\n    df['OverallQualCond'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Remodeled More Recently Than Built)\\n# Usefulness: Binary flag indicating if the `YearRemodAdd` is later than `YearBuilt`.\\n# Input samples: {'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\nif 'RemodeledRecently' not in df.columns:\\n    df['RemodeledRecently'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Basement Quality Score)\\n# Usefulness: Numerical conversion of `BsmtQual`. 'NA' maps to 0.\\n# Input samples: {'BsmtQual': ['TA', 'Gd', 'TA']}\\nif 'BsmtQual_Score' not in df.columns:\\n    df['BsmtQual_Score'] = df['BsmtQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n\\n# (Exterior Quality Score)\\n# Usefulness: Numerical conversion of `ExterQual`.\\n# Input samples: {'ExterQual': ['TA', 'Gd', 'TA']}\\nif 'ExterQual_Score' not in df.columns:\\n    df['ExterQual_Score'] = df['ExterQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Kitchen Quality Score)\\n# Usefulness: Numerical conversion of `KitchenQual`.\\n# Input samples: {'KitchenQual': ['TA', 'Gd', 'TA']}\\nif 'KitchenQual_Score' not in df.columns:\\n    df['KitchenQual_Score'] = df['KitchenQual'].map(quality_rating_map).fillna(quality_rating_map['TA'])\\n\\n# (Heating Quality Score)\\n# Usefulness: Numerical conversion of `HeatingQC`.\\n# Input samples: {'HeatingQC': ['Ex', 'Ex', 'Ex']}\\nif 'HeatingQC_Score' not in df.columns:\\n    df['HeatingQC_Score'] = df['HeatingQC'].map(quality_rating_map).fillna(quality_rating_map.get('TA'))\\n\\n# (Combined Garage Quality Score)\\n# Usefulness: Sums `GarageQual` and `GarageCond` numerical scores.\\n# Input samples: {'GarageQual': ['TA', 'TA', 'TA'], 'GarageCond': ['TA', 'TA', 'TA']}\\nif 'TotalGarageQualityScore' not in df.columns:\\n    df['GarageQual_Score'] = df['GarageQual'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n    df['GarageCond_Score'] = df['GarageCond'].map(quality_rating_map).fillna(quality_rating_map['NA'])\\n    df['TotalGarageQualityScore'] = df['GarageQual_Score'] + df['GarageCond_Score']\\n\\n# (Age At Sale - most recent of built or remodelled)\\n# Usefulness: Calculates time elapsed since the latest construction or significant update.\\n# Input samples: {'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]}\\nif 'AgeAtSale' not in df.columns:\\n    df['AgeAtSale'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (BsmtFinType1 Score)\\n# Usefulness: Converts 'BsmtFinType1' (rating of basement finished area type 1) to an ordinal numeric scale.\\n# Input samples: {'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']}\\nif 'BsmtFinType1_Score' not in df.columns:\\n    df['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (BsmtFinType2 Score)\\n# Usefulness: Converts 'BsmtFinType2' (rating of basement finished area type 2) to an ordinal numeric scale.\\n# Input samples: {'BsmtFinType2': ['Unf', 'Unf', 'Unf']}\\nif 'BsmtFinType2_Score' not in df.columns:\\n    df['BsmtFinType2_Score'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n\\n# --- START OF NEW FEATURES and FIX for 'Street' KeyError ---\\n\\n# (Bathrooms per Bedroom)\\n# Usefulness: Ratio of total bathrooms to bedrooms above grade. Higher ratios often imply more luxury and comfort for residents. Handles zero bedrooms by replacing with a small number.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'BedroomAbvGr': [3, 5, 3]}\\ndf['BathPerBedroom'] = df['TotalBath'] / df['BedroomAbvGr'].replace(0, 1e-6)\\n\\n# (Central Air Conditioning Numeric)\\n# Usefulness: Converts 'CentralAir' from 'Y'/'N' to 1/0. Central air is a significant modern amenity expected by many buyers.\\n# Input samples: {'CentralAir': ['Y', 'Y', 'Y']}\\ndf['CentralAir_Numeric'] = df['CentralAir'].map({'N': 0, 'Y': 1}).fillna(0)\\n\\n# (MasVnrType - Is Stone)\\n# Usefulness: Binary flag indicating if the house has a 'Stone' masonry veneer. Stone veneer often suggests a premium or more luxurious finish.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan, 'BrkFace']}\\ndf['MasVnrIsStone'] = (df['MasVnrType'] == 'Stone').astype(int)\\n\\n# (MasVnrType - Is BrickFace)\\n# Usefulness: Binary flag indicating if the house has a 'BrkFace' masonry veneer. Brick face is a common and often desirable exterior finish.\\n# Input samples: {'MasVnrType': [np.nan, np.nan, np.nan, 'BrkFace']}\\ndf['MasVnrIsBrickFace'] = (df['MasVnrType'] == 'BrkFace').astype(int)\\n\\n# (Is Poured Concrete Foundation)\\n# Usefulness: Binary flag for houses built with a 'PConc' (Poured Concrete) foundation. This is a common and robust modern foundation type, often preferred.\\n# Input samples: {'Foundation': ['CBlock', 'PConc', 'BrkTil']}\\ndf['IsPouredConcreteFoundation'] = (df['Foundation'] == 'PConc').astype(int)\\n\\n# (Electrical System Quality Score)\\n# Usefulness: Maps the 'Electrical' system quality to an ordinal numeric scale. A modern 'SBrkr' system is highly desirable.\\n# Input samples: {'Electrical': ['SBrkr', 'SBrkr', 'SBrkr']}\\ndf['Electrical_Score'] = df['Electrical'].map({'FuseP': 1, 'FuseF': 2, 'FuseA': 3, 'SBrkr': 4, 'Mix': 2.5}).fillna(4)\\n\\n# (Paved Street Access)\\n# Usefulness: Binary flag indicating if the property has 'Pave' street access. Paved roads are a basic amenity contributing to ease of access and curb appeal.\\n# Input samples: {'Street': ['Pave', 'Pave', 'Pave']}\\n# Defensive check added to address potential KeyError 'Street' from previous run, assuming default 'Pave' if column missing.\\nif 'Street' in df.columns:\\n    df['Street_Paved'] = (df['Street'] == 'Pave').astype(int)\\nelse:\\n    # Based on samples, 'Pave' is overwhelmingly common for 'Street'. Set to 1 if column is mysteriously absent.\\n    df['Street_Paved'] = 1\\n\\n# (Total Usable Square Footage - Living, Basement, Garage)\\n# Usefulness: A more comprehensive total square footage metric, combining above-grade living, total basement, and total garage area. This aims to capture all functional enclosed space.\\n# Input samples: {'TotalLivAreaSF': [2008, 3858, 2313], 'GarageArea': [264, 796, 281]}\\ndf['TotalHomeSF'] = df['TotalLivAreaSF'] + df['GarageArea']\\n\\n# (Age * Overall Quality Interaction)\\n# Usefulness: An interaction feature combining the 'HouseAge' and 'OverallQual'. This can capture how the age of the house impacts value differently based on its overall quality.\\n# Input samples: {'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5]}\\ndf['Age_x_OverallQual'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Remodeled House Quality Increase)\\n# Usefulness: Multiplies `RemodeledRecently` (1 if remodeled after built) with the sum of relevant quality scores. Highlights value gained from high-quality recent renovations.\\n# Input samples: {'RemodeledRecently': [1, 0, 1], 'OverallQual': [5, 8, 5], 'KitchenQual_Score': [3, 4, 3], 'ExterQual_Score': [3, 4, 3]}\\ndf['RemodelEffectQual'] = df['RemodeledRecently'] * (df['OverallQual'] + df['KitchenQual_Score'] + df['ExterQual_Score'])\\n\\n# (Average Room Size)\\n# Usefulness: Represents the average size of rooms above ground. Larger average room size can correlate with a more luxurious or spacious feel. Replaces 0 `TotRmsAbvGrd` to avoid division by zero.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]}\\ndf['AvgRoomSize'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1)\\n\\n# (Bathroom Density in Gross Living Area)\\n# Usefulness: Represents the density of bathrooms relative to the above-ground living area. High density might indicate a more luxurious or specialized layout.\\n# Input samples: {'TotalBath': [1.0, 2.5, 1.0], 'GrLivArea': [1144, 2520, 1520]}\\ndf['BathDensityGrLiv'] = df['TotalBath'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Log Transformed Masonry Veneer Area)\\n# Usefulness: Applies a log transform to `MasVnrArea` to normalize its distribution, as it often has a zero-inflated and skewed distribution.\\n# Input samples: {'MasVnrArea': [0.0, 0.0, 0.0, 167.0]}\\ndf['LogMasVnrArea'] = np.log1p(df['MasVnrArea'].fillna(0))\\n\\n# (Has Any Porch Area)\\n# Usefulness: Binary flag indicating the presence of *any* type of porch (open, enclosed, 3-season, screen).\\n# Input samples: {'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]}\\ndf['HasAnyPorch'] = ((df['OpenPorchSF'] > 0) | (df['EnclosedPorch'] > 0) | (df['3SsnPorch'] > 0) | (df['ScreenPorch'] > 0)).astype(int)\\n\\n# (Years Since House Built or Remodeled, Squared)\\n# Usefulness: Squaring `AgeAtSale` can capture non-linear depreciation patterns.\\n# Input samples: {'AgeAtSale': [48, 13, 77]}\\ndf['AgeAtSale_Sq'] = df['AgeAtSale'] ** 2\\n\\n# (Garage Size multiplied by its Overall Quality Score)\\n# Usefulness: Interaction between garage area and its total quality. A large, high-quality garage is likely more valuable.\\n# Input samples: {'GarageArea': [264, 796, 281], 'TotalGarageQualityScore': [6, 6, 6]}\\ndf['GarageArea_x_Qual'] = df['GarageArea'] * df['TotalGarageQualityScore']\\n\\n# (Lot Configuration indicates Corner or Cul-de-Sac)\\n# Usefulness: Flags whether the property is a corner lot or on a cul-de-sac. These often affect privacy, traffic, and lot utility.\\n# Input samples: {'LotConfig': ['Corner', 'Corner', 'Inside']}\\ndf['LotConfig_Special'] = df['LotConfig'].isin(['Corner', 'CulDSac']).astype(int)\\n\\n# (Average Basement Finished Type Score)\\n# Usefulness: Aggregated metric for the quality of finished basement areas.\\n# Input samples: {'BsmtFinType1_Score': [4, 6, 3], 'BsmtFinType2_Score': [1, 1, 1]}\\ndf['AvgBsmtFinTypeScore'] = (df['BsmtFinType1_Score'] + df['BsmtFinType2_Score']) / df[['BsmtFinType1_Score', 'BsmtFinType2_Score']].apply(lambda x: (x > 0).astype(int).sum() if (x > 0).astype(int).sum() > 0 else 1, axis=1)\\n\\n# (Total Square Footage Excluding Low Quality Finish)\\n# Usefulness: Excludes `LowQualFinSF` from `GrLivArea` to represent more \\\"desirable\\\" above-grade finished space, combined with total basement and garage areas.\\n# Input samples: {'GrLivArea': [1144, 2520, 1520], 'LowQualFinSF': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]}\\ndf['TotalSFExclLowQual'] = (df['GrLivArea'] - df['LowQualFinSF']) + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# (MSSubClass and HouseAge Interaction)\\n# Usefulness: Interaction between dwelling type ('MSSubClass') and 'HouseAge'. Captures type-specific aging effects on value.\\n# Input samples: {'MSSubClass': [20, 60, 50], 'HouseAge': [48, 13, 77]}\\ndf['MSSubClass_x_HouseAge'] = df['MSSubClass'] * df['HouseAge']\\n\\n# (Land Slope is Not Gentle)\\n# Usefulness: Binary flag if 'LandSlope' is 'Mod' (Moderate) or 'Sev' (Severe), impacting usability.\\n# Input samples: {'LandSlope': ['Gtl', 'Gtl', 'Gtl']}\\ndf['LandSlope_NotGtl'] = df['LandSlope'].isin(['Mod', 'Sev']).astype(int)\\n\\n# (Has Unfinished Basement Area)\\n# Usefulness: Binary flag indicating if there is any unfinished basement space.\\n# Input samples: {'BsmtUnfSF': [270, 326, 611]}\\ndf['HasUnfBsmt'] = (df['BsmtUnfSF'] > 0).astype(int)\\n\\n# (Foundation Type Interaction with Overall Quality)\\n# Usefulness: Interaction combining numerical score for 'Foundation' type with 'OverallQual'.\\n# Input samples: {'Foundation': ['CBlock', 'PConc', 'BrkTil'], 'OverallQual': [5, 8, 5]}\\ndf['Foundation_Type_Score'] = df['Foundation'].map(foundation_type_score_map).fillna(1)\\ndf['Foundation_x_OverallQual'] = df['Foundation_Type_Score'] * df['OverallQual']\\n\\n# (Alley Access Numeric Score)\\n# Usefulness: Ordinal numerical representation of 'Alley' access quality, where 'NA' (no alley) is 0.\\n# Input samples: {'Alley': [np.nan, np.nan, 'Pave']}\\ndf['Alley_Score'] = df['Alley'].map(alley_map).fillna(0)\\n\\n# (Heating Quality Interaction with Total Living Area)\\n# Usefulness: Interaction between `HeatingQC_Score` and `TotalLivAreaSF`.\\n# Input samples: {'HeatingQC_Score': [5, 5, 5], 'TotalLivAreaSF': [2008, 3858, 2313]}\\ndf['HeatingQual_x_LivArea'] = df['HeatingQC_Score'] * df['TotalLivAreaSF']\"}, {\"search_node\": {\"trial\": 22, \"parent_trial\": 13, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"score\": -0.11322638968093002}, {\"update\": \"import pandas as pd\\nimport numpy as np\\n\\n# Helper function for ordinal mapping of quality/condition ratings\\ndef map_quality_condition(series, mapping_dict):\\n    return series.map(mapping_dict).fillna(0).astype(int)\\n\\n# Mapping dictionary for 'Ex', 'Gd', 'TA', 'Fa', 'Po' values. 'NA' will be handled via fillna(0) for categorical columns.\\nqual_map_values = {\\n    'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1\\n}\\n\\n# (LivAreaPerRoom: Above grade living area per total rooms above grade)\\n# Usefulness: Provides insight into the spaciousness of individual rooms, indicating potential luxury or efficiency of floor plan, which can impact desirability and price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['LivAreaPerRoom'] = df['GrLivArea'] / df['TotRmsAbvGrd'].replace(0, 1) # Avoid division by zero, assuming 0 rooms above grade is not practical and impute to 1 for calculation stability.\\n\\n# (FinishedBsmtRatio: Proportion of finished basement area to total basement area)\\n# Usefulness: A higher ratio suggests more of the basement space is functional and finished for living, adding to the usable square footage and overall value of the property.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]\\ndf['FinishedBsmtRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / df['TotalBsmtSF'].replace(0, 1)\\ndf['FinishedBsmtRatio'] = df['FinishedBsmtRatio'].fillna(0) # Handles cases where TotalBsmtSF was originally 0 or NaN\\n\\n# (YearsSinceGarageBuilt: The age of the garage when the house was sold)\\n# Usefulness: Indicates the recency of the garage construction or remodel, which affects its condition and modern appeal, influencing buyer interest and value. NaNs are treated as 'no garage', making its contribution to age 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0]\\n# Fills NaN GarageYrBlt with YrSold for those entries that truly have no garage (and hence no age contribution), making YearsSinceGarageBuilt zero for them.\\ndf['YearsSinceGarageBuilt'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YrSold'])\\n\\n# (HasMasVnr: Binary indicator if the property has any masonry veneer)\\n# Usefulness: Masonry veneer (e.g., brick, stone) often enhances the home's exterior aesthetic, durability, and perceived value, indicating higher construction or finish quality.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0], 'MasVnrType': [np.nan, np.nan, np.nan]\\n# Fills NaNs in MasVnrType with 'None' and MasVnrArea with 0 before evaluation.\\ndf['MasVnrType_temp'] = df['MasVnrType'].fillna('None')\\ndf['MasVnrArea_temp'] = df['MasVnrArea'].fillna(0.0)\\ndf['HasMasVnr'] = ((df['MasVnrArea_temp'] > 0) | (df['MasVnrType_temp'] != 'None')).astype(int)\\ndf.drop(['MasVnrType_temp', 'MasVnrArea_temp'], axis=1, inplace=True)\\n\\n# (ExterQual_num: Numerical representation of Exterior Quality)\\n# Usefulness: Converts the qualitative rating of exterior material quality into an ordinal numerical scale, which directly informs models about the build quality impacting price.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_num'] = map_quality_condition(df['ExterQual'], qual_map_values)\\n\\n# (KitchenQual_num: Numerical representation of Kitchen Quality)\\n# Usefulness: Kitchen quality is a key selling point. This feature provides a numerical grade, making its significant impact on price accessible to regression algorithms.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_num'] = map_quality_condition(df['KitchenQual'], qual_map_values)\\n\\n# (BsmtQual_num: Numerical representation of Basement Quality)\\n# Usefulness: Ordinally scales the quality (height) of the basement, with 'NA' correctly implying no basement (score of 0), reflecting its contribution to livability and value.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_num'] = map_quality_condition(df['BsmtQual'], {**qual_map_values, 'NA': 0})\\n\\n# (HeatingQC_num: Numerical representation of Heating Quality and Condition)\\n# Usefulness: Translates the categorical heating system quality into an ordinal score, directly feeding into model evaluation of HVAC system efficiency and condition.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_num'] = map_quality_condition(df['HeatingQC'], qual_map_values)\\n\\n# (GarageQual_num: Numerical representation of Garage Quality)\\n# Usefulness: Provides a numerical grade for garage quality, where 'NA' (no garage) maps to 0, offering insight into its contribution to the overall property value.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_num'] = map_quality_condition(df['GarageQual'], {**qual_map_values, 'NA': 0})\\n\\n# (FireplaceQu_num: Numerical representation of Fireplace Quality)\\n# Usefulness: Ranks fireplace quality numerically, with 'NA' (no fireplace) indicating absence, to capture its impact as a desirable amenity influencing sale price.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', np.nan]\\ndf['FireplaceQu_num'] = map_quality_condition(df['FireplaceQu'], {**qual_map_values, 'NA': 0})\\n\\n# (TotalMajorQuality: Aggregate score of several key quality indicators)\\n# Usefulness: A composite score that sums the numerical grades of critical structural and aesthetic components (exterior, kitchen, basement, heating, garage, fireplace, and overall quality), offering a holistic measure of the property's general standing and finish quality.\\n# Input samples: 'ExterQual_num': [3, 4, 3], 'KitchenQual_num': [3, 4, 3], 'BsmtQual_num': [3, 4, 3], 'HeatingQC_num': [5, 5, 5], 'GarageQual_num': [3, 3, 3], 'FireplaceQu_num': [3, 3, 0], 'OverallQual': [5, 8, 5]\\ndf['TotalMajorQuality'] = df['ExterQual_num'] + df['KitchenQual_num'] + df['BsmtQual_num'] + \\\\\\n                          df['HeatingQC_num'] + df['GarageQual_num'] + df['FireplaceQu_num'] + df['OverallQual']\", \"score\": -0.11630963203173136}], \"predefined_state\": null, \"parent_score\": -0.11630963203173136, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import pandas as pd\\nimport numpy as np\\n\\n# TotalSqFootage: Sum of above grade living area, total basement area, and garage area.\\n# Usefulness: Provides a comprehensive measure of all enclosed, functional space within the property, which is highly correlated with price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793], 'GarageArea': [264, 796, 281]\\ndf['TotalSqFootage'] = df['GrLivArea'] + df['TotalBsmtSF'] + df['GarageArea']\\n\\n# YearsSinceBuilt: The age of the house when it was sold.\\n# Usefulness: Newer houses generally have modern features, fewer maintenance needs, and thus higher market value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceBuilt'] = df['YrSold'] - df['YearBuilt']\\n\\n# YearsSinceRemodel: The number of years passed since the last remodel or original construction if no remodel occurred.\\n# Usefulness: Homes that have been recently remodeled or are relatively new since their last update tend to fetch higher prices.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# TotalBathrooms: The aggregate number of full and half bathrooms, where half baths are weighted as 0.5.\\n# Usefulness: More bathrooms increase convenience and are a significant factor in a home's perceived value and desirability.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# OverallQualityCondition: A composite score indicating the overall material/finish and general condition of the house.\\n# Usefulness: Represents a combined measure of the property's build quality and upkeep, strongly correlating with sale price.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallQualityCondition'] = df['OverallQual'] * df['OverallCond']\\n\\n# TotalPorchArea: The cumulative square footage of all types of porch and deck areas.\\n# Usefulness: Outdoor living spaces contribute to the functionality and aesthetic appeal of a home, adding to its overall value.\\n# Input samples: 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# HasPool: A binary indicator (1 if the property has a pool, 0 otherwise).\\n# Usefulness: Pools are often considered luxury amenities and can significantly enhance a property's value, especially in specific housing markets.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# HasFireplace: A binary indicator (1 if the property has one or more fireplaces, 0 otherwise).\\n# Usefulness: Fireplaces add to the comfort and aesthetic appeal of a home, influencing buyer interest and perceived value.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\", \"import pandas as pd\\nimport numpy as np\\n\\n# Helper function for ordinal mapping of quality/condition ratings\\ndef map_quality_condition(series, mapping_dict):\\n    # For columns where NA means 'no feature', we map 'NA' to 0 (or the lowest category)\\n    # The fillna(0) ensures that any unexpected NaNs after explicit NA mapping are also set to 0.\\n    return series.map(mapping_dict).fillna(0).astype(int)\\n\\n# Mapping dictionary for 'Ex', 'Gd', 'TA', 'Fa', 'Po' values and also specific 'NA' cases.\\nqual_map_values = {\\n    'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0\\n}\\n\\n# Mapping dictionary for BsmtExposure\\nbsmt_exposure_map = {\\n    'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0\\n}\\n\\n# Mapping dictionary for BsmtFinType1/2\\nbsmt_fin_type_map = {\\n    'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0\\n}\\n\\n# (LivAreaPerSqFootLot: Ratio of above ground living area to lot area)\\n# Usefulness: Indicates how efficiently the lot area is used for living space. Can signify higher density, or inversely, larger grounds for a given living area, both impacting value depending on context.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaPerSqFootLot'] = df['GrLivArea'] / df['LotArea'].replace(0, 1) # Avoid division by zero\\n\\n# (Remodeled_YN: Binary flag if the house has been remodeled at some point after original construction)\\n# Usefulness: Remodeling usually implies updates and improvements, which tend to increase the desirability and value of a home.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled_YN'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (HasBasement: Binary flag indicating the presence of a basement)\\n# Usefulness: Basements provide additional space for storage, utilities, or potential finishing, adding value. Explicitly captures cases where 'TotalBsmtSF' is zero.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Foundation_PConc_YN: Binary flag for houses with Poured Concrete foundations)\\n# Usefulness: Poured Concrete foundations are typically found in newer, more modern constructions and are often considered superior for durability, correlating with higher value.\\n# Input samples: 'Foundation': ['CBlock', 'PConc', 'BrkTil']\\ndf['Foundation_PConc_YN'] = (df['Foundation'] == 'PConc').astype(int)\\n\\n# (IsNewerDwelling: Binary flag for properties built or significantly remodeled after the year 2000)\\n# Usefulness: Differentiates more modern homes (often with contemporary designs and efficiencies) from older ones, likely fetching higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['IsNewerDwelling'] = ((df['YearBuilt'] >= 2000) | (df['YearRemodAdd'] >= 2000)).astype(int)\\n\\n# (BsmtExposure_num: Ordinal representation of basement exposure level)\\n# Usefulness: Good basement exposure can allow for more natural light and make basement spaces more attractive and valuable for living, especially walk-out basements.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_num'] = map_quality_condition(df['BsmtExposure'], bsmt_exposure_map)\\n\\n# (BsmtFinType1_num: Ordinal representation of Type 1 finished basement quality)\\n# Usefulness: Provides a numerical rating for the primary finished area in the basement, indicating its utility and quality, which directly impacts the property's overall livable area value.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_num'] = map_quality_condition(df['BsmtFinType1'], bsmt_fin_type_map)\\n\\n# (TotalFlrSF: Total floor area combining 1st and 2nd floor, excluding low quality finished SF)\\n# Usefulness: Represents the primary above-ground usable living space more directly than just GrLivArea if the low quality finished area is significant.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'LowQualFinSF': [0, 0, 0]\\ndf['TotalFlrSF'] = df['1stFlrSF'] + df['2ndFlrSF'] - df['LowQualFinSF']\\n\"]}, \"score\": -0.11475181630236994, \"memory_update\": \"import pandas as pd\\nimport numpy as np\\n\\n# Helper function for ordinal mapping of quality/condition ratings\\ndef map_quality_condition(series, mapping_dict):\\n    # For columns where NA means 'no feature', we map 'NA' to 0 (or the lowest category)\\n    # The fillna(0) ensures that any unexpected NaNs after explicit NA mapping are also set to 0.\\n    return series.map(mapping_dict).fillna(0).astype(int)\\n\\n# Mapping dictionary for 'Ex', 'Gd', 'TA', 'Fa', 'Po' values and also specific 'NA' cases.\\nqual_map_values = {\\n    'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0\\n}\\n\\n# Mapping dictionary for BsmtExposure\\nbsmt_exposure_map = {\\n    'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0\\n}\\n\\n# Mapping dictionary for BsmtFinType1/2\\nbsmt_fin_type_map = {\\n    'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0\\n}\\n\\n# (LivAreaPerSqFootLot: Ratio of above ground living area to lot area)\\n# Usefulness: Indicates how efficiently the lot area is used for living space. Can signify higher density, or inversely, larger grounds for a given living area, both impacting value depending on context.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaPerSqFootLot'] = df['GrLivArea'] / df['LotArea'].replace(0, 1) # Avoid division by zero\\n\\n# (Remodeled_YN: Binary flag if the house has been remodeled at some point after original construction)\\n# Usefulness: Remodeling usually implies updates and improvements, which tend to increase the desirability and value of a home.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled_YN'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (HasBasement: Binary flag indicating the presence of a basement)\\n# Usefulness: Basements provide additional space for storage, utilities, or potential finishing, adding value. Explicitly captures cases where 'TotalBsmtSF' is zero.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Foundation_PConc_YN: Binary flag for houses with Poured Concrete foundations)\\n# Usefulness: Poured Concrete foundations are typically found in newer, more modern constructions and are often considered superior for durability, correlating with higher value.\\n# Input samples: 'Foundation': ['CBlock', 'PConc', 'BrkTil']\\ndf['Foundation_PConc_YN'] = (df['Foundation'] == 'PConc').astype(int)\\n\\n# (IsNewerDwelling: Binary flag for properties built or significantly remodeled after the year 2000)\\n# Usefulness: Differentiates more modern homes (often with contemporary designs and efficiencies) from older ones, likely fetching higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['IsNewerDwelling'] = ((df['YearBuilt'] >= 2000) | (df['YearRemodAdd'] >= 2000)).astype(int)\\n\\n# (BsmtExposure_num: Ordinal representation of basement exposure level)\\n# Usefulness: Good basement exposure can allow for more natural light and make basement spaces more attractive and valuable for living, especially walk-out basements.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_num'] = map_quality_condition(df['BsmtExposure'], bsmt_exposure_map)\\n\\n# (BsmtFinType1_num: Ordinal representation of Type 1 finished basement quality)\\n# Usefulness: Provides a numerical rating for the primary finished area in the basement, indicating its utility and quality, which directly impacts the property's overall livable area value.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_num'] = map_quality_condition(df['BsmtFinType1'], bsmt_fin_type_map)\\n\\n# (TotalFlrSF: Total floor area combining 1st and 2nd floor, excluding low quality finished SF)\\n# Usefulness: Represents the primary above-ground usable living space more directly than just GrLivArea if the low quality finished area is significant.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'LowQualFinSF': [0, 0, 0]\\ndf['TotalFlrSF'] = df['1stFlrSF'] + df['2ndFlrSF'] - df['LowQualFinSF']\\n\"}, {\"search_node\": {\"trial\": 23, \"parent_trial\": 16, \"memory\": [{\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"\", \"score\": -0.11561350952648}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# (TotalSF)\\n# Usefulness: Represents the combined total finished square footage of the above-grade living area and the basement, which is a major determinant of house value.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Represents the total number of bathrooms, including full and half, and distinguishing between above-grade and basement bathrooms by assigning half bathrooms a weight of 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Indicates how old the house was at the time of sale. Older houses might command different prices or require more maintenance.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Indicates the time elapsed since the last major remodel or addition. More recent remodels generally increase house value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (HasBsmt)\\n# Usefulness: A binary indicator if the property has a basement, which adds significant utility and storage space.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (HasFireplace)\\n# Usefulness: A binary indicator if the property has a fireplace, often considered a desirable amenity.\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (HasGarage)\\n# Usefulness: A binary indicator if the property has a garage, which adds value for parking and storage.\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (HasPool)\\n# Usefulness: A binary indicator if the property has a pool, a high-value amenity though less common.\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (TotalPorchArea)\\n# Usefulness: Combines all types of outdoor porch and deck areas, representing additional living or leisure space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Remodeled)\\n# Usefulness: A binary indicator if the house has undergone remodeling since its original construction, which often correlates with improved condition and higher value.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (GarageAge)\\n# Usefulness: The age of the garage at the time of sale. An older garage might be in poorer condition or of outdated construction. NaN values for GarageYrBlt are imputed with the House Age (if there is a garage), else 0 if no garage, and the AgeAtSale used for comparison. If GarageYrBlt is NaN and there is a garage (GarageCars>0), use YearBuilt, else use 0. If GarageCars is 0, set to 0.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0], 'GarageCars': [1, 3, 1]\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(df['YearBuilt'])\\ndf.loc[df['GarageCars'] == 0, 'GarageAge'] = 0 # No garage means age 0\\n\\n# Define mappings for ordinal categorical features\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\nbsmt_quality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nexposure_mapping = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\nbsmt_fin_type_mapping = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no basement, treated as 0 score\\ngarage_finish_mapping = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # 'NA' for no garage, treated as 0 score\\n\\n# (ExterQual_Score)\\n# Usefulness: Converts the ordinal categorical exterior quality into a numerical scale, allowing it to be used directly in regression models. 'NA' means no information/zero quality.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_mapping).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Converts the ordinal categorical exterior condition into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_mapping).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Converts the ordinal categorical kitchen quality into a numerical scale. 'NA' means no information/zero quality.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_mapping).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Converts the ordinal categorical basement height quality into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Converts the ordinal categorical basement condition into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Converts the ordinal categorical heating quality into a numerical scale.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_mapping).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Converts the ordinal categorical fireplace quality into a numerical scale, with 'NA' mapping to 0 for no fireplace.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageQual_Score)\\n# Usefulness: Converts the ordinal categorical garage quality into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Score'] = df['GarageQual'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (GarageCond_Score)\\n# Usefulness: Converts the ordinal categorical garage condition into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Score'] = df['GarageCond'].map(bsmt_quality_mapping).fillna(0)\\n\\n# (PoolQC_Score)\\n# Usefulness: Converts the ordinal categorical pool quality into a numerical scale. Given 'PoolQC' has NaN-freq [100%], if the column exists, it will correctly map NaNs to 0. If it doesn't exist, this statement should implicitly handle it if the environment is strict about non-existent columns. As it failed before, explicitly setting a default is safer for error handling.\\n# Input samples: 'PoolQC': [nan, nan, nan]\\n# Corrected handling: Since 'PoolQC' has 100% NaN frequency and caused KeyError, it will be skipped from being explicitly mapped to avoid the error. This effectively means 'PoolQC_Score' remains at a default of 0 if the column truly isn't available, or will effectively be 0 for all rows if it does exist and only contains NaNs.\\n# Assuming the intention for a 100% NaN column is for it to effectively contribute zero, this omission achieves the same outcome while resolving the error.\\nif 'PoolQC' in df.columns: # Check explicitly for column existence\\n    df['PoolQC_Score'] = df['PoolQC'].map(bsmt_quality_mapping).fillna(0)\\nelse:\\n    df['PoolQC_Score'] = 0 # Default to 0 if the column is entirely absent or contains no information\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Converts the ordinal categorical basement exposure into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_mapping).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 1 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (BsmtFinType2_Score)\\n# Usefulness: Converts the ordinal categorical basement finished area type 2 into a numerical scale, with 'NA' mapping to 0 for no basement.\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_Score'] = df['BsmtFinType2'].map(bsmt_fin_type_mapping).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Converts the ordinal categorical garage interior finish into a numerical scale, with 'NA' mapping to 0 for no garage.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_mapping).fillna(0)\\n\\n# (Neighborhood_Quality_Interaction)\\n# Usefulness: Combines the house's overall quality rating with its neighborhood, assuming some neighborhoods inherently have higher quality expectations. This captures interaction effects between two important factors.\\n# Input samples: 'OverallQual': [5, 8, 5], 'Neighborhood': ['Sawyer', 'NoRidge', 'SWISU']\\nneighborhood_quality_mapping = df.groupby('Neighborhood')['OverallQual'].transform('mean')\\ndf['Neighborhood_Quality_Interaction'] = df['OverallQual'] * neighborhood_quality_mapping\\n\\n# (LotSizeProduct)\\n# Usefulness: Combines the linear feet of street connection with the total lot area, which might indicate more prominent or accessible properties with larger plots.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0], 'LotArea': [10000, 14541, 4500]\\ndf['LotSizeProduct'] = df['LotFrontage'].fillna(0) * df['LotArea']\\n\\n# (TotalFlrSF)\\n# Usefulness: Represents the total square footage across all floors (1st, 2nd, and low quality finished), offering a comprehensive measure of usable living space above ground.\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'LowQualFinSF': [0, 0, 0]\\ndf['TotalFlrSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['LowQualFinSF']\\n\\n# (ExteriorQualCond)\\n# Usefulness: Combines the quality and condition of the exterior materials, offering a holistic view of the outside's state, which impacts curb appeal and maintenance costs.\\n# Input samples: 'ExterQual_Score': [3, 4, 3], 'ExterCond_Score': [3, 4, 3]\\ndf['ExteriorQualCond'] = df['ExterQual_Score'] + df['ExterCond_Score']\\n\\n# (HasMasVnr)\\n# Usefulness: A binary indicator if the house has masonry veneer, which can be an aesthetic upgrade and contribute to a higher appraisal value.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Quality_Overall_Ratio)\\n# Usefulness: Divides the general overall quality by the overall condition, highlighting houses where quality might be higher than current condition (implying potential for restoration) or vice-versa.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Quality_Overall_Ratio'] = df['OverallQual'] / df['OverallCond']\\n\\n# (AvgRoomSF)\\n# Usefulness: Calculates the average square footage per room above grade (excluding bathrooms). This gives a sense of room spaciousness.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AvgRoomSF'] = df['GrLivArea'] / df['TotRmsAbvGrd']\\n# Replace infinite values (if TotRmsAbvGrd is 0) with 0 for meaningful representation in a regression context.\\ndf['AvgRoomSF'] = df['AvgRoomSF'].replace([np.inf, -np.inf], 0).fillna(0)\\n\\n# (YearBuiltCategory)\\n# Usefulness: Categorizes houses into broader age groups (e.g., 'New', 'Recent', 'Old', 'VeryOld') which might capture generational architectural styles or construction standards, and simplify a potentially non-linear relationship.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932]\\ndf['YearBuiltCategory'] = pd.cut(df['YearBuilt'], bins=[0, 1940, 1970, 1995, 2010, np.inf], labels=['Pre1940', '1940-1969', '1970-1994', '1995-2009', 'Post2010'])\\n\\n# (BedroomBathroomRatio)\\n# Usefulness: Indicates the proportion of bedrooms to bathrooms. This might be important for family homes or larger properties where an equal balance or specific ratio is preferred.\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotalBathrooms': [2.0, 3.5, 1.0]\\ndf['BedroomBathroomRatio'] = df['BedroomAbvGr'] / df['TotalBathrooms']\\ndf['BedroomBathroomRatio'] = df['BedroomBathroomRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where TotalBathrooms might be 0\\n\\n# (GarageDensity)\\n# Usefulness: Represents the car capacity per square foot of garage area, which can indicate if a garage is more compact or spacious per vehicle.\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageArea': [264, 796, 281]\\ndf['GarageDensity'] = df['GarageCars'] / df['GarageArea']\\ndf['GarageDensity'] = df['GarageDensity'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GarageArea might be 0\\n\\n# (PorchToGrLivRatio)\\n# Usefulness: Relates the total porch/deck area to the above-grade living area, providing insight into the relative outdoor living space compared to indoor living space.\\n# Input samples: 'TotalPorchArea': [165, 264, 56], 'GrLivArea': [1144, 2520, 1520]\\ndf['PorchToGrLivRatio'] = df['TotalPorchArea'] / df['GrLivArea']\\ndf['PorchToGrLivRatio'] = df['PorchToGrLivRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (FireplacesPerGrLivArea)\\n# Usefulness: The ratio of fireplaces to the living area. This can indicate luxury or architectural features for the given size of the house.\\n# Input samples: 'Fireplaces': [1, 1, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['FireplacesPerGrLivArea'] = df['Fireplaces'] / df['GrLivArea']\\ndf['FireplacesPerGrLivArea'] = df['FireplacesPerGrLivArea'].replace([np.inf, -np.inf], 0).fillna(0) # Handle cases where GrLivArea might be 0\\n\\n# (IsNewBuild)\\n# Usefulness: A binary indicator for houses sold in the same year they were built, often commanding premium prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YrSold': [2009, 2006, 2009]\\ndf['IsNewBuild'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: A binary indicator for properties having a second floor. This greatly impacts the house's style, footprint, and potentially value.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (TotalSquareFootageRank)\\n# Usefulness: Ranks houses based on their total square footage. This helps capture non-linear effects of size by categorizing it relative to other houses.\\n# Input samples: 'TotalSF': [864, 1338, 793]\\ndf['TotalSquareFootageRank'] = df['TotalSF'].rank(method='dense')\\n\\n# (BsmtFinSF1Ratio)\\n# Usefulness: The ratio of finished basement area Type 1 to the total basement area. Indicates how much of the basement is dedicated to higher quality finished living space.\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1'] / df['TotalBsmtSF']\\ndf['BsmtFinSF1Ratio'] = df['BsmtFinSF1Ratio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\\n# (LivAreaToLotAreaRatio)\\n# Usefulness: Represents the proportion of above-grade living area to the total lot area, which can indicate building density on the plot or remaining yard space.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\ndf['LivAreaToLotAreaRatio'] = df['LivAreaToLotAreaRatio'].replace([np.inf, -np.inf], 0).fillna(0) # Handle division by zero\\n\", \"score\": -0.13104060995676203}, {\"update\": \"import numpy as np\\nimport pandas as pd\\n\\n# (Impute_LotFrontage_NaNs)\\n# Usefulness: Replaces NaN values in 'LotFrontage' with 0. Given that LotFrontage can sometimes mean 'no street connection' or be truly missing, treating NaN as 0 ensures numerical operations proceed without errors. Alternative: median imputation might be more accurate but could interact negatively with `LotArea` features if some missing are truly 0 frontage. Using 0 for this context keeps it consistent.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0]\\ndf['LotFrontage'] = df['LotFrontage'].fillna(0)\\n\\n# (Impute_MasVnrArea_NaNs)\\n# Usefulness: Replaces NaN values in 'MasVnrArea' with 0. The description of 'MasVnrType' includes 'None', which would naturally correspond to 0 'MasVnrArea'. This aligns NaNs with the 'None' type, indicating no masonry veneer.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea'] = df['MasVnrArea'].fillna(0)\\n\\n# (TotalSF)\\n# Usefulness: Sums the total living area (above grade) and total basement area to represent the overall enclosed habitable space, a primary driver of house price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Combines all bathroom counts (full and half, above and below grade) into a single, comprehensive numerical feature. Half baths are weighted at 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Calculates the age of the house at the time of sale. Older properties might have lower value or higher renovation costs, while new properties command a premium.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Computes the number of years since the last remodel. Recent remodels often indicate better condition and higher value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (TotalOutdoorSF)\\n# Usefulness: Aggregates all outdoor areas (wood deck, open porch, enclosed porch, 3-season porch, screen porch) into a single feature, representing total external living/recreational space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (HasMasVnr)\\n# Usefulness: Binary flag indicating if the house has masonry veneer. This can signify an aesthetic upgrade.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: Binary flag for the presence of a second floor, which impacts dwelling style and total usable area distribution.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (HasAlleyAccess)\\n# Usefulness: Binary flag indicating whether the property has alley access. This could be relevant for property utility or desirability. NaN and 'NA' are treated as no access.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or str(x) == 'NA' else 1)\\n\\n# (Remodeled)\\n# Usefulness: Binary flag indicating if the house has been remodeled at some point (YearBuilt != YearRemodAdd). Remodeled homes often fetch higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n\\n# Ordinal quality mappings\\nquality_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0} # General quality (ExterQual, HeatingQC, KitchenQual)\\nbsmt_gar_fp_pool_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # Quality for Bsmt, Garage, Fireplace, Pool where 'NA' means no item\\nexposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # Basement exposure\\nbsmt_fin_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Basement finish type\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Garage finish\\n\\n\\n# (ExterQual_Score)\\n# Usefulness: Numerical representation of the exterior material quality, important for curb appeal and durability.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Numerical representation of the exterior material condition.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Numerical score for basement height/quality, mapping 'NA' (no basement) to 0.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Numerical score for basement general condition, mapping 'NA' to 0.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Numerical score for basement walkout or garden level walls, mapping 'NA' to 0.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_map).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Numerical score for rating of basement finished area type 1, mapping 'NA' to 0.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_map).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Numerical score for heating quality and condition, crucial for comfort and energy efficiency.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Numerical score for kitchen quality, a significant factor in home desirability and value.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Numerical score for fireplace quality, mapping 'NA' (no fireplace) to 0.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Numerical score for interior finish of the garage, mapping 'NA' (no garage) to 0.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log_LotArea)\\n# Usefulness: Log-transformation often normalizes skewed distributions like 'LotArea', making relationships more linear and improving model performance. Using np.log1p handles zero values gracefully.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log_GrLivArea)\\n# Usefulness: Log-transformation of the above-grade living area to address its potentially skewed distribution and improve linearity.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Log_TotalBsmtSF)\\n# Usefulness: Log-transformation of total basement square footage, handling zero values with np.log1p, useful for skewed distributions.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['Log_TotalBsmtSF'] = np.log1p(df['TotalBsmtSF'])\\n\", \"score\": -0.11292848029975126}], \"predefined_state\": null, \"parent_score\": -0.11292848029975126, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"import numpy as np\\nimport pandas as pd\\n\\n# (Impute_LotFrontage_NaNs)\\n# Usefulness: Replaces NaN values in 'LotFrontage' with 0. Given that LotFrontage can sometimes mean 'no street connection' or be truly missing, treating NaN as 0 ensures numerical operations proceed without errors. Alternative: median imputation might be more accurate but could interact negatively with `LotArea` features if some missing are truly 0 frontage. Using 0 for this context keeps it consistent.\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0]\\ndf['LotFrontage'] = df['LotFrontage'].fillna(0)\\n\\n# (Impute_MasVnrArea_NaNs)\\n# Usefulness: Replaces NaN values in 'MasVnrArea' with 0. The description of 'MasVnrType' includes 'None', which would naturally correspond to 0 'MasVnrArea'. This aligns NaNs with the 'None' type, indicating no masonry veneer.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea'] = df['MasVnrArea'].fillna(0)\\n\\n# (TotalSF)\\n# Usefulness: Sums the total living area (above grade) and total basement area to represent the overall enclosed habitable space, a primary driver of house price.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalBathrooms)\\n# Usefulness: Combines all bathroom counts (full and half, above and below grade) into a single, comprehensive numerical feature. Half baths are weighted at 0.5.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: Calculates the age of the house at the time of sale. Older properties might have lower value or higher renovation costs, while new properties command a premium.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: Computes the number of years since the last remodel. Recent remodels often indicate better condition and higher value.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (TotalOutdoorSF)\\n# Usefulness: Aggregates all outdoor areas (wood deck, open porch, enclosed porch, 3-season porch, screen porch) into a single feature, representing total external living/recreational space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (HasMasVnr)\\n# Usefulness: Binary flag indicating if the house has masonry veneer. This can signify an aesthetic upgrade.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea'] > 0).astype(int)\\n\\n# (Has2ndFloor)\\n# Usefulness: Binary flag for the presence of a second floor, which impacts dwelling style and total usable area distribution.\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (HasAlleyAccess)\\n# Usefulness: Binary flag indicating whether the property has alley access. This could be relevant for property utility or desirability. NaN and 'NA' are treated as no access.\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['HasAlleyAccess'] = df['Alley'].apply(lambda x: 0 if pd.isna(x) or str(x) == 'NA' else 1)\\n\\n# (Remodeled)\\n# Usefulness: Binary flag indicating if the house has been remodeled at some point (YearBuilt != YearRemodAdd). Remodeled homes often fetch higher prices.\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['Remodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n\\n# Ordinal quality mappings\\nquality_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0} # General quality (ExterQual, HeatingQC, KitchenQual)\\nbsmt_gar_fp_pool_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0} # Quality for Bsmt, Garage, Fireplace, Pool where 'NA' means no item\\nexposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1, 'NA': 0, np.nan: 0} # Basement exposure\\nbsmt_fin_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Basement finish type\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1, 'NA': 0, np.nan: 0} # Garage finish\\n\\n\\n# (ExterQual_Score)\\n# Usefulness: Numerical representation of the exterior material quality, important for curb appeal and durability.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_map).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Numerical representation of the exterior material condition.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_map).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Numerical score for basement height/quality, mapping 'NA' (no basement) to 0.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Numerical score for basement general condition, mapping 'NA' to 0.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (BsmtExposure_Score)\\n# Usefulness: Numerical score for basement walkout or garden level walls, mapping 'NA' to 0.\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No']\\ndf['BsmtExposure_Score'] = df['BsmtExposure'].map(exposure_map).fillna(0)\\n\\n# (BsmtFinType1_Score)\\n# Usefulness: Numerical score for rating of basement finished area type 1, mapping 'NA' to 0.\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec']\\ndf['BsmtFinType1_Score'] = df['BsmtFinType1'].map(bsmt_fin_map).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Numerical score for heating quality and condition, crucial for comfort and energy efficiency.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_map).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Numerical score for kitchen quality, a significant factor in home desirability and value.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_map).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Numerical score for fireplace quality, mapping 'NA' (no fireplace) to 0.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(bsmt_gar_fp_pool_map).fillna(0)\\n\\n# (GarageFinish_Score)\\n# Usefulness: Numerical score for interior finish of the garage, mapping 'NA' (no garage) to 0.\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf']\\ndf['GarageFinish_Score'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log_LotArea)\\n# Usefulness: Log-transformation often normalizes skewed distributions like 'LotArea', making relationships more linear and improving model performance. Using np.log1p handles zero values gracefully.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# (Log_GrLivArea)\\n# Usefulness: Log-transformation of the above-grade living area to address its potentially skewed distribution and improve linearity.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Log_TotalBsmtSF)\\n# Usefulness: Log-transformation of total basement square footage, handling zero values with np.log1p, useful for skewed distributions.\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['Log_TotalBsmtSF'] = np.log1p(df['TotalBsmtSF'])\\n\", \"import numpy as np\\nimport pandas as pd\\n\\n# Define mappings for ordinal categorical features\\n# These mappings are fundamental and will be re-defined in each block for robustness against state resets.\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# This mapping covers 'NA' meaning 'no such feature' (e.g., No Basement, No Fireplace, No Garage)\\ngeneral_na_zero_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0}\\n\\n# (Impute MasVnrArea NaNs)\\n# Usefulness: Addresses missing 'MasVnrArea' values by assuming 0, consistent with properties having 'None' for 'MasVnrType'.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea'] = df['MasVnrArea'].fillna(0)\\n\\n# Regenerate fundamental individual quality/condition scores that are commonly used as building blocks.\\n# These steps are re-run here assuming 'df' resets to a base state, explaining previous KeyError issues.\\n\\n# (ExterQual_Score)\\n# Usefulness: Converts the ordinal exterior material quality into a numerical score.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_mapping).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Converts the ordinal exterior material condition into a numerical score.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_mapping).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Converts basement height/quality to a numerical score, with 'NA' indicating no basement mapped to 0.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(general_na_zero_mapping).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Converts basement condition to a numerical score, with 'NA' mapped to 0.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(general_na_zero_mapping).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Converts kitchen quality to a numerical score, highly indicative of house appeal.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_mapping).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Converts heating quality and condition to a numerical score.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_mapping).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Converts fireplace quality to a numerical score, with 'NA' (no fireplace) mapped to 0.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(general_na_zero_mapping).fillna(0)\\n\\n# (GarageQual_Score)\\n# Usefulness: Converts garage quality to a numerical score, with 'NA' (no garage) mapped to 0. Addresses previous KeyError.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Score'] = df['GarageQual'].map(general_na_zero_mapping).fillna(0)\\n\\n# (GarageCond_Score)\\n# Usefulness: Converts garage condition to a numerical score, with 'NA' mapped to 0.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Score'] = df['GarageCond'].map(general_na_zero_mapping).fillna(0)\\n\\n\\n# Regenerate key aggregate and log-transformed numerical features as necessary prerequisites.\\n\\n# (TotalSF)\\n# Usefulness: Represents the combined total finished square footage of above-grade living area and basement, a primary value driver.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalOutdoorSF)\\n# Usefulness: Aggregates all outdoor areas (decks, porches) into a single metric for outdoor living space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Log_GrLivArea)\\n# Usefulness: Applies a log1p transformation to 'GrLivArea' to reduce skewness and improve linearity in models.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Log_LotArea)\\n# Usefulness: Applies a log1p transformation to 'LotArea' for similar reasons as 'Log_GrLivArea'.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# Introduce new value-adding features and re-introduce key features that were part of prior logical groups but might have been discarded.\\n\\n# (TotalQual_Score_Combined)\\n# Usefulness: A composite score summing multiple quality assessments, providing a holistic quality metric.\\n# Input samples: 'ExterQual_Score': [3, 4, 3], 'KitchenQual_Score': [3, 4, 3], 'HeatingQC_Score': [5, 5, 5], 'BsmtQual_Score': [3, 4, 3], 'FireplaceQu_Score': [3, 3, 0], 'GarageQual_Score': [3, 3, 3]\\ndf['TotalQual_Score_Combined'] = df['ExterQual_Score'] + df['KitchenQual_Score'] + df['HeatingQC_Score'] + df['BsmtQual_Score'] + df['FireplaceQu_Score'] + df['GarageQual_Score']\\n\\n# (TotalCond_Score_Combined)\\n# Usefulness: A composite score summing multiple condition assessments, providing a holistic condition metric.\\n# Input samples: 'ExterCond_Score': [3, 4, 3], 'BsmtCond_Score': [3, 4, 3], 'GarageCond_Score': [3, 3, 3], 'OverallCond': [6, 7, 5]\\ndf['TotalCond_Score_Combined'] = df['ExterCond_Score'] + df['BsmtCond_Score'] + df['GarageCond_Score'] + df['OverallCond']\\n\\n# (PorchToLotRatio)\\n# Usefulness: The ratio of total outdoor porch/deck area to the total lot area, indicating density of outdoor features.\\n# Input samples: 'TotalOutdoorSF': [165, 264, 56], 'LotArea': [10000, 14541, 4500]\\ndf['PorchToLotRatio'] = df['TotalOutdoorSF'] / df['LotArea'].replace(0, np.nan)\\ndf['PorchToLotRatio'] = df['PorchToLotRatio'].fillna(0)\\n\\n# (HasOverallQual8OrHigher)\\n# Usefulness: Binary indicator for properties with a high 'OverallQual', segmenting top-tier homes.\\n# Input samples: 'OverallQual': [5, 8, 5]\\ndf['HasOverallQual8OrHigher'] = (df['OverallQual'] >= 8).astype(int)\\n\\n# (HasModernRemodel)\\n# Usefulness: Binary indicator if the house was remodeled in or after the year 2000, signaling a modern update.\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YrSold': [2009, 2006, 2009]\\ndf['HasModernRemodel'] = (df['YearRemodAdd'] >= 2000).astype(int)\\n\\n# Re-incorporate other important core derived features.\\n\\n# (TotalBathrooms)\\n# Usefulness: Consolidates all bathroom types (full/half, above/below grade) into a single count.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: The age of the property at the time of sale.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: The years passed since the last remodeling event.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Room_Density_Above_Grade)\\n# Usefulness: The ratio of rooms to the logarithm of above-grade living area, indicating room spaciousness relative to total area.\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'Log_GrLivArea': [7.043, 7.832, 7.326]\\ndf['Room_Density_Above_Grade'] = df['TotRmsAbvGrd'] / df['Log_GrLivArea']\\ndf['Room_Density_Above_Grade'] = df['Room_Density_Above_Grade'].replace([np.inf, -np.inf], 0).fillna(0)\\n\\n# (Overall_Quality_Condition)\\n# Usefulness: An interaction feature multiplying overall quality and condition, capturing their synergistic effect.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Overall_Quality_Condition'] = df['OverallQual'] * df['OverallCond']\"]}, \"score\": -0.11465645947657063, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# Define mappings for ordinal categorical features\\n# These mappings are fundamental and will be re-defined in each block for robustness against state resets.\\nquality_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, np.nan: 0}\\n# This mapping covers 'NA' meaning 'no such feature' (e.g., No Basement, No Fireplace, No Garage)\\ngeneral_na_zero_mapping = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1, 'NA': 0, np.nan: 0}\\n\\n# (Impute MasVnrArea NaNs)\\n# Usefulness: Addresses missing 'MasVnrArea' values by assuming 0, consistent with properties having 'None' for 'MasVnrType'.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['MasVnrArea'] = df['MasVnrArea'].fillna(0)\\n\\n# Regenerate fundamental individual quality/condition scores that are commonly used as building blocks.\\n# These steps are re-run here assuming 'df' resets to a base state, explaining previous KeyError issues.\\n\\n# (ExterQual_Score)\\n# Usefulness: Converts the ordinal exterior material quality into a numerical score.\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA']\\ndf['ExterQual_Score'] = df['ExterQual'].map(quality_mapping).fillna(0)\\n\\n# (ExterCond_Score)\\n# Usefulness: Converts the ordinal exterior material condition into a numerical score.\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA']\\ndf['ExterCond_Score'] = df['ExterCond'].map(quality_mapping).fillna(0)\\n\\n# (BsmtQual_Score)\\n# Usefulness: Converts basement height/quality to a numerical score, with 'NA' indicating no basement mapped to 0.\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA']\\ndf['BsmtQual_Score'] = df['BsmtQual'].map(general_na_zero_mapping).fillna(0)\\n\\n# (BsmtCond_Score)\\n# Usefulness: Converts basement condition to a numerical score, with 'NA' mapped to 0.\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA']\\ndf['BsmtCond_Score'] = df['BsmtCond'].map(general_na_zero_mapping).fillna(0)\\n\\n# (KitchenQual_Score)\\n# Usefulness: Converts kitchen quality to a numerical score, highly indicative of house appeal.\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA']\\ndf['KitchenQual_Score'] = df['KitchenQual'].map(quality_mapping).fillna(0)\\n\\n# (HeatingQC_Score)\\n# Usefulness: Converts heating quality and condition to a numerical score.\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex']\\ndf['HeatingQC_Score'] = df['HeatingQC'].map(quality_mapping).fillna(0)\\n\\n# (FireplaceQu_Score)\\n# Usefulness: Converts fireplace quality to a numerical score, with 'NA' (no fireplace) mapped to 0.\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan]\\ndf['FireplaceQu_Score'] = df['FireplaceQu'].map(general_na_zero_mapping).fillna(0)\\n\\n# (GarageQual_Score)\\n# Usefulness: Converts garage quality to a numerical score, with 'NA' (no garage) mapped to 0. Addresses previous KeyError.\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA']\\ndf['GarageQual_Score'] = df['GarageQual'].map(general_na_zero_mapping).fillna(0)\\n\\n# (GarageCond_Score)\\n# Usefulness: Converts garage condition to a numerical score, with 'NA' mapped to 0.\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA']\\ndf['GarageCond_Score'] = df['GarageCond'].map(general_na_zero_mapping).fillna(0)\\n\\n\\n# Regenerate key aggregate and log-transformed numerical features as necessary prerequisites.\\n\\n# (TotalSF)\\n# Usefulness: Represents the combined total finished square footage of above-grade living area and basement, a primary value driver.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (TotalOutdoorSF)\\n# Usefulness: Aggregates all outdoor areas (decks, porches) into a single metric for outdoor living space.\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Log_GrLivArea)\\n# Usefulness: Applies a log1p transformation to 'GrLivArea' to reduce skewness and improve linearity in models.\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['Log_GrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Log_LotArea)\\n# Usefulness: Applies a log1p transformation to 'LotArea' for similar reasons as 'Log_GrLivArea'.\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['Log_LotArea'] = np.log1p(df['LotArea'])\\n\\n# Introduce new value-adding features and re-introduce key features that were part of prior logical groups but might have been discarded.\\n\\n# (TotalQual_Score_Combined)\\n# Usefulness: A composite score summing multiple quality assessments, providing a holistic quality metric.\\n# Input samples: 'ExterQual_Score': [3, 4, 3], 'KitchenQual_Score': [3, 4, 3], 'HeatingQC_Score': [5, 5, 5], 'BsmtQual_Score': [3, 4, 3], 'FireplaceQu_Score': [3, 3, 0], 'GarageQual_Score': [3, 3, 3]\\ndf['TotalQual_Score_Combined'] = df['ExterQual_Score'] + df['KitchenQual_Score'] + df['HeatingQC_Score'] + df['BsmtQual_Score'] + df['FireplaceQu_Score'] + df['GarageQual_Score']\\n\\n# (TotalCond_Score_Combined)\\n# Usefulness: A composite score summing multiple condition assessments, providing a holistic condition metric.\\n# Input samples: 'ExterCond_Score': [3, 4, 3], 'BsmtCond_Score': [3, 4, 3], 'GarageCond_Score': [3, 3, 3], 'OverallCond': [6, 7, 5]\\ndf['TotalCond_Score_Combined'] = df['ExterCond_Score'] + df['BsmtCond_Score'] + df['GarageCond_Score'] + df['OverallCond']\\n\\n# (PorchToLotRatio)\\n# Usefulness: The ratio of total outdoor porch/deck area to the total lot area, indicating density of outdoor features.\\n# Input samples: 'TotalOutdoorSF': [165, 264, 56], 'LotArea': [10000, 14541, 4500]\\ndf['PorchToLotRatio'] = df['TotalOutdoorSF'] / df['LotArea'].replace(0, np.nan)\\ndf['PorchToLotRatio'] = df['PorchToLotRatio'].fillna(0)\\n\\n# (HasOverallQual8OrHigher)\\n# Usefulness: Binary indicator for properties with a high 'OverallQual', segmenting top-tier homes.\\n# Input samples: 'OverallQual': [5, 8, 5]\\ndf['HasOverallQual8OrHigher'] = (df['OverallQual'] >= 8).astype(int)\\n\\n# (HasModernRemodel)\\n# Usefulness: Binary indicator if the house was remodeled in or after the year 2000, signaling a modern update.\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YrSold': [2009, 2006, 2009]\\ndf['HasModernRemodel'] = (df['YearRemodAdd'] >= 2000).astype(int)\\n\\n# Re-incorporate other important core derived features.\\n\\n# (TotalBathrooms)\\n# Usefulness: Consolidates all bathroom types (full/half, above/below grade) into a single count.\\n# Input samples: 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0], 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0]\\ndf['TotalBathrooms'] = df['FullBath'] + 0.5 * df['HalfBath'] + df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath']\\n\\n# (AgeAtSale)\\n# Usefulness: The age of the property at the time of sale.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['AgeAtSale'] = df['YrSold'] - df['YearBuilt']\\n\\n# (YearsSinceRemodel)\\n# Usefulness: The years passed since the last remodeling event.\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceRemodel'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Room_Density_Above_Grade)\\n# Usefulness: The ratio of rooms to the logarithm of above-grade living area, indicating room spaciousness relative to total area.\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'Log_GrLivArea': [7.043, 7.832, 7.326]\\ndf['Room_Density_Above_Grade'] = df['TotRmsAbvGrd'] / df['Log_GrLivArea']\\ndf['Room_Density_Above_Grade'] = df['Room_Density_Above_Grade'].replace([np.inf, -np.inf], 0).fillna(0)\\n\\n# (Overall_Quality_Condition)\\n# Usefulness: An interaction feature multiplying overall quality and condition, capturing their synergistic effect.\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Overall_Quality_Condition'] = df['OverallQual'] * df['OverallCond']\"}]}"