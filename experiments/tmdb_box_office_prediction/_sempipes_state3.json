{
  "generated_code": [
    "\n# (Release date features: release_year, release_month, release_day, release_dayofweek, release_dayofyear)\n# Usefulness: Release timing can influence box office due to seasonality, holidays, and cultural patterns.\n# Input samples: 'release_date': ['10/15/99', '4/20/17', '2/5/15']\nimport numpy as np\nimport pandas as pd\n\nrelease_date_parsed = pd.to_datetime(df['release_date'], errors=\"coerce\", infer_datetime_format=True)\ndf['release_year'] = release_date_parsed.dt.year\ndf['release_month'] = release_date_parsed.dt.month\ndf['release_day'] = release_date_parsed.dt.day\ndf['release_dayofweek'] = release_date_parsed.dt.dayofweek\ndf['release_dayofyear'] = release_date_parsed.dt.dayofyear\n\n# (Impute missing rating using mean of (release_year, original_language))\n# Usefulness: Ensures ratings are filled in a realistic way, leveraging similar movies in terms of language and release epoch.\n# Input samples: 'rating': [8.4, 5.5, 6.9], 'release_year': [1999, 2017, 2015], 'original_language': ['en', 'en', 'en']\nrating_means = df.groupby(['release_year', 'original_language'])['rating'].transform('mean')\ndf['rating_filled'] = df['rating']\ndf.loc[df['rating'].isnull(), 'rating_filled'] = rating_means[df['rating'].isnull()]\ndf['rating_filled'] = df['rating_filled'].astype(float)\n\n# (Impute missing totalVotes using mean of (release_year, original_language))\n# Usefulness: Fills vote counts with realistic values by year/language segments, boosting model robustness to missing data.\n# Input samples: 'totalVotes': [15256.0, 284.0, 666.0], 'release_year': [1999, 2017, 2015], 'original_language': ['en', 'en', 'en']\nvotes_means = df.groupby(['release_year', 'original_language'])['totalVotes'].transform('mean')\ndf['totalVotes_filled'] = df['totalVotes']\ndf.loc[df['totalVotes'].isnull(), 'totalVotes_filled'] = votes_means[df['totalVotes'].isnull()]\ndf['totalVotes_filled'] = df['totalVotes_filled'].astype(float)\n\n# (Inflation-adjusted budget and log-normalized budget)\n# Usefulness: Adjusting for inflation and log-transforming normalizes scale and makes budgets from different eras comparable.\n# Input samples: 'budget': [63000000, 12000000, 0], 'release_year': [1999, 2017, 2015]\n# CPI index relative to 2018 (approximate, US only): 1999=1.48, 2004=1.27, 2009=1.14, 2014=1.03, 2017=1.01, 2018=1.00\ndef adjust_inflation(row):\n    year = row['release_year']\n    budget = row['budget']\n    if pd.isnull(year):\n        return np.nan\n    if year < 2000:\n        factor = 1.48\n    elif year < 2005:\n        factor = 1.27\n    elif year < 2010:\n        factor = 1.14\n    elif year < 2015:\n        factor = 1.03\n    elif year < 2018:\n        factor = 1.01\n    else:\n        factor = 1.00\n    return budget * factor\n\ndf['budget_inflation_adj'] = df.apply(adjust_inflation, axis=1)\ndf['budget_log1p'] = np.log1p(df['budget'])\n\n# (Number of female and male crew members, number of crew members in total)\n# Usefulness: Gender and crew size can be proxies for diversity and production scale.\n# Input samples: 'crew': [very long JSON strings with gender and job info]\nimport ast\n\ndef count_gender_in_crew(s, target_gender):\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        return sum(1 for entry in lst if isinstance(entry, dict) and entry.get('gender', None) == target_gender)\n    except Exception:\n        return 0\n\ndef count_crew(s):\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        return len(lst) if isinstance(lst, list) else 0\n    except Exception:\n        return 0\n\ndf['crew_num_male'] = df['crew'].apply(lambda s: count_gender_in_crew(s, 2))\ndf['crew_num_female'] = df['crew'].apply(lambda s: count_gender_in_crew(s, 1))\ndf['crew_count'] = df['crew'].apply(count_crew)\n\n# (Collection name by ordinal encoding, has_collection bool)\n# Usefulness: Franchise/collection status can directly affect box office; ordinal encoding allows downstream regression.\n# Input samples: 'belongs_to_collection': [nan, \"[{'id': 119, 'name': 'The Lord of the Rings Collection', ...}]\", nan]\nfrom collections import Counter\n\ndef extract_collection_name(s):\n    if pd.isnull(s):\n        return 'None'\n    try:\n        items = ast.literal_eval(s)\n        if isinstance(items, list) and len(items) > 0:\n            name = items[0].get('name', 'None')\n            return str(name)\n        return 'None'\n    except Exception:\n        return 'None'\n\ndf['collection_name'] = df['belongs_to_collection'].apply(extract_collection_name)\n# Ordinal encoding by frequency (most common collection gets lowest code)\ncollection_counts = df['collection_name'].value_counts()\ncollection_order = {name: i for i, name in enumerate(collection_counts.index)}\ndf['collection_name_ord'] = df['collection_name'].map(collection_order).fillna(-1).astype(int)\ndf['has_collection'] = (df['collection_name'] != 'None').astype(int)\n\n# (Number of keywords, number of cast members)\n# Usefulness: Size of cast/keywords can indicate scope and marketing reach of a movie.\n# Input samples: 'Keywords': [JSON string or nan], 'cast': [JSON string or nan]\ndef count_keywords(s):\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        return len(lst) if isinstance(lst, list) else 0\n    except Exception:\n        return 0\n\ndef count_cast(s):\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        return len(lst) if isinstance(lst, list) else 0\n    except Exception:\n        return 0\n\ndf['num_keywords'] = df['Keywords'].apply(count_keywords)\ndf['cast_count'] = df['cast'].apply(count_cast)\n\n# (Mean popularity for same year, ratio: budget/runtime, budget/popularity, totalVotes/popularity, rating/popularity)\n# Usefulness: These relational features capture economic/marketing efficiency and contextual popularity.\n# Input samples: 'popularity': [63.87, 10.16, 9.96], 'budget': [63000000, 12000000, 0], 'runtime': [139, 100, 85], 'totalVotes_filled': [15256, 284, 666], 'rating_filled': [8.4, 5.5, 6.9]\ndf['popularity_year_mean'] = df.groupby('release_year')['popularity'].transform('mean')\ndf['budget_runtime_ratio'] = df['budget'] / df['runtime'].replace(0, np.nan)\ndf['budget_popularity_ratio'] = df['budget'] / df['popularity'].replace(0, np.nan)\ndf['votes_popularity_ratio'] = df['totalVotes_filled'] / df['popularity'].replace(0, np.nan)\ndf['rating_popularity_ratio'] = df['rating_filled'] / df['popularity'].replace(0, np.nan)\n\n# (Most common spoken language, production country, production company, genre: ordinal encoding)\n# Usefulness: These categorical encodings allow the model to learn box office patterns at the language/country/company/genre level.\n# Input samples:\n# 'spoken_languages': [\"[{'iso_639_1': 'en', 'name': 'English'}]\", ...],\n# 'production_countries': [\"[{'iso_3166_1': 'DE', 'name': 'Germany'}]\", ...],\n# 'production_companies': [\"[{'name': 'Twentieth Century Fox Film Corporation', ...}]\", ...],\n# 'genres': [\"[{'id': 18, 'name': 'Drama'}]\", ...]\n\ndef first_field_from_json_list(s, key):\n    if pd.isnull(s):\n        return 'None'\n    try:\n        lst = ast.literal_eval(s)\n        if isinstance(lst, list) and len(lst) > 0:\n            val = lst[0].get(key, 'None')\n            return str(val)\n        return 'None'\n    except Exception:\n        return 'None'\n\n# Extract first for each, then ordinal-encode by frequency\nfor col, key, newcol in [\n    ('spoken_languages', 'name', 'main_language'),\n    ('production_countries', 'name', 'main_country'),\n    ('production_companies', 'name', 'main_company'),\n    ('genres', 'name', 'main_genre')\n]:\n    df[newcol] = df[col].apply(lambda s: first_field_from_json_list(s, key))\n    counts = df[newcol].value_counts()\n    order = {name: i for i, name in enumerate(counts.index)}\n    df[newcol + '_ord'] = df[newcol].map(order).fillna(-1).astype(int)\n\n# (Binary features and text length/count features: has_homepage, tagline_missing, original_language_is_en, released, original_title_differs, title/overview/tagline/original_title letter/word counts)\n# Usefulness: These features capture marketing efforts, title differences, status, and rich proxy variables for production effort and internationalization.\n# Input samples: 'homepage': ['http://...', nan], 'tagline': ['Mischief. Mayhem. Soap.', nan], etc.\n\ndf['has_homepage'] = df['homepage'].notnull().astype(int)\ndf['tagline_missing'] = df['tagline'].isnull().astype(int)\ndf['original_language_is_en'] = (df['original_language'] == 'en').astype(int)\ndf['original_title_differs'] = (df['original_title'] != df['title']).astype(int)\ndf['is_released'] = (df['status'] == 'Released').astype(int)\n\ndf['original_title_lettercount'] = df['original_title'].str.len()\ndf['original_title_wordcount'] = df['original_title'].str.split().str.len()\ndf['title_wordcount'] = df['title'].str.split().str.len()\ndf['overview_wordcount'] = df['overview'].fillna('').str.split().str.len()\ndf['tagline_wordcount'] = df['tagline'].fillna('').str.split().str.len()\ndf['title_lettercount'] = df['title'].str.len()\ndf['overview_lettercount'] = df['overview'].fillna('').str.len()\ndf['tagline_lettercount'] = df['tagline'].fillna('').str.len()\n\n# (Number of production companies, production countries, cast, crew)\n# Usefulness: Quantifies the scale and internationality of production, and broadness of cast, which can impact box office.\n# Input samples: as above\n\ndef count_json_list(s):\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        return len(lst) if isinstance(lst, list) else 0\n    except Exception:\n        return 0\n\ndf['num_production_companies'] = df['production_companies'].apply(count_json_list)\ndf['num_production_countries'] = df['production_countries'].apply(count_json_list)\n# (cast_count, crew_count already defined)\n\n# For completeness, count of cast and crew (redundant if already above, but for downstream compatibility)\ndf['num_cast'] = df['cast'].apply(count_json_list)\ndf['num_crew'] = df['crew'].apply(count_json_list)\n\n# (Mean runtime, popularity, budget, totalVotes for movie's year; median budget for movie's year; mean totalVotes for movie's rating)\n# Usefulness: Provides movie-year and rating context for these variables, letting model learn relative scale/importance.\n# Input samples: 'runtime': [139,100,85], 'release_year': [1999,2017,2015], etc.\n\ndf['runtime_year_mean'] = df.groupby('release_year')['runtime'].transform('mean')\ndf['popularity_year_mean'] = df.groupby('release_year')['popularity'].transform('mean')\ndf['budget_year_mean'] = df.groupby('release_year')['budget'].transform('mean')\ndf['totalVotes_year_mean'] = df.groupby('release_year')['totalVotes_filled'].transform('mean')\ndf['budget_year_median'] = df.groupby('release_year')['budget'].transform('median')\ndf['totalVotes_rating_mean'] = df.groupby('rating_filled')['totalVotes_filled'].transform('mean')\n# (Number of genres, number of spoken languages)\n# Usefulness: Gives a direct measure of movie complexity or target market; more genres/languages can mean broader appeal.\n# Input samples: 'genres': [\"[{'id': 18, 'name': 'Drama'}]\", \"[{'id': 18, 'name': 'Drama'}, {'id': 53, 'name': 'Thriller'}]\", ...], 'spoken_languages': [\"[{'iso_639_1': 'en', 'name': 'English'}]\", ...]\nimport ast\n\ndef count_json_items(x):\n    if pd.isnull(x):\n        return 0\n    try:\n        l = ast.literal_eval(x)\n        return len(l) if isinstance(l, list) else 0\n    except Exception:\n        return 0\n\ndf['num_genres'] = df['genres'].apply(count_json_items)\ndf['num_spoken_languages'] = df['spoken_languages'].apply(count_json_items)\n\n# (Budget per cast member, budget per production company, budget per crew member)\n# Usefulness: Measures budget allocation per person/company, which can relate to star power or production value.\n# Input samples: 'budget': [63000000, 12000000, 0], 'cast_count': [76, 18, 15], 'num_production_companies': [7, 1, 3], 'crew_count': [97, 63, 56]\ndf['budget_per_cast'] = df['budget'] / df['cast_count'].replace(0, np.nan)\ndf['budget_per_company'] = df['budget'] / df['num_production_companies'].replace(0, np.nan)\ndf['budget_per_crew'] = df['budget'] / df['crew_count'].replace(0, np.nan)\n\n# (Popularity per cast, popularity per crew)\n# Usefulness: Higher popularity per key personnel may identify star-driven or niche films.\n# Input samples: 'popularity': [63.87, 10.16, 9.96], 'cast_count': [76, 18, 15], 'crew_count': [97, 63, 56]\ndf['popularity_per_cast'] = df['popularity'] / df['cast_count'].replace(0, np.nan)\ndf['popularity_per_crew'] = df['popularity'] / df['crew_count'].replace(0, np.nan)\n\n# (Cast/crew ratio, cast/company ratio, crew/company ratio)\n# Usefulness: Indicates organizational structure and film scale.\n# Input samples: 'cast_count': [76, 18, 15], 'crew_count': [97, 63, 56], 'num_production_companies': [7, 1, 3]\ndf['cast_crew_ratio'] = df['cast_count'] / df['crew_count'].replace(0, np.nan)\ndf['cast_company_ratio'] = df['cast_count'] / df['num_production_companies'].replace(0, np.nan)\ndf['crew_company_ratio'] = df['crew_count'] / df['num_production_companies'].replace(0, np.nan)\n\n# (Is sequel)\n# Usefulness: Sequels/franchise entries often perform differently at the box office.\n# Input samples: 'collection_name': ['None', 'The Lord of the Rings Collection', ...], 'title': ['Fight Club', 'The Lord of the Rings: The Two Towers', ...]\nimport re\ndef is_sequel_func(row):\n    # Look for numbers or sequel keywords in title or collection\n    title = str(row['title']).lower()\n    collection = str(row['collection_name']).lower()\n    sequel_keywords = ['part', 'ii', '2', 'iii', '3', 'iv', '4', 'chapter', 'episode', 'return', 'revenge', 'next']\n    num_match = bool(re.search(r'\b[2-9]{1}\b', title)) or bool(re.search(r'\bii+\b', title))\n    seq_kw_match = any(kw in title for kw in sequel_keywords) or any(kw in collection for kw in sequel_keywords)\n    return int(num_match or seq_kw_match)\n\ndf['is_sequel'] = df.apply(is_sequel_func, axis=1)\n\n# (Is animation)\n# Usefulness: Animation movies have different box office behavior.\n# Input samples: 'genres': [\"[{'id': 10751, 'name': 'Family'}, {'id': 16, 'name': 'Animation'}, ...]\", ...]\ndef is_animation_func(s):\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        for g in lst:\n            if isinstance(g, dict) and ('animation' in str(g.get('name', '')).lower()):\n                return 1\n        return 0\n    except Exception:\n        return 0\n\ndf['is_animation'] = df['genres'].apply(is_animation_func)\n\n# (Is Christmas or summer release)\n# Usefulness: Seasonality is a strong factor in box office performance.\n# Input samples: 'release_month': [10, 4, 2], 'release_day': [15, 20, 5]\ndef is_christmas_release(m, d):\n    # Nov-Dec (esp. late Nov/Dec) is Christmas season\n    return int((m == 12 and d >= 10) or (m == 11 and d >= 20))\n\ndef is_summer_release(m):\n    # May-August is summer blockbuster season\n    return int(m in [5, 6, 7, 8])\n\ndf['is_christmas_release'] = [is_christmas_release(m, d) for m, d in zip(df['release_month'], df['release_day'])]\ndf['is_summer_release'] = df['release_month'].isin([5, 6, 7, 8]).astype(int)\n\n# (Minimum/maximum popularity for year)\n# Usefulness: Provides relative context for popularity for the movie's year.\n# Input samples: 'release_year': [1999, 2017, 2015], 'popularity': [63.87, 10.16, 9.96]\ndf['popularity_year_min'] = df.groupby('release_year')['popularity'].transform('min')\ndf['popularity_year_max'] = df.groupby('release_year')['popularity'].transform('max')\n\n# (Production company, country, language, genre: cardinality)\n# Usefulness: Gives an idea of diversity, potential reach, and market targeting.\ndf['production_company_cardinality'] = df['num_production_companies']\ndf['production_country_cardinality'] = df['num_production_countries']\ndf['spoken_language_cardinality'] = df['num_spoken_languages']\ndf['genre_cardinality'] = df['num_genres']\n# (Mean/median/variance of runtime and budget for each main genre)\n# Usefulness: Understanding typical scale (budget/runtime) for a genre lets the model compare a film's values to genre norms.\n# Input samples: 'main_genre': ['Drama', 'Thriller', 'Animation'], 'runtime': [139, 100, 85], 'budget': [63000000, 12000000, 0]\ndf['main_genre_runtime_mean'] = df.groupby('main_genre')['runtime'].transform('mean')\ndf['main_genre_runtime_median'] = df.groupby('main_genre')['runtime'].transform('median')\ndf['main_genre_runtime_var'] = df.groupby('main_genre')['runtime'].transform('var')\ndf['main_genre_budget_mean'] = df.groupby('main_genre')['budget'].transform('mean')\ndf['main_genre_budget_median'] = df.groupby('main_genre')['budget'].transform('median')\ndf['main_genre_budget_var'] = df.groupby('main_genre')['budget'].transform('var')\n\n# (Number of unique keywords)\n# Usefulness: A higher number of unique keywords may indicate broader thematic appeal or complex marketing.\n# Input samples: 'Keywords': [\"[{'id': 825, 'name': 'support group'}, ...]\", nan, \"[{'id': 548, ...}]\", ...]\ndef get_keyword_names(s):\n    import ast\n    if pd.isnull(s):\n        return set()\n    try:\n        lst = ast.literal_eval(s)\n        return set(x['name'] for x in lst if isinstance(x, dict) and 'name' in x)\n    except Exception:\n        return set()\n\ndf['unique_keywords_count'] = df['Keywords'].apply(lambda x: len(get_keyword_names(x)))\n\n# (Fraction of English spoken languages)\n# Usefulness: Movies with dialogue in English are more likely to have a wider box office in many markets.\n# Input samples: 'spoken_languages': [\"[{'iso_639_1': 'en', 'name': 'English'}]\", \"[{'iso_639_1': 'en', ...}, {'iso_639_1': 'fr', ...}]\", ...]\ndef frac_en_spoken(s):\n    import ast\n    if pd.isnull(s):\n        return 0.0\n    try:\n        lst = ast.literal_eval(s)\n        if not lst: return 0.0\n        en_count = sum(1 for item in lst if isinstance(item, dict) and (item.get('iso_639_1', '') == 'en' or 'english' in str(item.get('name', '')).lower()))\n        return en_count / len(lst) if len(lst) else 0.0\n    except Exception:\n        return 0.0\n\ndf['frac_en_spoken'] = df['spoken_languages'].apply(frac_en_spoken)\n\n# (Is original: source novel, based on book/comic)\n# Usefulness: Adaptations and original works frequently have different revenue patterns.\n# Input samples: 'Keywords': [\"[{'id': 818, 'name': 'based on novel'}, ...]\", ...]\ndef has_adaptation_keyword(s):\n    kw_list = ['novel', 'book', 'comic', 'adaptation', 'fairy tale', 'story', 'short story']\n    names = get_keyword_names(s)\n    return int(any(any(kw in str(n).lower() for kw in kw_list) for n in names))\n\ndf['is_adaptation'] = df['Keywords'].apply(has_adaptation_keyword)\n\n# (Title and tagline sentiment: length, exclamation/question, capitalization)\n# Usefulness: Certain title/tagline characteristics are associated with genre, marketing, or audience targeting.\n# Input samples: 'title': ['Fight Club', 'Unforgettable'], 'tagline': ['Mischief. Mayhem. Soap.', nan]\ndf['title_has_exclam'] = df['title'].str.contains('!', na=False).astype(int)\ndf['title_has_question'] = df['title'].str.contains('\\?', na=False).astype(int)\ndf['title_num_capitals'] = df['title'].apply(lambda s: sum(1 for c in str(s) if c.isupper()))\ndf['tagline_has_exclam'] = df['tagline'].fillna('').str.contains('!', na=False).astype(int)\ndf['tagline_has_question'] = df['tagline'].fillna('').str.contains('\\?', na=False).astype(int)\ndf['tagline_num_capitals'] = df['tagline'].fillna('').apply(lambda s: sum(1 for c in str(s) if c.isupper()))\n\n# (Runtime below/above genre median)\n# Usefulness: Relative position of runtime to genre median can indicate outliers, which may affect commercial performance.\ndf['runtime_gt_genre_median'] = (df['runtime'] > df['main_genre_runtime_median']).astype(int)\ndf['runtime_lt_genre_median'] = (df['runtime'] < df['main_genre_runtime_median']).astype(int)\n\n# (Budget below/above genre median)\n# Usefulness: Relative position of budget to genre norms can indicate risk or production value.\ndf['budget_gt_genre_median'] = (df['budget'] > df['main_genre_budget_median']).astype(int)\ndf['budget_lt_genre_median'] = (df['budget'] < df['main_genre_budget_median']).astype(int)\n\n# (Is remake/reboot)\n# Usefulness: Remakes/reboots have specific box office trends.\ndef is_remake(s):\n    if pd.isnull(s): return 0\n    try:\n        names = get_keyword_names(s)\n        for n in names:\n            if any(x in str(n).lower() for x in ['remake', 'reboot']):\n                return 1\n        return 0\n    except Exception:\n        return 0\n\ndf['is_remake'] = df['Keywords'].apply(is_remake)\n# (Fraction of crew in directing, writing, production departments)\n# Usefulness: High concentration of crew in key departments (directing, writing, production) may indicate focus, auteur-driven, or big productions.\n# Input samples: 'crew': [JSON string with various 'department's]\ndef fraction_crew_in_dept(s, dept):\n    import ast\n    if pd.isnull(s):\n        return 0.0\n    try:\n        lst = ast.literal_eval(s)\n        if not lst:\n            return 0.0\n        count_dept = sum(1 for entry in lst if isinstance(entry, dict) and entry.get('department', '') == dept)\n        return count_dept / len(lst) if len(lst) else 0.0\n    except Exception:\n        return 0.0\n\ndf['crew_frac_directing'] = df['crew'].apply(lambda s: fraction_crew_in_dept(s, 'Directing'))\ndf['crew_frac_writing'] = df['crew'].apply(lambda s: fraction_crew_in_dept(s, 'Writing'))\ndf['crew_frac_production'] = df['crew'].apply(lambda s: fraction_crew_in_dept(s, 'Production'))\n\n# (Number of female protagonists in cast)\n# Usefulness: Films with more prominent female roles may have different box office outcomes due to audience targeting.\ndef num_female_protagonists(s):\n    import ast\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        # Gender==1 is female; protagonist if order < 5\n        return sum(1 for entry in lst if isinstance(entry, dict) and entry.get('gender', 0) == 1 and entry.get('order', 100) < 5)\n    except Exception:\n        return 0\n\ndf['num_female_leads'] = df['cast'].apply(num_female_protagonists)\n\n# (Number of male protagonists in cast)\n# Usefulness: See above; gender breakdown of leads can influence marketing and audience.\ndef num_male_protagonists(s):\n    import ast\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        # Gender==2 is male; protagonist if order < 5\n        return sum(1 for entry in lst if isinstance(entry, dict) and entry.get('gender', 0) == 2 and entry.get('order', 100) < 5)\n    except Exception:\n        return 0\n\ndf['num_male_leads'] = df['cast'].apply(num_male_protagonists)\n\n# (Ratio of female/male leads)\n# Usefulness: Captures gender representation in lead roles.\ndf['female_male_leads_ratio'] = df['num_female_leads'] / (df['num_male_leads'] + 1e-3)\n\n# (Title contains number)\n# Usefulness: Often indicates sequels/franchise, which have box office patterns.\nimport re\ndef title_contains_number(s):\n    if pd.isnull(s): return 0\n    return int(bool(re.search(r'\b\\d+\b', str(s))))\n\ndf['title_contains_number'] = df['title'].apply(title_contains_number)\n\n# (Production company is major studio: ordinal encoding)\n# Usefulness: Major studios have more marketing power and established distribution.\nmajor_studios = [\n    'warner bros', 'universal', 'paramount', 'sony', 'twentieth century fox', '20th century fox',\n    'walt disney', 'columbia pictures', 'new line cinema', 'marvel studios'\n]\ndef is_major_studio(s):\n    import ast\n    if pd.isnull(s): return 0\n    try:\n        lst = ast.literal_eval(s)\n        for entry in lst:\n            if isinstance(entry, dict) and any(ms in str(entry.get('name', '')).lower() for ms in major_studios):\n                return 1\n        return 0\n    except Exception:\n        return 0\n\ndf['has_major_studio'] = df['production_companies'].apply(is_major_studio)\n\n# (Tagline contains number)\n# Usefulness: Taglines with numbers often highlight sequels or milestones.\ndef tagline_contains_number(s):\n    if pd.isnull(s): return 0\n    return int(bool(re.search(r'\b\\d+\b', str(s))))\n\ndf['tagline_contains_number'] = df['tagline'].apply(tagline_contains_number)\n\n# (Cast contains Oscar winner)\n# Usefulness: Oscar-winning actors can boost box office; we'll use a static list of famous winners for simplicity.\noscar_winners = [\n    'tom hanks', 'meryl streep', 'leonardo dicaprio', 'natalie portman', 'dustin hoffman', 'sean penn', 'sandra bullock',\n    'cate blanchett', 'denzel washington', 'jodie foster', 'matthew mcconaughey', 'nicole kidman',\n    'russell crowe', 'emma stone', 'julianne moore', 'marion cotillard', 'jennifer lawrence', 'jeff bridges'\n]\ndef has_oscar_winner(s):\n    import ast\n    if pd.isnull(s): return 0\n    try:\n        lst = ast.literal_eval(s)\n        for entry in lst:\n            if isinstance(entry, dict) and any(w in str(entry.get('name', '')).lower() for w in oscar_winners):\n                return 1\n        return 0\n    except Exception:\n        return 0\n\ndf['has_oscar_winner_cast'] = df['cast'].apply(has_oscar_winner)\n\n# (Crew contains Oscar winner)\ndef has_oscar_winner_crew(s):\n    import ast\n    if pd.isnull(s): return 0\n    try:\n        lst = ast.literal_eval(s)\n        for entry in lst:\n            if isinstance(entry, dict) and any(w in str(entry.get('name', '')).lower() for w in oscar_winners):\n                return 1\n        return 0\n    except Exception:\n        return 0\n\ndf['has_oscar_winner_crew'] = df['crew'].apply(has_oscar_winner_crew)\n# (Fraction of top 5 cast with profile pictures)\n# Usefulness: Indicates star-power; more known actors usually have profile pics and attract audiences.\ndef frac_top5_cast_with_profile(s):\n    import ast\n    if pd.isnull(s): return 0.0\n    try:\n        lst = ast.literal_eval(s)\n        if not lst: return 0.0\n        top5 = [entry for entry in lst if isinstance(entry, dict) and entry.get('order', 1000) < 5]\n        if not top5: return 0.0\n        return sum(1 for entry in top5 if entry.get('profile_path')) / len(top5)\n    except Exception:\n        return 0.0\n\ndf['frac_top5_cast_with_profile'] = df['cast'].apply(frac_top5_cast_with_profile)\n\n# (Is international co-production)\n# Usefulness: Multiple production countries can indicate international financing, affecting box office potential.\ndf['is_international_coprod'] = (df['num_production_countries'] > 1).astype(int)\n\n# (Release weekday: ordinal encode, with (Friday/Saturday/Sunday) as highest values)\n# Usefulness: Weekend releases usually have higher box office.\nweekday_order = {0: 2, 1: 3, 2: 4, 3: 5, 4: 6, 5: 7, 6: 1}  # Monday:2, ..., Friday:7, Saturday:1\ndf['release_weekday_ord'] = df['release_dayofweek'].map(weekday_order).fillna(-1).astype(int)\n\n# (Number of unique cast names)\n# Usefulness: Measures diversity of cast, which can affect marketing and appeal.\ndef num_unique_cast_names(s):\n    import ast\n    if pd.isnull(s):\n        return 0\n    try:\n        lst = ast.literal_eval(s)\n        return len(set(entry['name'] for entry in lst if isinstance(entry, dict) and 'name' in entry))\n    except Exception:\n        return 0\n\ndf['num_unique_cast'] = df['cast'].apply(num_unique_cast_names)\n\n# (Cast gender diversity index)\n# Usefulness: More diverse casts can broaden a film's appeal.\ndef cast_gender_diversity(s):\n    import ast\n    if pd.isnull(s): return 0.0\n    try:\n        lst = ast.literal_eval(s)\n        genders = [entry.get('gender', 0) for entry in lst if isinstance(entry, dict)]\n        if not genders: return 0.0\n        p_female = sum(1 for g in genders if g == 1) / len(genders)\n        p_male = sum(1 for g in genders if g == 2) / len(genders)\n        return 1 - abs(p_female - p_male)\n    except Exception:\n        return 0.0\n\ndf['cast_gender_diversity'] = df['cast'].apply(cast_gender_diversity)\n\n# (Crew gender diversity index)\ndef crew_gender_diversity(s):\n    import ast\n    if pd.isnull(s): return 0.0\n    try:\n        lst = ast.literal_eval(s)\n        genders = [entry.get('gender', 0) for entry in lst if isinstance(entry, dict)]\n        if not genders: return 0.0\n        p_female = sum(1 for g in genders if g == 1) / len(genders)\n        p_male = sum(1 for g in genders if g == 2) / len(genders)\n        return 1 - abs(p_female - p_male)\n    except Exception:\n        return 0.0\n\ndf['crew_gender_diversity'] = df['crew'].apply(crew_gender_diversity)\n\n# (Overview contains Oscar/award keywords)\n# Usefulness: Award-related words in overview may indicate a prestige project.\naward_words = ['oscar', 'academy award', 'golden globe', 'bafta', 'cannes', 'winner', 'nominated', 'nominee', 'award']\ndef overview_has_award(x):\n    if pd.isnull(x): return 0\n    x = x.lower()\n    return int(any(word in x for word in award_words))\ndf['overview_has_award'] = df['overview'].apply(overview_has_award)\n\n# (Tagline contains \"true story\"/\"based on true events\" etc.)\n# Usefulness: True stories often have box office appeal.\ndef tagline_has_true_story(x):\n    if pd.isnull(x): return 0\n    x = x.lower()\n    return int(('true story' in x) or ('based on true' in x) or ('inspired by true' in x))\ndf['tagline_has_true_story'] = df['tagline'].apply(tagline_has_true_story)\n\n# (Title contains location words)\n# Usefulness: Location in the title is often present in travel/war/historical/epic movies.\nlocation_words = ['paris', 'london', 'america', 'new york', 'berlin', 'rome', 'china', 'japan', 'india', 'africa', 'france', 'italy', 'spain', 'canada', 'australia', 'brazil', 'hollywood', 'texas', 'california', 'alaska']\ndef title_has_location(x):\n    if pd.isnull(x): return 0\n    x = x.lower()\n    return int(any(lw in x for lw in location_words))\ndf['title_has_location'] = df['title'].apply(title_has_location)\n# (Fraction of cast with last names)\n# Usefulness: Single-name (mononymous) actors are rare and may suggest niche or foreign markets.\ndef frac_cast_with_lastname(s):\n    import ast\n    if pd.isnull(s): return 0.0\n    try:\n        lst = ast.literal_eval(s)\n        if not lst:\n            return 0.0\n        names = [entry['name'] for entry in lst if isinstance(entry, dict) and 'name' in entry]\n        if not names:\n            return 0.0\n        return sum(1 for n in names if len(str(n).split()) > 1) / len(names)\n    except Exception:\n        return 0.0\n\ndf['frac_cast_with_lastname'] = df['cast'].apply(frac_cast_with_lastname)\n\n# (Number of unique crew job types)\n# Usefulness: Measures production complexity and organizational diversity.\ndef num_unique_crew_jobs(s):\n    import ast\n    if pd.isnull(s): return 0\n    try:\n        lst = ast.literal_eval(s)\n        return len(set(entry['job'] for entry in lst if isinstance(entry, dict) and 'job' in entry))\n    except Exception:\n        return 0\n\ndf['num_unique_crew_jobs'] = df['crew'].apply(num_unique_crew_jobs)\n\n# (Any company is from USA: binary)\n# Usefulness: USA-based companies are more likely to be associated with major releases or larger budgets.\ndef has_usa_company(s):\n    import ast\n    if pd.isnull(s): return 0\n    try:\n        lst = ast.literal_eval(s)\n        for entry in lst:\n            if isinstance(entry, dict) and ('united states' in str(entry.get('name', '')).lower() or 'usa' in str(entry.get('name', '')).lower()):\n                return 1\n        return 0\n    except Exception:\n        return 0\n\ndf['has_usa_company'] = df['production_companies'].apply(has_usa_company)\n\n# (Fraction of cast with 'Jr.'/'Sr.'/'III' in name)\n# Usefulness: Can correlate with period/historical pieces or unique casting.\ndef frac_cast_with_suffix(s):\n    import ast\n    if pd.isnull(s): return 0.0\n    try:\n        lst = ast.literal_eval(s)\n        if not lst:\n            return 0.0\n        names = [entry['name'] for entry in lst if isinstance(entry, dict) and 'name' in entry]\n        suffixes = ['jr.', 'sr.', 'iii', 'ii']\n        return sum(1 for n in names if any(suf in str(n).lower() for suf in suffixes)) / len(names) if names else 0.0\n    except Exception:\n        return 0.0\n\ndf['frac_cast_with_suffix'] = df['cast'].apply(frac_cast_with_suffix)\n\n# (Overview/title/tagline starts with \"the\")\n# Usefulness: Definite article at the beginning is common in certain genres or title conventions.\ndf['overview_startswith_the'] = df['overview'].fillna('').str.lower().str.startswith('the').astype(int)\ndf['title_startswith_the'] = df['title'].fillna('').str.lower().str.startswith('the').astype(int)\ndf['tagline_startswith_the'] = df['tagline'].fillna('').str.lower().str.startswith('the').astype(int)\n\n# (Cast contains comedian(s))\n# Usefulness: Comedies have box office trends; comedian actors can indicate genre.\ncomedian_names = [\n    'eddie murphy', 'robin williams', 'jim carrey', 'chris rock', 'martin lawrence', 'kevin hart', 'whoopi goldberg',\n    'steve martin', 'will ferrell', 'bill murray', 'seth rogen', 'tina fey', 'amy poehler', 'mel brooks', 'gene wilder',\n    'ben stiller', 'owen wilson'\n]\ndef has_comedian_cast(s):\n    import ast\n    if pd.isnull(s): return 0\n    try:\n        lst = ast.literal_eval(s)\n        for entry in lst:\n            if isinstance(entry, dict) and any(c in str(entry.get('name', '')).lower() for c in comedian_names):\n                return 1\n        return 0\n    except Exception:\n        return 0\n\ndf['has_comedian_cast'] = df['cast'].apply(has_comedian_cast)\n\n# (Number of all-caps words in title)\n# Usefulness: All-caps words are often used for emphasis or branding.\ndef num_allcaps_words(s):\n    if pd.isnull(s): return 0\n    return sum(1 for w in str(s).split() if w.isupper())\n\ndf['title_num_allcaps_words'] = df['title'].apply(num_allcaps_words)\n"
  ]
}
