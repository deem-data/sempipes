{
    "generated_code": [
        "\nimport ast, json\nimport numpy as np\nimport pandas as pd\n\n# robust parser for the JSON-like columns (many rows are Python-list-of-dicts in string form)\ndef _parse_list_of_dicts(cell):\n    if pd.isna(cell):\n        return []\n    if isinstance(cell, (list, tuple)):\n        return list(cell)\n    if not isinstance(cell, str):\n        return []\n    s = cell.strip()\n    # some entries are already JSON with double quotes, some use single quotes -> try a few ways\n    for parser in (ast.literal_eval, json.loads):\n        try:\n            parsed = parser(s)\n            if isinstance(parsed, (list, tuple)):\n                return list(parsed)\n        except Exception:\n            continue\n    # fallback: try to replace single quotes with double quotes (risky) and parse\n    try:\n        parsed = json.loads(s.replace(\"'\", '\"'))\n        if isinstance(parsed, (list, tuple)):\n            return list(parsed)\n    except Exception:\n        pass\n    # give up -> return empty list\n    return []\n\n# First batch of features (genres, collections, budget, production, release, runtime)\n# (num_genres) Number of genres listed for the movie\n# Usefulness: More genres can indicate broader appeal or cross-genre marketing; genre variety often correlates with revenue potential.\n# Input samples: 'genres': [\"[{'id': 18, 'name': 'Drama'}, {'id': 27, 'name': 'Horror'}]\", \"[{'id': 18, 'name': 'Drama'}]\", \"[{'id': 28, 'name': 'Action'}, {'id': 12, 'name': 'Adventure'}, {'id': 80, 'name': 'Crime'}]\"]\ndf['__parsed_genres'] = df['genres'].apply(_parse_list_of_dicts)\ndf['num_genres'] = df['__parsed_genres'].apply(lambda L: len(L))\n\n# (has_genre_Action/Comedy/Drama/Animation/Adventure/Horror/Romance/Science Fiction/Family/Crime)\n# Usefulness: Specific genres have strong, consistent box-office patterns (e.g., Action, Animation often earn more).\n# Input samples: same as above for 'genres'\ngenre_list = ['Action','Comedy','Drama','Animation','Adventure','Horror','Romance','Science Fiction','Family','Crime']\nfor g in genre_list:\n    col = 'genre_has_' + g.replace(' ','_')\n    df[col] = df['__parsed_genres'].apply(lambda L, g=g: int(any(( (d.get('name') or '').lower()==g.lower() ) for d in L)))\n\n# (genres_first_id) ID of the first genre (proxy for primary genre), -1 if missing\n# Usefulness: Primary genre id can capture a more granular category signal that the free text genre flags may miss.\n# Input samples: same as above for 'genres'\ndef _first_genre_id(L):\n    if not L: return -1\n    try:\n        return int(L[0].get('id', -1))\n    except Exception:\n        return -1\ndf['genres_first_id'] = df['__parsed_genres'].apply(_first_genre_id)\n\n# (belongs_to_collection_flag) Binary flag if movie belongs to a collection / franchise\n# Usefulness: Films in collections/franchises (sequels, franchises) often have higher guaranteed revenue.\n# Input samples: 'belongs_to_collection': [nan, nan, \"[{'id': 645, 'name': 'James Bond Collection', ...}]\"]\ndf['__parsed_collection'] = df['belongs_to_collection'].apply(_parse_list_of_dicts)\ndf['belongs_to_collection_flag'] = df['__parsed_collection'].apply(lambda L: int(len(L) > 0))\n# (collection_id) extract collection id if present else -1\ndef _collection_id(L):\n    if not L: return -1\n    try:\n        # sometimes the column is single dict inside list; take first id\n        v = L[0]\n        if isinstance(v, dict):\n            return int(v.get('id', -1))\n    except Exception:\n        pass\n    return -1\ndf['collection_id'] = df['__parsed_collection'].apply(_collection_id)\n\n# (log_budget) Log-transformed budget (stabilizes large values)\n# Usefulness: Budget magnitude is a key predictor for revenue; log reduces skew.\n# Input samples: 'budget': [10500000, 0, 245000000]\ndf['log_budget'] = np.log1p(df['budget'].fillna(0))\ndf['budget_zero_flag'] = (df['budget'].fillna(0) == 0).astype(int)\n\n# (num_production_companies) Number of production companies\n# Usefulness: More production companies can indicate larger/complex productions or more distribution/promotion partners.\n# Input samples: 'production_companies': [\"[{'name': 'Paramount Pictures', 'id': 4}, {'name': 'Graveyard Productions', 'id': 3826}, ...]\", ... , nan]\ndf['__parsed_prod_companies'] = df['production_companies'].apply(_parse_list_of_dicts)\ndf['num_production_companies'] = df['__parsed_prod_companies'].apply(lambda L: len(L))\n\n# (major_studio_flag) Whether any production company is a major studio (Paramount, Columbia, Universal, Warner, Fox, Disney, Sony, TriStar, MGM, DreamWorks)\n# Usefulness: Major studios often have better marketing/distribution leading to higher revenue.\nmajors = ['paramount','columbia','universal','warner','fox','20th','twentieth','disney','sony','tristar','mga','mgm','dreamworks','regency','new regency']\ndef _has_major(L):\n    for d in L:\n        name = (d.get('name') or '').lower()\n        for m in majors:\n            if m in name:\n                return 1\n    return 0\ndf['major_studio_flag'] = df['__parsed_prod_companies'].apply(_has_major)\n\n# (num_production_countries) Number of production countries\n# Usefulness: US-produced films historically earn more in global box office; international production may indicate indie/art films.\n# Input samples: 'production_countries': [\"[{'iso_3166_1': 'JP', 'name': 'Japan'}, {'iso_3166_1': 'US', 'name': 'United States of America'}]\", ...]\ndf['__parsed_prod_countries'] = df['production_countries'].apply(_parse_list_of_dicts)\ndf['num_production_countries'] = df['__parsed_prod_countries'].apply(lambda L: len(L))\ndf['produced_in_US_flag'] = df['__parsed_prod_countries'].apply(lambda L: int(any((d.get('iso_3166_1')=='US' or (d.get('name') or '').lower().find('united states')!=-1) for d in L)))\n\n# (release_year, release_month, release_weekday)\n# Usefulness: Release timing (seasonality) affects revenue (summer/winter blocks, holidays). Year can capture trends.\n# Input samples: 'release_date': ['10/26/90', '6/9/17', '10/26/15']\ndef _safe_date_parts(s):\n    try:\n        if pd.isna(s): return (np.nan, np.nan, np.nan)\n        # many dates are M/D/YY or M/D/YYYY\n        parts = s.split('/')\n        if len(parts) >= 3:\n            m = int(parts[0]); d = int(parts[1]); y = int(parts[2])\n            if y < 100: # two-digit year\n                # assume 1900s if >= 90 else 2000s (common in movie data)\n                y = 1900 + y if y >= 90 else 2000 + y\n            import datetime\n            wd = datetime.date(y, m, d).weekday()  # 0=Monday\n            return (y, m, wd)\n    except Exception:\n        pass\n    return (np.nan, np.nan, np.nan)\n\n_date_parts = df['release_date'].apply(_safe_date_parts)\ndf['release_year'] = _date_parts.apply(lambda t: t[0])\ndf['release_month'] = _date_parts.apply(lambda t: t[1])\ndf['release_weekday'] = _date_parts.apply(lambda t: t[2])\ndf['release_quarter'] = df['release_month'].apply(lambda m: ((int(m)-1)//3+1) if (pd.notna(m) and m>0) else np.nan)\n\n# (runtime_missing_flag) whether runtime is missing\n# Usefulness: Missing runtime might indicate poor data for older/indie films; runtime also correlates with production scale.\n# Input samples: 'runtime': [89.0, 97.0, 148.0]\ndf['runtime_missing_flag'] = df['runtime'].isna().astype(int)\n\n# drop temp parsed columns that might not be needed downstream (we keep them if helpful, but avoid clutter)\n# we keep parsed lists with double-underscore names in case subsequent features reuse them\n\n# Second batch of features (popularity, spoken languages, keywords, cast & crew, text lengths, homepage/tagline)\n# (popularity_log) Log1p popularity\n# Usefulness: Popularity metric already encodes audience interest; log reduces skew.\n# Input samples: 'popularity': [4.67, 6.55, 24.93]\ndf['popularity_log'] = np.log1p(df['popularity'].fillna(0))\n\n# (num_spoken_languages) Number of spoken languages and (english_spoken_flag)\n# Usefulness: English-language films often perform better in US/global markets; multilingual films may target international audiences.\n# Input samples: 'spoken_languages': [\"[{'iso_639_1': 'en', 'name': 'English'}]\", \"[{'iso_639_1': 'fr', 'name': 'Fran\u00e7ais'}, {'iso_639_1': 'en', 'name': 'English'}]\"]\ndf['__parsed_spoken_languages'] = df['spoken_languages'].apply(_parse_list_of_dicts)\ndf['num_spoken_languages'] = df['__parsed_spoken_languages'].apply(lambda L: len(L))\ndf['english_spoken_flag'] = df['__parsed_spoken_languages'].apply(lambda L: int(any((d.get('iso_639_1')=='en' or (d.get('name') or '').lower().find('english')!=-1) for d in L)))\n\n# (num_keywords) and important keyword flags (sequel, based on novel, remake, biography, superhero, zombie)\n# Usefulness: Keywords like 'sequel' or 'based on novel' indicate franchise/adaptation which often boost revenue.\n# Input samples: 'Keywords': [\"[{'id': 158072, 'name': 'man eaten by monster'}]\", \"[{'id': 470, 'name': 'spy'}, {'id': 818, 'name': 'based on novel'}, {'id': 9663, 'name': 'sequel'}]\"]\ndf['__parsed_keywords'] = df['Keywords'].apply(_parse_list_of_dicts)\ndf['num_keywords'] = df['__parsed_keywords'].apply(lambda L: len(L))\nkw_list = ['sequel','based on novel','remake','biography','superhero','zombie','alien','christmas','musical','documentary']\nfor kw in kw_list:\n    col = 'kw_has_' + kw.replace(' ','_')\n    df[col] = df['__parsed_keywords'].apply(lambda L, kw=kw: int(any(kw in ((d.get('name') or '').lower()) for d in L)))\n\n# (num_cast) number of cast entries, (top3_cast_count) number of cast with order <= 2, (cast_profile_ratio)\n# Usefulness: A larger cast and more top-billed recognizable actors (proxy via profile_path presence) can indicate star power and draw.\n# Input samples: 'cast': ['[{'cast_id': 2, 'character': 'John Hall', 'name': 'David Andrews', ...}, {...}]', \"[{'cast_id': 19, 'character': 'Lee Hayden', 'name': 'Sam Elliott', ...}, {...}]\"]\ndf['__parsed_cast'] = df['cast'].apply(_parse_list_of_dicts)\ndf['num_cast'] = df['__parsed_cast'].apply(lambda L: len(L))\ndf['top3_cast_count'] = df['__parsed_cast'].apply(lambda L: sum(1 for d in L if ( (d.get('order') is not None) and (int(d.get('order')) <= 2) )))\ndef _cast_profile_ratio(L):\n    if not L: return 0.0\n    has = sum(1 for d in L if d.get('profile_path'))\n    return has / len(L)\ndf['cast_profile_ratio'] = df['__parsed_cast'].apply(_cast_profile_ratio)\n\n# (num_crew) size of crew, (num_directors) number of Directors, (num_producers)\n# Usefulness: Director and producer counts can reflect production scale; presence of multiple directors may indicate issues/large-scale production.\n# Input samples: 'crew': [\"[{'credit_id': '52fe47c09251416c750a4627', 'department': 'Directing', 'job': 'Director', 'name': 'Ralph S. Singleton'}, {...}]\"]\ndf['__parsed_crew'] = df['crew'].apply(_parse_list_of_dicts)\ndf['num_crew'] = df['__parsed_crew'].apply(lambda L: len(L))\ndf['num_directors'] = df['__parsed_crew'].apply(lambda L: sum(1 for d in L if (d.get('job') or '').lower() == 'director'))\ndf['num_producers'] = df['__parsed_crew'].apply(lambda L: sum(1 for d in L if (d.get('job') or '').lower().endswith('producer')))\n\n# (overview_length) token/character length of overview, (title_length), (tagline_present), (homepage_present)\n# Usefulness: Longer overviews/taglines/homepages might indicate bigger marketing budgets and richer positioning which can be correlated with revenue.\n# Input samples: 'overview': ['John Hall is a drifter ...', 'Lee, a former Western film icon, ...', 'A cryptic message from Bond...']\ndf['overview_length'] = df['overview'].fillna('').apply(lambda s: len(s))\ndf['overview_word_count'] = df['overview'].fillna('').apply(lambda s: len(s.split()))\ndf['title_length'] = df['title'].fillna('').apply(lambda s: len(s))\ndf['tagline_present'] = df['tagline'].notna().astype(int)\ndf['homepage_present'] = df['homepage'].notna().astype(int)\n\n# (has_popular_cast_proxy) crude proxy for star-power: whether cast contains any widely-known sample names from dataset (Matt Damon, Drew Barrymore, Bruce Willis, Daniel Craig, Ellen Page, Tom Cruise, Brad Pitt)\n# Usefulness: Presence of known big-name actors often increases box-office.\n# Input samples: names from 'cast' samples above include 'Matt Damon','Drew Barrymore','Bruce Willis','Daniel Craig','Ellen Page'\npopular_names = ['matt damon','drew barrymore','bruce willis','daniel craig','ellen page','sam elliott','tom cruise','robert downey','leonardo dicaprio','tom hanks','brad pitt']\ndef _has_popular(L):\n    for d in L:\n        name = (d.get('name') or '').lower()\n        for p in popular_names:\n            if p in name:\n                return 1\n    return 0\ndf['has_popular_cast_proxy'] = df['__parsed_cast'].apply(_has_popular)\n\n# Final housekeeping: fill NaNs for newly added numeric features with sensible defaults to avoid issues for tree learners\nnum_cols = ['num_genres','genres_first_id','belongs_to_collection_flag','collection_id','log_budget','budget_zero_flag',\n            'num_production_companies','major_studio_flag','num_production_countries','produced_in_US_flag',\n            'release_year','release_month','release_weekday','release_quarter','runtime_missing_flag',\n            'popularity_log','num_spoken_languages','english_spoken_flag','num_keywords','num_cast','top3_cast_count',\n            'cast_profile_ratio','num_crew','num_directors','num_producers','overview_length','overview_word_count',\n            'title_length','tagline_present','homepage_present','has_popular_cast_proxy']\nfor c in num_cols:\n    if c in df.columns:\n        if df[c].dtype == 'float64' or df[c].dtype == 'int64' or df[c].dtype == 'object':\n            df[c] = df[c].fillna(0)\n\n# (Note) Many parsed intermediate columns start with '__parsed_'. They are left in df in case downstream feature engineering wants them.\n"
    ]
}