{
  "generated_code": [
    "\n# (Release date: year, month, day, day of week, day of year, elapsed days since release)\n# Usefulness: Movie release time (year, month, etc) is highly predictive for revenue due to seasonality, trend, and recency. Elapsed days since release handles how old the movie is.\n# Input samples: 'release_date': ['10/15/99', '4/20/17', '2/5/15']\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\n\ndef parse_date(date_str):\n    # Handles missing/NaN gracefully\n    try:\n        return pd.to_datetime(date_str, errors='coerce', infer_datetime_format=True)\n    except Exception:\n        return pd.NaT\n\ndf['release_date_parsed'] = df['release_date'].apply(parse_date)\n\ndf['release_year'] = df['release_date_parsed'].dt.year\ndf['release_month'] = df['release_date_parsed'].dt.month\ndf['release_day'] = df['release_date_parsed'].dt.day\ndf['release_dayofweek'] = df['release_date_parsed'].dt.dayofweek\ndf['release_dayofyear'] = df['release_date_parsed'].dt.dayofyear\ndf['release_elapsed_days'] = (pd.Timestamp.now() - df['release_date_parsed']).dt.days\n\n# (Number of cast members)\n# Usefulness: Star power/cast size is linked to marketing, appeal, and thus revenue.\n# Input samples: 'cast': [\"[{'cast_id': 4, ...}]\", \"[{'cast_id': 1, ...}]\", \"[{'cast_id': 4, ...}]\"]\nimport ast\ndef safe_count_list(val):\n    try:\n        if pd.isnull(val):\n            return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return len(x)\n    except Exception:\n        return 0\n\ndf['num_cast'] = df['cast'].apply(safe_count_list)\n\n# (Number of crew members)\n# Usefulness: Crew size indicates production scale; large productions often have higher revenue.\n# Input samples: 'crew': [\"[{'credit_id': ...}]\", \"[{'credit_id': ...}]\", \"[{'credit_id': ...}]\"]\ndf['num_crew'] = df['crew'].apply(safe_count_list)\n\n# (Has tagline)\n# Usefulness: Taglines are used for marketing. If present, it may indicate a larger marketing budget and higher expected revenue.\n# Input samples: 'tagline': ['Mischief. Mayhem. Soap.', np.nan, 'Moving on to Pastures New.']\ndf['has_tagline'] = df['tagline'].notnull().astype(int)\n\n# (Tagline length in words)\n# Usefulness: Longer taglines may be more descriptive and could correlate with marketing thoroughness.\n# Input samples: 'tagline': ['Mischief. Mayhem. Soap.', np.nan, 'Moving on to Pastures New.']\ndf['tagline_length'] = df['tagline'].fillna('').apply(lambda x: len(str(x).split()))\n\n# (Has overview)\n# Usefulness: Overview is a proxy for available metadata/promotion; missing overview might indicate a less-promoted movie.\n# Input samples: 'overview': ['A ticking-time-bomb insomniac...', np.nan, \"When Shaun decides...\"]\ndf['has_overview'] = df['overview'].notnull().astype(int)\n\n# (Overview length in words)\n# Usefulness: Richer, longer overviews may indicate a more developed marketing effort.\n# Input samples: 'overview': ['A ticking-time-bomb...', np.nan, \"When Shaun decides...\"]\ndf['overview_length'] = df['overview'].fillna('').apply(lambda x: len(str(x).split()))\n\n# (Has budget > 0)\n# Usefulness: Movies with declared budget are more likely to have significant marketing/revenue.\n# Input samples: 'budget': [63000000, 12000000, 0]\ndf['has_budget'] = (df['budget'] > 0).astype(int)\n\n# (Has homepage)\n# Usefulness: A homepage is a sign of marketing spend/effort and correlates with big releases.\n# Input samples: 'homepage': ['http://www.foxmovies.com/..', np.nan, 'http://www.shaunthesheep.com/']\ndf['has_homepage'] = df['homepage'].notnull().astype(int)\n\n# (Number of production companies)\n# Usefulness: More production companies often means bigger budget or international co-productions, leading to higher possible revenue.\n# Input samples: 'production_companies': [\"[{'name': ...}]\", \"[{'name': ...}]\", \"[{'name': ...}]\"]\ndf['num_production_companies'] = df['production_companies'].apply(safe_count_list)\n\n# (Number of production countries)\n# Usefulness: International productions may have wider release and greater revenue.\n# Input samples: 'production_countries': [\"[{'iso_3166_1': ...}]\", \"[{'iso_3166_1': ...}]\", \"[{'iso_3166_1': ...}]\"]\ndf['num_production_countries'] = df['production_countries'].apply(safe_count_list)\n\n# (Number of spoken languages)\n# Usefulness: More languages can indicate broader international appeal.\n# Input samples: 'spoken_languages': [\"[{'iso_639_1': 'en'...}]\", \"[{'iso_639_1': ...}]\", \"[{'iso_639_1': ...}]\"]\ndf['num_spoken_languages'] = df['spoken_languages'].apply(safe_count_list)\n\n# (Number of genres)\n# Usefulness: Movies spanning multiple genres may appeal to broader audiences.\n# Input samples: 'genres': [\"[{'id': 18, ...}]\", \"[{'id': 18, ...}, {'id': 53, ...}]\", ...]\ndf['num_genres'] = df['genres'].apply(safe_count_list)\n\n# (Is part of a collection)\n# Usefulness: Franchises often have guaranteed revenue due to built-in audience.\n# Input samples: 'belongs_to_collection': [np.nan, \"[{'id': 119, ...}]\", np.nan]\ndf['has_collection'] = df['belongs_to_collection'].notnull().astype(int)\n\n# (Runtime in minutes; and has runtime)\n# Usefulness: Runtime can be correlated with genre and production scale; missing runtime may indicate TV/shorts.\n# Input samples: 'runtime': [139, 100, 85]\ndf['has_runtime'] = df['runtime'].notnull().astype(int)\ndf['runtime_filled'] = df['runtime'].fillna(-1)\n\n# (Budget to runtime ratio)\n# Usefulness: Investment per minute may capture production value.\n# Input samples: 'budget': [63000000, 12000000, 0], 'runtime': [139, 100, 85]\ndf['budget_per_minute'] = df.apply(lambda x: x['budget'] / x['runtime'] if (pd.notnull(x['runtime']) and x['runtime'] > 0) else 0, axis=1)\n\n# (Number of keywords)\n# Usefulness: More keywords often provided for movies that are more promoted, which can relate to revenue.\n# Input samples: 'Keywords': [\"[{'id': 825, ...}]\", np.nan, \"[{'id': 548, ...}]\"]\ndf['num_keywords'] = df['Keywords'].apply(safe_count_list)\n\n# (Number of cast with gender==1 (female), gender==2 (male))\n# Usefulness: Gender representation can correlate with audience and marketing.\ndef count_gender(val, gender):\n    try:\n        if pd.isnull(val):\n            return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for member in x if 'gender' in member and member['gender'] == gender)\n    except Exception:\n        return 0\ndf['num_cast_female'] = df['cast'].apply(lambda x: count_gender(x, 1))\ndf['num_cast_male'] = df['cast'].apply(lambda x: count_gender(x, 2))\n\n# (Number of crew with gender==1 (female), gender==2 (male))\ndef count_crew_gender(val, gender):\n    try:\n        if pd.isnull(val):\n            return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for member in x if 'gender' in member and member['gender'] == gender)\n    except Exception:\n        return 0\ndf['num_crew_female'] = df['crew'].apply(lambda x: count_crew_gender(x, 1))\ndf['num_crew_male'] = df['crew'].apply(lambda x: count_crew_gender(x, 2))\n\n# (Number of unique production company names)\n# Usefulness: Large consortia might suggest increased marketing and reach.\ndef count_unique_company_names(val):\n    try:\n        if pd.isnull(val):\n            return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return len(set(comp['name'] for comp in x if 'name' in comp))\n    except Exception:\n        return 0\ndf['num_unique_production_companies'] = df['production_companies'].apply(count_unique_company_names)\n\n# (Number of unique production country names)\n# Usefulness: Diversity of countries signals wider distribution and appeal.\ndef count_unique_country_names(val):\n    try:\n        if pd.isnull(val):\n            return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return len(set(c['name'] for c in x if 'name' in c))\n    except Exception:\n        return 0\ndf['num_unique_production_countries'] = df['production_countries'].apply(count_unique_country_names)\n\n# (Is English original language)\n# Usefulness: English-language movies tend to have higher international box office potential.\n# Input samples: 'original_language': ['en', 'en', 'en']\ndf['is_english'] = (df['original_language'] == 'en').astype(int)\n\n# (Number of spoken languages is 1)\n# Usefulness: Single-language vs. multilingual for global/local appeal.\ndf['is_single_language'] = (df['num_spoken_languages'] == 1).astype(int)\n\n# (Genre is comedy, action, drama, animation, family, or sci-fi)\n# Usefulness: Top genres tend to have higher/lower average revenue.\ndef has_genre(genres, target):\n    try:\n        if pd.isnull(genres):\n            return 0\n        x = ast.literal_eval(genres) if isinstance(genres, str) else genres\n        return any(target.lower() in g['name'].lower() for g in x if 'name' in g)\n    except Exception:\n        return 0\nfor g in ['Comedy', 'Action', 'Drama', 'Animation', 'Family', 'Science Fiction']:\n    df[f'genre_{g.lower().replace(\" \", \"_\")}'] = df['genres'].apply(lambda x: has_genre(x, g))\n\n# (Collection name present)\n# Usefulness: Certain collection names (e.g. 'Lord of the Rings') are highly correlated with revenue.\ndef extract_collection_name(val):\n    try:\n        if pd.isnull(val):\n            return ''\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        if isinstance(x, dict) and 'name' in x:\n            return x['name']\n        if isinstance(x, list) and x and 'name' in x[0]:\n            return x[0]['name']\n        return ''\n    except Exception:\n        return ''\ndf['collection_name'] = df['belongs_to_collection'].apply(extract_collection_name)\n\n# (Title length and original title length)\n# Usefulness: Title length can relate to marketing style and appeal.\ndf['title_length'] = df['title'].fillna('').apply(lambda x: len(str(x)))\ndf['original_title_length'] = df['original_title'].fillna('').apply(lambda x: len(str(x)))\n\n# (Release in top 5 months for box office: May, June, July, November, December)\n# Usefulness: Blockbusters are released in these months.\ndf['is_blockbuster_month'] = df['release_month'].isin([5, 6, 7, 11, 12]).astype(int)\n# (Director name)\n# Usefulness: Certain directors have a \"brand\" and consistently high/low revenue, useful as a categorical feature.\n# Input samples: 'crew': [\"[{'credit_id': ... 'job': 'Director', 'name': 'David Fincher', ...}]\", ...]\ndef extract_crew_job_name(crew_str, job_title):\n    import ast\n    try:\n        if pd.isnull(crew_str): return ''\n        crew = ast.literal_eval(crew_str) if isinstance(crew_str, str) else crew_str\n        for member in crew:\n            if 'job' in member and str(member['job']).lower() == job_title.lower():\n                return member['name']\n        return ''\n    except Exception:\n        return ''\ndf['director_name'] = df['crew'].apply(lambda x: extract_crew_job_name(x, 'Director'))\n\n# (Screenplay writer name)\n# Usefulness: Well-known writers (e.g. for adaptations or bestsellers) can influence box office.\n# Input samples: 'crew': [\"[{'job': 'Screenplay', ...}, ...]\", ...]\ndf['screenplay_writer'] = df['crew'].apply(lambda x: extract_crew_job_name(x, 'Screenplay'))\n\n# (Director of Photography)\n# Usefulness: Renowned cinematographers often work on higher budget/ambitious movies.\n# Input samples: 'crew': [\"[{'job': 'Director of Photography', ...}, ...]\", ...]\ndf['director_of_photography'] = df['crew'].apply(lambda x: extract_crew_job_name(x, 'Director of Photography'))\n\n# (Original Music Composer)\n# Usefulness: Famous composers work on high-profile projects, and musical score grandeur can correlate with revenue.\n# Input samples: 'crew': [\"[{'job': 'Original Music Composer', ...}, ...]\", ...]\ndf['original_music_composer'] = df['crew'].apply(lambda x: extract_crew_job_name(x, 'Original Music Composer'))\n\n# (Art Director)\n# Usefulness: Art directors can indicate the production scale and visual ambition.\n# Input samples: 'crew': [\"[{'job': 'Art Direction', ...}, ...]\", ...]\ndf['art_director'] = df['crew'].apply(lambda x: extract_crew_job_name(x, 'Art Direction'))\n\n# (Is sequel/prequel/remake/part number in title)\n# Usefulness: Sequels, prequels, and remakes have built-in audience and often larger revenue.\n# Input samples: 'title': ['The Lord of the Rings: The Two Towers', 'Unforgettable', 'The Best Movie 3-DE']\nimport re\ndef has_sequel_word(title):\n    if pd.isnull(title): return 0\n    sequel_words = ['II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Part', 'Chapter', 'Returns', 'Revenge', 'Begins']\n    title_str = str(title).upper()\n    if re.search(r'\b(' + '|'.join(sequel_words) + r')\b', title_str):\n        return 1\n    return 0\ndf['is_sequel_or_part'] = df['title'].apply(has_sequel_word)\n\n# (Number of genres that are \"family\", \"adventure\", \"animation\")\n# Usefulness: These genres have consistent family/young audience appeal.\ndef count_target_genres(genres, targets=['Family', 'Adventure', 'Animation']):\n    import ast\n    try:\n        if pd.isnull(genres): return 0\n        x = ast.literal_eval(genres) if isinstance(genres, str) else genres\n        return sum(1 for g in x if 'name' in g and g['name'] in targets)\n    except: return 0\ndf['num_family_adventure_animation'] = df['genres'].apply(count_target_genres)\n\n# (Cast star power: max cast_id, mean cast_id, std cast_id)\n# Usefulness: Lower cast_id (top-billed) sometimes means more famous actors. Distribution of cast_id can reflect star power.\ndef cast_id_stats(val, stat='max'):\n    import ast\n    try:\n        if pd.isnull(val): return np.nan\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        ids = [m['cast_id'] for m in x if 'cast_id' in m and isinstance(m['cast_id'], int)]\n        if not ids: return np.nan\n        if stat == 'max': return np.max(ids)\n        if stat == 'mean': return np.mean(ids)\n        if stat == 'std': return np.std(ids)\n    except: return np.nan\ndf['cast_id_max'] = df['cast'].apply(lambda x: cast_id_stats(x, 'max'))\ndf['cast_id_mean'] = df['cast'].apply(lambda x: cast_id_stats(x, 'mean'))\ndf['cast_id_std'] = df['cast'].apply(lambda x: cast_id_stats(x, 'std'))\n\n# (Number of keywords containing \"based on\" or \"novel\")\n# Usefulness: Based on book/true story often means built-in audience, higher anticipation.\ndef keywords_basedon_novel(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for k in x if 'name' in k and ('based on' in k['name'].lower() or 'novel' in k['name'].lower()))\n    except: return 0\ndf['keywords_basedon_novel'] = df['Keywords'].apply(keywords_basedon_novel)\n\n# (Number of keywords containing \"love\", \"romance\", \"war\", \"crime\", \"future\")\n# Usefulness: Certain themes (love, war, crime...) are overrepresented in big hits.\nimportant_themes = ['love', 'romance', 'war', 'crime', 'future']\nfor theme in important_themes:\n    df[f'keywords_theme_{theme}'] = df['Keywords'].apply(lambda x: 0 if pd.isnull(x) else (\n        sum(1 for k in (ast.literal_eval(x) if isinstance(x, str) else x)\n            if 'name' in k and theme in k['name'].lower())\n        if isinstance(x, str) or isinstance(x, list) else 0\n    ))\n\n# (Cast: max order, mean order, std order)\n# Usefulness: 'order' field in cast indicates on-screen prominence, with lower value for main actors.\ndef cast_order_stats(val, stat='max'):\n    import ast\n    try:\n        if pd.isnull(val): return np.nan\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        orders = [m['order'] for m in x if 'order' in m and isinstance(m['order'], int)]\n        if not orders: return np.nan\n        if stat == 'max': return np.max(orders)\n        if stat == 'mean': return np.mean(orders)\n        if stat == 'std': return np.std(orders)\n    except: return np.nan\ndf['cast_order_max'] = df['cast'].apply(lambda x: cast_order_stats(x, 'max'))\ndf['cast_order_mean'] = df['cast'].apply(lambda x: cast_order_stats(x, 'mean'))\ndf['cast_order_std'] = df['cast'].apply(lambda x: cast_order_stats(x, 'std'))\n\n# (Number of crew with job 'Producer')\n# Usefulness: More producers can indicate higher budget or broader distribution effort.\ndef count_producers(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for m in x if 'job' in m and 'producer' in str(m['job']).lower())\n    except: return 0\ndf['num_producers'] = df['crew'].apply(count_producers)\n\n# (Is homepage official (contains \"official\"))\n# Usefulness: Official homepages are more common for major releases.\ndf['is_official_homepage'] = df['homepage'].fillna('').apply(lambda x: int('official' in x.lower()))\n\n# (Production companies contains major studio)\n# Usefulness: Major studios (Disney, Universal, Warner, Paramount, Fox, Sony, Columbia) have broader reach and higher average revenue.\nmajors = ['disney', 'universal', 'warner', 'paramount', 'fox', 'sony', 'columbia', 'dreamworks', 'lionsgate', 'new line', 'miramax', 'mgm']\ndef has_major_studio(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        names = [c['name'].lower() for c in x if 'name' in c]\n        return int(any(any(m in n for m in majors) for n in names))\n    except: return 0\ndf['has_major_studio'] = df['production_companies'].apply(has_major_studio)\n\n# (Production countries contains 'United States of America')\n# Usefulness: US-produced films tend to have higher global box office.\ndef is_us_production(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return int(any('United States of America' == c.get('name', '') for c in x))\n    except: return 0\ndf['is_us_production'] = df['production_countries'].apply(is_us_production)\n\n# (Count of genres \"thriller\" and \"romance\")\n# Usefulness: Thrillers and romances have distinct audience sizes and box office patterns.\ndf['genre_thriller'] = df['genres'].apply(lambda x: has_genre(x, 'Thriller'))\ndf['genre_romance'] = df['genres'].apply(lambda x: has_genre(x, 'Romance'))\n# (Crew: number of jobs with \"Sound\" or \"Music\")\n# Usefulness: Large sound/music departments can indicate big productions with significant musical elements, which may affect revenue.\n# Input samples: 'crew': [\"[{'department': 'Sound', ...}, ...]\", ...]\ndef count_crew_music_sound(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for m in x if 'department' in m and str(m['department']).lower() in ['sound', 'music'])\n    except: return 0\ndf['num_crew_music_sound'] = df['crew'].apply(count_crew_music_sound)\n\n# (Number of \"executive producer\" in crew)\n# Usefulness: Big productions often have several executive producers, correlating with budget/revenue.\ndef count_executive_producers(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for m in x if 'job' in m and 'executive producer' in str(m['job']).lower())\n    except: return 0\ndf['num_executive_producers'] = df['crew'].apply(count_executive_producers)\n\n# (Number of \"writer\" jobs in crew)\n# Usefulness: Multiple writers can suggest adaptations or important stories, possibly affecting revenue.\ndef count_writers(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for m in x if 'job' in m and 'writer' in str(m['job']).lower())\n    except: return 0\ndf['num_writers'] = df['crew'].apply(count_writers)\n\n# (Number of lead actors (order <=2) in cast)\n# Usefulness: More top-billed actors may indicate ensemble casts, which can be a box office draw.\ndef count_lead_actors(cast_val):\n    import ast\n    try:\n        if pd.isnull(cast_val): return 0\n        x = ast.literal_eval(cast_val) if isinstance(cast_val, str) else cast_val\n        return sum(1 for m in x if 'order' in m and isinstance(m['order'], int) and m['order'] <= 2)\n    except: return 0\ndf['num_lead_actors'] = df['cast'].apply(count_lead_actors)\n\n# (Cast/crew ratio)\n# Usefulness: High cast-to-crew ratio can indicate character-driven films; low ratio may indicate technical or effects-driven films.\ndf['cast_crew_ratio'] = df.apply(lambda row: row['num_cast'] / row['num_crew'] if row['num_crew'] > 0 else 0, axis=1)\n\n# (Number of production companies with \"Entertainment\")\n# Usefulness: \"Entertainment\" companies often involved in wider distribution/production.\ndef count_entertainment_companies(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for c in x if 'name' in c and 'entertainment' in c['name'].lower())\n    except: return 0\ndf['num_entertainment_companies'] = df['production_companies'].apply(count_entertainment_companies)\n\n# (Number of unique jobs in crew)\n# Usefulness: Measures diversity/complexity of production, which correlates with project size.\ndef count_unique_crew_jobs(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return len(set(m['job'] for m in x if 'job' in m))\n    except: return 0\ndf['num_unique_crew_jobs'] = df['crew'].apply(count_unique_crew_jobs)\n\n# (Number of unique departments in crew)\n# Usefulness: Wider range of departments reflects scale and ambition of the project.\ndef count_unique_crew_departments(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return len(set(m['department'] for m in x if 'department' in m))\n    except: return 0\ndf['num_unique_crew_departments'] = df['crew'].apply(count_unique_crew_departments)\n\n# (Number of female producers)\n# Usefulness: Gender diversity among producers could be linked to budget/production style.\ndef count_female_producers(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for m in x if 'gender' in m and m['gender'] == 1 and 'producer' in str(m.get('job', '')).lower())\n    except: return 0\ndf['num_female_producers'] = df['crew'].apply(count_female_producers)\n\n# (Number of male directors)\n# Usefulness: Gender of director, as a categorical/real feature.\ndef count_male_directors(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for m in x if 'gender' in m and m['gender'] == 2 and str(m.get('job', '')).lower() == \"director\")\n    except: return 0\ndf['num_male_directors'] = df['crew'].apply(count_male_directors)\n\n# (Number of production countries that are in Europe)\n# Usefulness: European backing can affect distribution/revenue potential.\neurope_countries = {'France', 'United Kingdom', 'Germany', 'Italy', 'Spain', 'Poland', 'Belgium', 'Norway', 'Sweden', 'Netherlands',\n                    'Luxembourg', 'Switzerland', 'Ireland', 'Austria', 'Denmark', 'Russia', 'Finland', 'Czech Republic', 'Hungary', 'Romania',\n                    'Bulgaria', 'Greece', 'Portugal', 'Slovakia', 'Croatia', 'Slovenia', 'Ukraine', 'Serbia'}\ndef count_europe_production_countries(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for c in x if 'name' in c and c['name'] in europe_countries)\n    except: return 0\ndf['num_europe_production_countries'] = df['production_countries'].apply(count_europe_production_countries)\n\n# (Number of genres that are 'biography' or 'documentary')\n# Usefulness: These genres often have lower average revenue.\ndef count_bio_doc_genres(genres):\n    import ast\n    try:\n        if pd.isnull(genres): return 0\n        x = ast.literal_eval(genres) if isinstance(genres, str) else genres\n        return sum(1 for g in x if 'name' in g and g['name'].lower() in ['biography', 'documentary'])\n    except: return 0\ndf['num_bio_doc_genres'] = df['genres'].apply(count_bio_doc_genres)\n\n# (Number of keywords containing \"based on true story\")\n# Usefulness: True story movies often perform differently at box office.\ndef keywords_basedon_true_story(val):\n    import ast\n    try:\n        if pd.isnull(val): return 0\n        x = ast.literal_eval(val) if isinstance(val, str) else val\n        return sum(1 for k in x if 'name' in k and 'based on true story' in k['name'].lower())\n    except: return 0\ndf['keywords_basedon_true_story'] = df['Keywords'].apply(keywords_basedon_true_story)\n"
  ]
}
