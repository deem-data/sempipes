"{\"sempipes_config\": {\"llm_for_code_generation\": {\"name\": \"gemini/gemini-2.5-flash\", \"parameters\": {\"temperature\": 2.0}}, \"llm_for_batch_processing\": {\"name\": \"ollama/gpt-oss:120b\", \"parameters\": {\"api_base\": \"http://localhost:11434\", \"temperature\": 0.0}}, \"batch_size_for_batch_processing\": 20}, \"optimizer_args\": {\"operator_name\": \"house_features\", \"num_trials\": 24, \"scoring\": \"neg_root_mean_squared_error\", \"cv\": \"10\", \"num_hpo_iterations_per_trial\": 10}, \"outcomes\": [{\"search_node\": {\"trial\": 0, \"parent_trial\": null, \"memory\": [], \"predefined_state\": {\"generated_code\": []}, \"parent_score\": null, \"inspirations\": []}, \"state\": {\"generated_code\": []}, \"score\": -0.14098390849032688, \"memory_update\": \"\"}, {\"search_node\": {\"trial\": 1, \"parent_trial\": 0, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}], \"predefined_state\": null, \"parent_score\": -0.14098390849032688, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\"]}, \"score\": -0.13304342646742578, \"memory_update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\"}, {\"search_node\": {\"trial\": 2, \"parent_trial\": 1, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}], \"predefined_state\": null, \"parent_score\": -0.13304342646742578, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\"]}, \"score\": -0.1346066602590829, \"memory_update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\"}, {\"search_node\": {\"trial\": 3, \"parent_trial\": 1, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}], \"predefined_state\": null, \"parent_score\": -0.13304342646742578, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"# (Total Combined Porch and Deck Square Footage)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Presence of a Pool: Binary feature, 1 if PoolArea > 0, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Presence of a Garage: Binary feature, 1 if GarageCars > 0, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Presence of a Basement: Binary feature, 1 if TotalBsmtSF > 0, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if YearRemodAdd is different from YearBuilt, indicating a remodeling event)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Living Area to Lot Area Ratio: Ratio of above ground living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (Average Square Footage Per Room Above Ground: Average size of rooms above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Add a small constant to avoid division by zero, although TotRmsAbvGrd is typically > 0 for living areas.\\ndf['SqFtPerRoomAbvGr'] = df['GrLivArea'] / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Masonry Veneer Presence: Binary feature, 1 if MasVnrArea > 0, 0 otherwise)\\n# Impute MasVnrArea NaNs to 0 before comparison.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0, 207.0]\\ndf['MasVnrPresence'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 for consistency if any were present)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1} # Re-define as it's not inherited from previous block\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_map).fillna(0)\\n\\n# (Total Living Area Quality Score: Product of TotalSF and OverallQual as a proxy for combined size and perceived quality)\\n# Input samples: 'TotalSF': [2008, 3860, 2216], 'OverallQual': [5, 8, 5] (TotalSF calculated in prev block)\\ndf['TotalLivAreaQual'] = df['TotalSF'] * df['OverallQual']\"]}, \"score\": -0.13822797877857976, \"memory_update\": \"# (Total Combined Porch and Deck Square Footage)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Presence of a Pool: Binary feature, 1 if PoolArea > 0, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Presence of a Garage: Binary feature, 1 if GarageCars > 0, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Presence of a Basement: Binary feature, 1 if TotalBsmtSF > 0, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if YearRemodAdd is different from YearBuilt, indicating a remodeling event)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Living Area to Lot Area Ratio: Ratio of above ground living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (Average Square Footage Per Room Above Ground: Average size of rooms above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Add a small constant to avoid division by zero, although TotRmsAbvGrd is typically > 0 for living areas.\\ndf['SqFtPerRoomAbvGr'] = df['GrLivArea'] / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Masonry Veneer Presence: Binary feature, 1 if MasVnrArea > 0, 0 otherwise)\\n# Impute MasVnrArea NaNs to 0 before comparison.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0, 207.0]\\ndf['MasVnrPresence'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 for consistency if any were present)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1} # Re-define as it's not inherited from previous block\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_map).fillna(0)\\n\\n# (Total Living Area Quality Score: Product of TotalSF and OverallQual as a proxy for combined size and perceived quality)\\n# Input samples: 'TotalSF': [2008, 3860, 2216], 'OverallQual': [5, 8, 5] (TotalSF calculated in prev block)\\ndf['TotalLivAreaQual'] = df['TotalSF'] * df['OverallQual']\"}, {\"search_node\": {\"trial\": 4, \"parent_trial\": 2, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}], \"predefined_state\": null, \"parent_score\": -0.1346066602590829, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\"]}, \"score\": -0.13231140571525984, \"memory_update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\"}, {\"search_node\": {\"trial\": 5, \"parent_trial\": 3, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"# (Total Combined Porch and Deck Square Footage)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Presence of a Pool: Binary feature, 1 if PoolArea > 0, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Presence of a Garage: Binary feature, 1 if GarageCars > 0, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Presence of a Basement: Binary feature, 1 if TotalBsmtSF > 0, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if YearRemodAdd is different from YearBuilt, indicating a remodeling event)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Living Area to Lot Area Ratio: Ratio of above ground living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (Average Square Footage Per Room Above Ground: Average size of rooms above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Add a small constant to avoid division by zero, although TotRmsAbvGrd is typically > 0 for living areas.\\ndf['SqFtPerRoomAbvGr'] = df['GrLivArea'] / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Masonry Veneer Presence: Binary feature, 1 if MasVnrArea > 0, 0 otherwise)\\n# Impute MasVnrArea NaNs to 0 before comparison.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0, 207.0]\\ndf['MasVnrPresence'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 for consistency if any were present)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1} # Re-define as it's not inherited from previous block\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_map).fillna(0)\\n\\n# (Total Living Area Quality Score: Product of TotalSF and OverallQual as a proxy for combined size and perceived quality)\\n# Input samples: 'TotalSF': [2008, 3860, 2216], 'OverallQual': [5, 8, 5] (TotalSF calculated in prev block)\\ndf['TotalLivAreaQual'] = df['TotalSF'] * df['OverallQual']\", \"score\": -0.13822797877857976}], \"predefined_state\": null, \"parent_score\": -0.13822797877857976, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"# (Total Outdoor Square Footage: sum of all porch and deck areas)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Has Pool: Binary feature, 1 if PoolArea is greater than 0, indicating the presence of a pool, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Basement: Binary feature, 1 if TotalBsmtSF is greater than 0, indicating the presence of a basement, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Garage: Binary feature, 1 if GarageCars is greater than 0, indicating the presence of a garage, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1, 2, 2]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if the YearBuilt is different from YearRemodAdd, indicating the house was remodeled)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (No Alley Access: Binary feature, 1 if Alley column has a NaN value, indicating no alley access, 0 otherwise)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['NoAlleyAccess'] = df['Alley'].isnull().astype(int)\\n\\n# (Has Fence: Binary feature, 1 if Fence column is not NaN, indicating the presence of a fence, 0 otherwise)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, 'MnPrv']\\ndf['HasFence'] = df['Fence'].notnull().astype(int)\\n\\n# (MasVnrType_None: Binary feature, 1 if MasVnrType is NaN (None), indicating no masonry veneer, 0 otherwise)\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\ndf['MasVnrType_None'] = (df['MasVnrType'].isnull()).astype(int)\\n\\n# (Age Squared: Square of the house's age at sale to capture potential non-linear relationships with price)\\n# Input samples: 'HouseAge': [48, 13, 77, 6, 53] (HouseAge column should exist from previous block)\\ndf['AgeSquared'] = df['HouseAge'] ** 2\\n\\n# (Lot Frontage Imputed: LotFrontage with missing values filled using the median to provide a complete numeric feature)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\"]}, \"score\": -0.1333106854611686, \"memory_update\": \"# (Total Outdoor Square Footage: sum of all porch and deck areas)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Has Pool: Binary feature, 1 if PoolArea is greater than 0, indicating the presence of a pool, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Basement: Binary feature, 1 if TotalBsmtSF is greater than 0, indicating the presence of a basement, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Garage: Binary feature, 1 if GarageCars is greater than 0, indicating the presence of a garage, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1, 2, 2]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if the YearBuilt is different from YearRemodAdd, indicating the house was remodeled)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (No Alley Access: Binary feature, 1 if Alley column has a NaN value, indicating no alley access, 0 otherwise)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['NoAlleyAccess'] = df['Alley'].isnull().astype(int)\\n\\n# (Has Fence: Binary feature, 1 if Fence column is not NaN, indicating the presence of a fence, 0 otherwise)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, 'MnPrv']\\ndf['HasFence'] = df['Fence'].notnull().astype(int)\\n\\n# (MasVnrType_None: Binary feature, 1 if MasVnrType is NaN (None), indicating no masonry veneer, 0 otherwise)\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\ndf['MasVnrType_None'] = (df['MasVnrType'].isnull()).astype(int)\\n\\n# (Age Squared: Square of the house's age at sale to capture potential non-linear relationships with price)\\n# Input samples: 'HouseAge': [48, 13, 77, 6, 53] (HouseAge column should exist from previous block)\\ndf['AgeSquared'] = df['HouseAge'] ** 2\\n\\n# (Lot Frontage Imputed: LotFrontage with missing values filled using the median to provide a complete numeric feature)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\"}, {\"search_node\": {\"trial\": 6, \"parent_trial\": 0, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}], \"predefined_state\": null, \"parent_score\": -0.14098390849032688, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total_Living_SF: Total finished living area in square feet (above ground + basement))\\n# Input samples: 'GrLivArea': [np.int64(1144), np.int64(2520), np.int64(1520)], 'TotalBsmtSF': [np.int64(864), np.int64(1338), np.int64(793)]\\ndf['Total_Living_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total_Bathrooms: Total number of full and half bathrooms, with half baths counted as 0.5)\\n# Input samples: 'BsmtFullBath': [np.int64(1), np.int64(1), np.int64(0)], 'BsmtHalfBath': [np.int64(0), np.int64(0), np.int64(0)], 'FullBath': [np.int64(1), np.int64(2), np.int64(1)], 'HalfBath': [np.int64(0), np.int64(1), np.int64(0)]\\ndf['Total_Bathrooms'] = df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath'] + df['FullBath'] + 0.5 * df['HalfBath']\\n\\n# (Years_Old: Age of the house at the time of sale)\\n# Input samples: 'YrSold': [np.int64(2009), np.int64(2006), np.int64(2009)], 'YearBuilt': [np.int64(1961), np.int64(1993), np.int64(1932)]\\ndf['Years_Old'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years_Since_Last_Change: Years since the last major remodeling or construction)\\n# Input samples: 'YrSold': [np.int64(2009), np.int64(2006), np.int64(2009)], 'YearRemodAdd': [np.int64(1983), np.int64(1993), np.int64(2000)]\\ndf['Years_Since_Last_Change'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Has_MasVnr: Binary indicator if the house has masonry veneer)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['Has_MasVnr'] = df['MasVnrArea'].fillna(0).apply(lambda x: 1 if x > 0 else 0)\\n\\n# (Overall_Quality_Product: A composite score for the overall quality and condition of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Overall_Quality_Product'] = df['OverallQual'] * df['OverallCond']\"]}, \"score\": -0.13366084403420786, \"memory_update\": \"# (Total_Living_SF: Total finished living area in square feet (above ground + basement))\\n# Input samples: 'GrLivArea': [np.int64(1144), np.int64(2520), np.int64(1520)], 'TotalBsmtSF': [np.int64(864), np.int64(1338), np.int64(793)]\\ndf['Total_Living_SF'] = df['GrLivArea'] + df['TotalBsmtSF']\\n\\n# (Total_Bathrooms: Total number of full and half bathrooms, with half baths counted as 0.5)\\n# Input samples: 'BsmtFullBath': [np.int64(1), np.int64(1), np.int64(0)], 'BsmtHalfBath': [np.int64(0), np.int64(0), np.int64(0)], 'FullBath': [np.int64(1), np.int64(2), np.int64(1)], 'HalfBath': [np.int64(0), np.int64(1), np.int64(0)]\\ndf['Total_Bathrooms'] = df['BsmtFullBath'] + 0.5 * df['BsmtHalfBath'] + df['FullBath'] + 0.5 * df['HalfBath']\\n\\n# (Years_Old: Age of the house at the time of sale)\\n# Input samples: 'YrSold': [np.int64(2009), np.int64(2006), np.int64(2009)], 'YearBuilt': [np.int64(1961), np.int64(1993), np.int64(1932)]\\ndf['Years_Old'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years_Since_Last_Change: Years since the last major remodeling or construction)\\n# Input samples: 'YrSold': [np.int64(2009), np.int64(2006), np.int64(2009)], 'YearRemodAdd': [np.int64(1983), np.int64(1993), np.int64(2000)]\\ndf['Years_Since_Last_Change'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Has_MasVnr: Binary indicator if the house has masonry veneer)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0]\\ndf['Has_MasVnr'] = df['MasVnrArea'].fillna(0).apply(lambda x: 1 if x > 0 else 0)\\n\\n# (Overall_Quality_Product: A composite score for the overall quality and condition of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['Overall_Quality_Product'] = df['OverallQual'] * df['OverallCond']\"}, {\"search_node\": {\"trial\": 7, \"parent_trial\": 5, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"# (Total Combined Porch and Deck Square Footage)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Presence of a Pool: Binary feature, 1 if PoolArea > 0, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Presence of a Garage: Binary feature, 1 if GarageCars > 0, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Presence of a Basement: Binary feature, 1 if TotalBsmtSF > 0, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if YearRemodAdd is different from YearBuilt, indicating a remodeling event)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Living Area to Lot Area Ratio: Ratio of above ground living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (Average Square Footage Per Room Above Ground: Average size of rooms above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Add a small constant to avoid division by zero, although TotRmsAbvGrd is typically > 0 for living areas.\\ndf['SqFtPerRoomAbvGr'] = df['GrLivArea'] / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Masonry Veneer Presence: Binary feature, 1 if MasVnrArea > 0, 0 otherwise)\\n# Impute MasVnrArea NaNs to 0 before comparison.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0, 207.0]\\ndf['MasVnrPresence'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 for consistency if any were present)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1} # Re-define as it's not inherited from previous block\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_map).fillna(0)\\n\\n# (Total Living Area Quality Score: Product of TotalSF and OverallQual as a proxy for combined size and perceived quality)\\n# Input samples: 'TotalSF': [2008, 3860, 2216], 'OverallQual': [5, 8, 5] (TotalSF calculated in prev block)\\ndf['TotalLivAreaQual'] = df['TotalSF'] * df['OverallQual']\", \"score\": -0.13822797877857976}, {\"update\": \"# (Total Outdoor Square Footage: sum of all porch and deck areas)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Has Pool: Binary feature, 1 if PoolArea is greater than 0, indicating the presence of a pool, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Basement: Binary feature, 1 if TotalBsmtSF is greater than 0, indicating the presence of a basement, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Garage: Binary feature, 1 if GarageCars is greater than 0, indicating the presence of a garage, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1, 2, 2]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if the YearBuilt is different from YearRemodAdd, indicating the house was remodeled)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (No Alley Access: Binary feature, 1 if Alley column has a NaN value, indicating no alley access, 0 otherwise)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['NoAlleyAccess'] = df['Alley'].isnull().astype(int)\\n\\n# (Has Fence: Binary feature, 1 if Fence column is not NaN, indicating the presence of a fence, 0 otherwise)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, 'MnPrv']\\ndf['HasFence'] = df['Fence'].notnull().astype(int)\\n\\n# (MasVnrType_None: Binary feature, 1 if MasVnrType is NaN (None), indicating no masonry veneer, 0 otherwise)\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\ndf['MasVnrType_None'] = (df['MasVnrType'].isnull()).astype(int)\\n\\n# (Age Squared: Square of the house's age at sale to capture potential non-linear relationships with price)\\n# Input samples: 'HouseAge': [48, 13, 77, 6, 53] (HouseAge column should exist from previous block)\\ndf['AgeSquared'] = df['HouseAge'] ** 2\\n\\n# (Lot Frontage Imputed: LotFrontage with missing values filled using the median to provide a complete numeric feature)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\", \"score\": -0.1333106854611686}], \"predefined_state\": null, \"parent_score\": -0.1333106854611686, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"# (Binary Indicator for Missing Lot Frontage: 1 if LotFrontage is missing, 0 otherwise)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0]\\ndf['IsLotFrontageMissing'] = df['LotFrontage'].isnull().astype(int)\\n\\n# (Binary Indicator for No Alley Access: 1 if Alley is missing, 0 otherwise)\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['NoAlleyAccess'] = df['Alley'].isnull().astype(int)\\n\\n# (Binary Indicator for Has Fence: 1 if Fence is not missing, 0 otherwise)\\n# Input samples: 'Fence': ['GdWo', nan, nan]\\ndf['HasFence'] = df['Fence'].notnull().astype(int)\\n\\n# (Binary Indicator for No Masonry Veneer Type: 1 if MasVnrType is missing (None), 0 otherwise)\\n# Input samples: 'MasVnrType': [nan, nan, 'BrkFace']\\ndf['NoMasVnrType'] = df['MasVnrType'].isnull().astype(int)\\n\\n# (Ratio: Living Area to Lot Area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['GrLivArea_Per_LotArea'] = df['GrLivArea'] / df['LotArea']\\n\\n# (Interaction: Total Square Footage multiplied by Overall Quality)\\n# Input samples: 'TotalSF': [1144+0+864, 1352+1168+1338, 848+672+793], 'OverallQual': [5, 8, 5] (TotalSF from first accepted block)\\ndf['TotalSF_x_OverallQual'] = df['TotalSF'] * df['OverallQual']\\n\\n# (Interaction: Overall Condition multiplied by House Age)\\n# Input samples: 'OverallCond': [6, 7, 5], 'HouseAge': [48, 13, 77] (HouseAge from first accepted block)\\ndf['OverallCond_x_HouseAge'] = df['OverallCond'] * df['HouseAge']\\n\\n# Define quality mapping (needed for this block's scope)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Encoded Categorical: Garage Quality - mapped to numeric, NaN for no garage treated as 0)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_map).fillna(0)\\n\\n# (Encoded Categorical: Garage Condition - mapped to numeric, NaN for no garage treated as 0)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_map).fillna(0)\\n\\n# (Age of the house since its most recent major update (construction or remodel))\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['AgeAtSale_LastUpdate'] = df['YrSold'] - df[['YearBuilt', 'YearRemodAdd']].max(axis=1)\"]}, \"score\": -0.13748040646229137, \"memory_update\": \"# (Binary Indicator for Missing Lot Frontage: 1 if LotFrontage is missing, 0 otherwise)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0]\\ndf['IsLotFrontageMissing'] = df['LotFrontage'].isnull().astype(int)\\n\\n# (Binary Indicator for No Alley Access: 1 if Alley is missing, 0 otherwise)\\n# Input samples: 'Alley': [nan, nan, 'Pave']\\ndf['NoAlleyAccess'] = df['Alley'].isnull().astype(int)\\n\\n# (Binary Indicator for Has Fence: 1 if Fence is not missing, 0 otherwise)\\n# Input samples: 'Fence': ['GdWo', nan, nan]\\ndf['HasFence'] = df['Fence'].notnull().astype(int)\\n\\n# (Binary Indicator for No Masonry Veneer Type: 1 if MasVnrType is missing (None), 0 otherwise)\\n# Input samples: 'MasVnrType': [nan, nan, 'BrkFace']\\ndf['NoMasVnrType'] = df['MasVnrType'].isnull().astype(int)\\n\\n# (Ratio: Living Area to Lot Area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['GrLivArea_Per_LotArea'] = df['GrLivArea'] / df['LotArea']\\n\\n# (Interaction: Total Square Footage multiplied by Overall Quality)\\n# Input samples: 'TotalSF': [1144+0+864, 1352+1168+1338, 848+672+793], 'OverallQual': [5, 8, 5] (TotalSF from first accepted block)\\ndf['TotalSF_x_OverallQual'] = df['TotalSF'] * df['OverallQual']\\n\\n# (Interaction: Overall Condition multiplied by House Age)\\n# Input samples: 'OverallCond': [6, 7, 5], 'HouseAge': [48, 13, 77] (HouseAge from first accepted block)\\ndf['OverallCond_x_HouseAge'] = df['OverallCond'] * df['HouseAge']\\n\\n# Define quality mapping (needed for this block's scope)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Encoded Categorical: Garage Quality - mapped to numeric, NaN for no garage treated as 0)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_map).fillna(0)\\n\\n# (Encoded Categorical: Garage Condition - mapped to numeric, NaN for no garage treated as 0)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_map).fillna(0)\\n\\n# (Age of the house since its most recent major update (construction or remodel))\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['AgeAtSale_LastUpdate'] = df['YrSold'] - df[['YearBuilt', 'YearRemodAdd']].max(axis=1)\"}, {\"search_node\": {\"trial\": 8, \"parent_trial\": 5, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"# (Total Combined Porch and Deck Square Footage)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Presence of a Pool: Binary feature, 1 if PoolArea > 0, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Presence of a Garage: Binary feature, 1 if GarageCars > 0, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Presence of a Basement: Binary feature, 1 if TotalBsmtSF > 0, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if YearRemodAdd is different from YearBuilt, indicating a remodeling event)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (Living Area to Lot Area Ratio: Ratio of above ground living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivAreaToLotAreaRatio'] = df['GrLivArea'] / df['LotArea']\\n\\n# (Average Square Footage Per Room Above Ground: Average size of rooms above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Add a small constant to avoid division by zero, although TotRmsAbvGrd is typically > 0 for living areas.\\ndf['SqFtPerRoomAbvGr'] = df['GrLivArea'] / (df['TotRmsAbvGrd'] + 1e-6)\\n\\n# (Masonry Veneer Presence: Binary feature, 1 if MasVnrArea > 0, 0 otherwise)\\n# Impute MasVnrArea NaNs to 0 before comparison.\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0, 207.0]\\ndf['MasVnrPresence'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 for consistency if any were present)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1} # Re-define as it's not inherited from previous block\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_map).fillna(0)\\n\\n# (Total Living Area Quality Score: Product of TotalSF and OverallQual as a proxy for combined size and perceived quality)\\n# Input samples: 'TotalSF': [2008, 3860, 2216], 'OverallQual': [5, 8, 5] (TotalSF calculated in prev block)\\ndf['TotalLivAreaQual'] = df['TotalSF'] * df['OverallQual']\", \"score\": -0.13822797877857976}, {\"update\": \"# (Total Outdoor Square Footage: sum of all porch and deck areas)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Has Pool: Binary feature, 1 if PoolArea is greater than 0, indicating the presence of a pool, 0 otherwise)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Basement: Binary feature, 1 if TotalBsmtSF is greater than 0, indicating the presence of a basement, 0 otherwise)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894]\\ndf['HasBasement'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Has Garage: Binary feature, 1 if GarageCars is greater than 0, indicating the presence of a garage, 0 otherwise)\\n# Input samples: 'GarageCars': [1, 3, 1, 2, 2]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Was Remodeled: Binary feature, 1 if the YearBuilt is different from YearRemodAdd, indicating the house was remodeled)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearBuilt'] != df['YearRemodAdd']).astype(int)\\n\\n# (No Alley Access: Binary feature, 1 if Alley column has a NaN value, indicating no alley access, 0 otherwise)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['NoAlleyAccess'] = df['Alley'].isnull().astype(int)\\n\\n# (Has Fence: Binary feature, 1 if Fence column is not NaN, indicating the presence of a fence, 0 otherwise)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, 'MnPrv']\\ndf['HasFence'] = df['Fence'].notnull().astype(int)\\n\\n# (MasVnrType_None: Binary feature, 1 if MasVnrType is NaN (None), indicating no masonry veneer, 0 otherwise)\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\ndf['MasVnrType_None'] = (df['MasVnrType'].isnull()).astype(int)\\n\\n# (Age Squared: Square of the house's age at sale to capture potential non-linear relationships with price)\\n# Input samples: 'HouseAge': [48, 13, 77, 6, 53] (HouseAge column should exist from previous block)\\ndf['AgeSquared'] = df['HouseAge'] ** 2\\n\\n# (Lot Frontage Imputed: LotFrontage with missing values filled using the median to provide a complete numeric feature)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\", \"score\": -0.1333106854611686}], \"predefined_state\": null, \"parent_score\": -0.1333106854611686, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"# (Total Finished Basement Square Footage: Sum of BsmtFinSF1 and BsmtFinSF2)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Total Bathroom per Square Foot of Living Area: Density of bathrooms)\\n# Input samples: 'TotalBath': [2.0, 3.5, 1.0], 'GrLivArea': [1144, 2520, 1520] (TotalBath calculated in prev block)\\ndf['BathPerSqFt'] = df['TotalBath'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Has Fireplace: Binary feature, 1 if Fireplaces > 0, 0 otherwise)\\n# Input samples: 'Fireplaces': [1, 1, 0, 0, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Is New Construction: Binary feature, 1 if YearBuilt equals YrSold, indicating a brand new house at time of sale)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932, 2003, 1954], 'YrSold': [2009, 2006, 2009, 2007, 2007]\\ndf['IsNewConstruction'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# (Is Remodeled Recently: Binary feature, 1 if YearRemodAdd equals YrSold, indicating a very recent remodel)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000, 2003, 1954], 'YrSold': [2009, 2006, 2009, 2007, 2007]\\ndf['IsRemodeledRecently'] = (df['YearRemodAdd'] == df['YrSold']).astype(int)\\n\\n# (Garage Area per Car: Average garage size per car capacity)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Fillna with 0 for GarageArea to indicate no garage if missing. Use 1 as denominator if GarageCars is 0 to avoid div by zero.\\ndf['GarageAreaPerCar'] = df['GarageArea'].fillna(0) / (df['GarageCars'].replace(0, 1) + 1e-6) # add epsilon to replace\\n\\n# (BsmtQual_TotalSF: Interaction between basement quality and its total size)\\n# Input samples: 'BsmtQual_enc': [3.0, 4.0, 3.0], 'TotalBsmtSF': [864, 1338, 793] (BsmtQual_enc calculated in prev block)\\ndf['BsmtQual_TotalSF'] = df['BsmtQual_enc'] * df['TotalBsmtSF']\\n\\n# (Combined Living Quality Score: Product of GrLivArea and OverallQual for overall living space quality)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]\\ndf['GrLivArea_OverallQual'] = df['GrLivArea'] * df['OverallQual']\\n\\n# (House Age per Remodel Age: Ratio indicating how recently the house was remodeled relative to its age)\\n# Input samples: 'HouseAge': [48, 13, 77], 'RemodAge': [26, 13, 9] (HouseAge, RemodAge calculated in prev block)\\ndf['HouseAge_Per_RemodAge'] = df['HouseAge'] / (df['RemodAge'] + 1e-6)\\n\\n# (MasVnrArea per TotalSF: Density of masonry veneer over total living space, imputing MasVnrArea NaNs to 0)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0], 'TotalSF': [2008, 3860, 2216]\\ndf['MasVnrArea_Per_TotalSF'] = df['MasVnrArea'].fillna(0) / (df['TotalSF'] + 1e-6)\"]}, \"score\": -0.13616654715154244, \"memory_update\": \"# (Total Finished Basement Square Footage: Sum of BsmtFinSF1 and BsmtFinSF2)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinBsmtSF'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Total Bathroom per Square Foot of Living Area: Density of bathrooms)\\n# Input samples: 'TotalBath': [2.0, 3.5, 1.0], 'GrLivArea': [1144, 2520, 1520] (TotalBath calculated in prev block)\\ndf['BathPerSqFt'] = df['TotalBath'] / (df['GrLivArea'] + 1e-6)\\n\\n# (Has Fireplace: Binary feature, 1 if Fireplaces > 0, 0 otherwise)\\n# Input samples: 'Fireplaces': [1, 1, 0, 0, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Is New Construction: Binary feature, 1 if YearBuilt equals YrSold, indicating a brand new house at time of sale)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932, 2003, 1954], 'YrSold': [2009, 2006, 2009, 2007, 2007]\\ndf['IsNewConstruction'] = (df['YearBuilt'] == df['YrSold']).astype(int)\\n\\n# (Is Remodeled Recently: Binary feature, 1 if YearRemodAdd equals YrSold, indicating a very recent remodel)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000, 2003, 1954], 'YrSold': [2009, 2006, 2009, 2007, 2007]\\ndf['IsRemodeledRecently'] = (df['YearRemodAdd'] == df['YrSold']).astype(int)\\n\\n# (Garage Area per Car: Average garage size per car capacity)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Fillna with 0 for GarageArea to indicate no garage if missing. Use 1 as denominator if GarageCars is 0 to avoid div by zero.\\ndf['GarageAreaPerCar'] = df['GarageArea'].fillna(0) / (df['GarageCars'].replace(0, 1) + 1e-6) # add epsilon to replace\\n\\n# (BsmtQual_TotalSF: Interaction between basement quality and its total size)\\n# Input samples: 'BsmtQual_enc': [3.0, 4.0, 3.0], 'TotalBsmtSF': [864, 1338, 793] (BsmtQual_enc calculated in prev block)\\ndf['BsmtQual_TotalSF'] = df['BsmtQual_enc'] * df['TotalBsmtSF']\\n\\n# (Combined Living Quality Score: Product of GrLivArea and OverallQual for overall living space quality)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]\\ndf['GrLivArea_OverallQual'] = df['GrLivArea'] * df['OverallQual']\\n\\n# (House Age per Remodel Age: Ratio indicating how recently the house was remodeled relative to its age)\\n# Input samples: 'HouseAge': [48, 13, 77], 'RemodAge': [26, 13, 9] (HouseAge, RemodAge calculated in prev block)\\ndf['HouseAge_Per_RemodAge'] = df['HouseAge'] / (df['RemodAge'] + 1e-6)\\n\\n# (MasVnrArea per TotalSF: Density of masonry veneer over total living space, imputing MasVnrArea NaNs to 0)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0], 'TotalSF': [2008, 3860, 2216]\\ndf['MasVnrArea_Per_TotalSF'] = df['MasVnrArea'].fillna(0) / (df['TotalSF'] + 1e-6)\"}, {\"search_node\": {\"trial\": 9, \"parent_trial\": 4, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}], \"predefined_state\": null, \"parent_score\": -0.13231140571525984, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\"]}, \"score\": -0.13365202713357074, \"memory_update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\"}, {\"search_node\": {\"trial\": 10, \"parent_trial\": 4, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}], \"predefined_state\": null, \"parent_score\": -0.13231140571525984, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Difference in years between last remodel and original construction year. 0 if no remodel.)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearDiffRemodBuilt'] = df['YearRemodAdd'] - df['YearBuilt']\\n\\n# (Ratio of garage area per car. Handled as 0 if no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Assume GarageArea and GarageCars are 0 if no garage, otherwise 0/0 leads to NaN/inf.\\ndf['GarageAreaPerCar'] = df['GarageArea'] / np.maximum(df['GarageCars'], 1)\\ndf.loc[df['GarageCars'] == 0, 'GarageAreaPerCar'] = 0 # Explicitly set to 0 where no garage or 0 cars\\n\\n# (Binary feature: does the property have a pool?)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Binary feature: does the property have an alley? (NaN in 'Alley' means No Alley Access))\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['HasAlley'] = (~df['Alley'].isnull()).astype(int)\\n\\n# (Binary feature: does the property have a fence? (NaN in 'Fence' means No Fence))\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan]\\ndf['HasFence'] = (~df['Fence'].isnull()).astype(int)\\n\\n# (Ratio of total rooms above ground to the overall living area)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]\\ndf['RoomsPerGrLivArea'] = df['TotRmsAbvGrd'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding for BsmtFinType1 - basement finished type 1)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf']\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0) # 0 for no basement or unknown type\\n\\n# (Numerical encoding for BsmtFinType2 - basement finished type 2)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0) # 0 for no basement or unknown type\\n\\n# (Indicator for 'Excellent' heating quality. As 'Ex' is the top tier and could be very predictive.)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\ndf['HeatingQC_Ex'] = (df['HeatingQC'] == 'Ex').astype(int)\\n\\n# (Binary feature indicating if the MasVnrType is 'Stone', often associated with higher quality/price.)\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan, 'BrkFace', 'BrkFace']\\ndf['IsStoneVeneer'] = (df['MasVnrType'] == 'Stone').astype(int)\"]}, \"score\": -0.1325570257604041, \"memory_update\": \"import numpy as np\\n\\n# (Difference in years between last remodel and original construction year. 0 if no remodel.)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearDiffRemodBuilt'] = df['YearRemodAdd'] - df['YearBuilt']\\n\\n# (Ratio of garage area per car. Handled as 0 if no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Assume GarageArea and GarageCars are 0 if no garage, otherwise 0/0 leads to NaN/inf.\\ndf['GarageAreaPerCar'] = df['GarageArea'] / np.maximum(df['GarageCars'], 1)\\ndf.loc[df['GarageCars'] == 0, 'GarageAreaPerCar'] = 0 # Explicitly set to 0 where no garage or 0 cars\\n\\n# (Binary feature: does the property have a pool?)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Binary feature: does the property have an alley? (NaN in 'Alley' means No Alley Access))\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['HasAlley'] = (~df['Alley'].isnull()).astype(int)\\n\\n# (Binary feature: does the property have a fence? (NaN in 'Fence' means No Fence))\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan]\\ndf['HasFence'] = (~df['Fence'].isnull()).astype(int)\\n\\n# (Ratio of total rooms above ground to the overall living area)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]\\ndf['RoomsPerGrLivArea'] = df['TotRmsAbvGrd'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding for BsmtFinType1 - basement finished type 1)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf']\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0) # 0 for no basement or unknown type\\n\\n# (Numerical encoding for BsmtFinType2 - basement finished type 2)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0) # 0 for no basement or unknown type\\n\\n# (Indicator for 'Excellent' heating quality. As 'Ex' is the top tier and could be very predictive.)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\ndf['HeatingQC_Ex'] = (df['HeatingQC'] == 'Ex').astype(int)\\n\\n# (Binary feature indicating if the MasVnrType is 'Stone', often associated with higher quality/price.)\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan, 'BrkFace', 'BrkFace']\\ndf['IsStoneVeneer'] = (df['MasVnrType'] == 'Stone').astype(int)\"}, {\"search_node\": {\"trial\": 11, \"parent_trial\": 9, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\", \"score\": -0.13365202713357074}], \"predefined_state\": null, \"parent_score\": -0.13365202713357074, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\"]}, \"score\": -0.13319472683183448, \"memory_update\": \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\"}, {\"search_node\": {\"trial\": 12, \"parent_trial\": 4, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}], \"predefined_state\": null, \"parent_score\": -0.13231140571525984, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Has Pool: Binary indicator for whether the house has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0] (Despite samples showing 0, assume there are instances with pools, a rare but significant feature)\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Garage: Binary indicator for whether the house has a garage)\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Remodel Indicator: Binary indicator for whether the house has been remodeled since it was built)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['RemodelIndicator'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Total Rooms and Baths: Sum of total rooms above ground and total calculated bathrooms)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'TotalBath': [1.0, 3.5, 1.0] (TotalBath is from a previous block)\\ndf['TotalRoomsAndBaths'] = df['TotRmsAbvGrd'] + df['TotalBath']\\n\\n# (Effective Age of Home: Years since construction or last major remodel/addition, whichever is newer)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['AgeOfHomeAtSale_Adj'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Area Per Room Above Ground: Average living area per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AreaPerRoom_GrLiv'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Living Area Ratio to Lot Area: Ratio of above-grade living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivingAreaRatio_to_LotArea'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Garage Car Capacity Factor: Interaction between number of garage cars and garage quality encoding)\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageQual_enc': [3.0, 3.0, 3.0] (GarageQual_enc from a previous block)\\ndf['GarageCarCapacityFactor'] = df['GarageCars'] * df['GarageQual_enc']\\n\\n# (Fireplace Presence and Quality Interaction: Interaction of number of fireplaces and their quality encoding)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3.0, 3.0, 0.0] (FireplaceQu_enc from a previous block)\\ndf['FireplacePresence_Qual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Basement Unfinished Ratio: Proportion of the basement that is unfinished)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtUnfRatio'] = df['BsmtUnfSF'] / np.maximum(df['TotalBsmtSF'], 1)\"]}, \"score\": -0.133093350398863, \"memory_update\": \"import numpy as np\\n\\n# (Has Pool: Binary indicator for whether the house has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0] (Despite samples showing 0, assume there are instances with pools, a rare but significant feature)\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Garage: Binary indicator for whether the house has a garage)\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Remodel Indicator: Binary indicator for whether the house has been remodeled since it was built)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['RemodelIndicator'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Total Rooms and Baths: Sum of total rooms above ground and total calculated bathrooms)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'TotalBath': [1.0, 3.5, 1.0] (TotalBath is from a previous block)\\ndf['TotalRoomsAndBaths'] = df['TotRmsAbvGrd'] + df['TotalBath']\\n\\n# (Effective Age of Home: Years since construction or last major remodel/addition, whichever is newer)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['AgeOfHomeAtSale_Adj'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Area Per Room Above Ground: Average living area per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AreaPerRoom_GrLiv'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Living Area Ratio to Lot Area: Ratio of above-grade living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivingAreaRatio_to_LotArea'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Garage Car Capacity Factor: Interaction between number of garage cars and garage quality encoding)\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageQual_enc': [3.0, 3.0, 3.0] (GarageQual_enc from a previous block)\\ndf['GarageCarCapacityFactor'] = df['GarageCars'] * df['GarageQual_enc']\\n\\n# (Fireplace Presence and Quality Interaction: Interaction of number of fireplaces and their quality encoding)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3.0, 3.0, 0.0] (FireplaceQu_enc from a previous block)\\ndf['FireplacePresence_Qual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Basement Unfinished Ratio: Proportion of the basement that is unfinished)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtUnfRatio'] = df['BsmtUnfSF'] / np.maximum(df['TotalBsmtSF'], 1)\"}, {\"search_node\": {\"trial\": 13, \"parent_trial\": 11, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\", \"score\": -0.13365202713357074}, {\"update\": \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\", \"score\": -0.13319472683183448}], \"predefined_state\": null, \"parent_score\": -0.13319472683183448, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Log transformation of above ground living area, helps address skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Count of outdoor features present, indicating number of porches/decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['NumOutdoorFeatures'] = ((df['WoodDeckSF'] > 0).astype(int) +\\n                            (df['OpenPorchSF'] > 0).astype(int) +\\n                            (df['EnclosedPorch'] > 0).astype(int) +\\n                            (df['3SsnPorch'] > 0).astype(int) +\\n                            (df['ScreenPorch'] > 0).astype(int))\\n\\n# (Interaction feature: Overall Quality multiplied by Log transformed GrLivArea)\\n# Input samples: 'OverallQual': [5, 8, 5], 'LogGrLivArea': [7.04313, 7.83296, 7.32688] (calculated based on samples above)\\ndf['Qual_x_LogGrLivArea'] = df['OverallQual'] * df['LogGrLivArea']\\n\\n# (Difference in years between remodel and initial build, indicates how much the property changed from original)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['Remod_vs_Build_Years'] = df['YearRemodAdd'] - df['YearBuilt']\\n\\n# (Binary feature: 1 if the house has a second floor, 0 otherwise)\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFlr'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Interaction feature: Total number of bathrooms multiplied by Overall Quality)\\n# Input samples: 'TotalBath': [2.0, 3.5, 1.0], 'OverallQual': [5, 8, 5] (TotalBath is an existing derived feature)\\ndf['TotalBath_x_OverallQual'] = df['TotalBath'] * df['OverallQual']\\n\\n# (Ratio of Garage Area to Total Square Footage, indicating garage's proportion of total space)\\n# Input samples: 'GarageArea': [264, 796, 281], 'TotalSF': [2008, 2520, 1520] (TotalSF is an existing derived feature)\\ndf['GarageRatioToTotalSF'] = np.where(df['TotalSF'] > 0, df['GarageArea'] / df['TotalSF'], 0)\\n\\n# (Ratio of total rooms above ground to number of bedrooms, indicates roominess per bedroom)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]\\ndf['RmsPerBedrm'] = np.where(df['BedroomAbvGr'] > 0, df['TotRmsAbvGrd'] / df['BedroomAbvGr'], df['TotRmsAbvGrd'])\\n\\n# (Combined value from PoolArea and MiscVal, which are often zeros but represent significant features when non-zero)\\n# Input samples: 'PoolArea': [0, 0, 0], 'MiscVal': [400, 0, 0]\\ndf['Pool_or_MiscVal'] = df['PoolArea'] + df['MiscVal']\\n\\n# (Binary feature: 1 if the property has a garage, 0 otherwise)\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\"]}, \"score\": -0.13398364854708192, \"memory_update\": \"import numpy as np\\n\\n# (Log transformation of above ground living area, helps address skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Count of outdoor features present, indicating number of porches/decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['NumOutdoorFeatures'] = ((df['WoodDeckSF'] > 0).astype(int) +\\n                            (df['OpenPorchSF'] > 0).astype(int) +\\n                            (df['EnclosedPorch'] > 0).astype(int) +\\n                            (df['3SsnPorch'] > 0).astype(int) +\\n                            (df['ScreenPorch'] > 0).astype(int))\\n\\n# (Interaction feature: Overall Quality multiplied by Log transformed GrLivArea)\\n# Input samples: 'OverallQual': [5, 8, 5], 'LogGrLivArea': [7.04313, 7.83296, 7.32688] (calculated based on samples above)\\ndf['Qual_x_LogGrLivArea'] = df['OverallQual'] * df['LogGrLivArea']\\n\\n# (Difference in years between remodel and initial build, indicates how much the property changed from original)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['Remod_vs_Build_Years'] = df['YearRemodAdd'] - df['YearBuilt']\\n\\n# (Binary feature: 1 if the house has a second floor, 0 otherwise)\\n# Input samples: '2ndFlrSF': [0, 1168, 672]\\ndf['Has2ndFlr'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Interaction feature: Total number of bathrooms multiplied by Overall Quality)\\n# Input samples: 'TotalBath': [2.0, 3.5, 1.0], 'OverallQual': [5, 8, 5] (TotalBath is an existing derived feature)\\ndf['TotalBath_x_OverallQual'] = df['TotalBath'] * df['OverallQual']\\n\\n# (Ratio of Garage Area to Total Square Footage, indicating garage's proportion of total space)\\n# Input samples: 'GarageArea': [264, 796, 281], 'TotalSF': [2008, 2520, 1520] (TotalSF is an existing derived feature)\\ndf['GarageRatioToTotalSF'] = np.where(df['TotalSF'] > 0, df['GarageArea'] / df['TotalSF'], 0)\\n\\n# (Ratio of total rooms above ground to number of bedrooms, indicates roominess per bedroom)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]\\ndf['RmsPerBedrm'] = np.where(df['BedroomAbvGr'] > 0, df['TotRmsAbvGrd'] / df['BedroomAbvGr'], df['TotRmsAbvGrd'])\\n\\n# (Combined value from PoolArea and MiscVal, which are often zeros but represent significant features when non-zero)\\n# Input samples: 'PoolArea': [0, 0, 0], 'MiscVal': [400, 0, 0]\\ndf['Pool_or_MiscVal'] = df['PoolArea'] + df['MiscVal']\\n\\n# (Binary feature: 1 if the property has a garage, 0 otherwise)\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\"}, {\"search_node\": {\"trial\": 14, \"parent_trial\": 11, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\", \"score\": -0.13365202713357074}, {\"update\": \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\", \"score\": -0.13319472683183448}], \"predefined_state\": null, \"parent_score\": -0.13319472683183448, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log transformation of GrLivArea to handle skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Combined Condition Score: weighted sum of overall condition, exterior, basement, and garage condition)\\n# Input samples: 'OverallCond': [6, 7, 5], 'ExterCond_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3], 'GarageCond_enc': [3, 4, 3]\\n# Note: ExterCond_enc, BsmtCond_enc, GarageCond_enc were accepted in previous blocks.\\ndf['CombinedCondScore'] = df['OverallCond'] + df['ExterCond_enc'] + df['BsmtCond_enc'] + df['GarageCond_enc']\"]}, \"score\": -0.13273066211438242, \"memory_update\": \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log transformation of GrLivArea to handle skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Combined Condition Score: weighted sum of overall condition, exterior, basement, and garage condition)\\n# Input samples: 'OverallCond': [6, 7, 5], 'ExterCond_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3], 'GarageCond_enc': [3, 4, 3]\\n# Note: ExterCond_enc, BsmtCond_enc, GarageCond_enc were accepted in previous blocks.\\ndf['CombinedCondScore'] = df['OverallCond'] + df['ExterCond_enc'] + df['BsmtCond_enc'] + df['GarageCond_enc']\"}, {\"search_node\": {\"trial\": 15, \"parent_trial\": 14, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\", \"score\": -0.13365202713357074}, {\"update\": \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\", \"score\": -0.13319472683183448}, {\"update\": \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log transformation of GrLivArea to handle skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Combined Condition Score: weighted sum of overall condition, exterior, basement, and garage condition)\\n# Input samples: 'OverallCond': [6, 7, 5], 'ExterCond_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3], 'GarageCond_enc': [3, 4, 3]\\n# Note: ExterCond_enc, BsmtCond_enc, GarageCond_enc were accepted in previous blocks.\\ndf['CombinedCondScore'] = df['OverallCond'] + df['ExterCond_enc'] + df['BsmtCond_enc'] + df['GarageCond_enc']\", \"score\": -0.13273066211438242}], \"predefined_state\": null, \"parent_score\": -0.13273066211438242, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Has Pool: Binary indicator if the house has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Misc Feature: Binary indicator if the house has any miscellaneous value item)\\n# Input samples: 'MiscVal': [400, 0, 0, 0, 0]\\ndf['HasMiscVal'] = (df['MiscVal'] > 0).astype(int)\\n\\n# (Has 2nd Floor: Binary indicator if the house has a second floor)\\n# Input samples: '2ndFlrSF': [0, 1168, 672, 0, 0]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Years Since Last Major Activity: Years since the last of either construction or major remodel)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceLastActivity'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Log of Total Square Footage: Log-transformed sum of 1st, 2nd floor, and total basement square footage)\\n# Input samples: 'TotalSF': [1144, 2520, 1520, 1479, 894] (TotalSF is an accepted feature from earlier blocks)\\ndf['LogTotalSF'] = np.log1p(df['TotalSF'])\\n\\n# (Garage Total Value: Product of GarageArea and GarageCars to indicate overall garage capacity/utility)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageTotal'] = df['GarageArea'] * df['GarageCars']\\n\\n# (Overall Material and Kitchen Quality: Combined score from general quality, exterior quality, and kitchen quality)\\n# Input samples: 'OverallQual': [5, 8, 5], 'ExterQual_enc': [3, 4, 3], 'KitchenQual_enc': [3, 4, 3] (ExterQual_enc and KitchenQual_enc are accepted features from earlier blocks)\\ndf['OverallMaterialKitchenQual'] = df['OverallQual'] + df['ExterQual_enc'] + df['KitchenQual_enc']\"]}, \"score\": -0.13268714103095364, \"memory_update\": \"import numpy as np\\n\\n# (Has Pool: Binary indicator if the house has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Misc Feature: Binary indicator if the house has any miscellaneous value item)\\n# Input samples: 'MiscVal': [400, 0, 0, 0, 0]\\ndf['HasMiscVal'] = (df['MiscVal'] > 0).astype(int)\\n\\n# (Has 2nd Floor: Binary indicator if the house has a second floor)\\n# Input samples: '2ndFlrSF': [0, 1168, 672, 0, 0]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Years Since Last Major Activity: Years since the last of either construction or major remodel)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceLastActivity'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Log of Total Square Footage: Log-transformed sum of 1st, 2nd floor, and total basement square footage)\\n# Input samples: 'TotalSF': [1144, 2520, 1520, 1479, 894] (TotalSF is an accepted feature from earlier blocks)\\ndf['LogTotalSF'] = np.log1p(df['TotalSF'])\\n\\n# (Garage Total Value: Product of GarageArea and GarageCars to indicate overall garage capacity/utility)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageTotal'] = df['GarageArea'] * df['GarageCars']\\n\\n# (Overall Material and Kitchen Quality: Combined score from general quality, exterior quality, and kitchen quality)\\n# Input samples: 'OverallQual': [5, 8, 5], 'ExterQual_enc': [3, 4, 3], 'KitchenQual_enc': [3, 4, 3] (ExterQual_enc and KitchenQual_enc are accepted features from earlier blocks)\\ndf['OverallMaterialKitchenQual'] = df['OverallQual'] + df['ExterQual_enc'] + df['KitchenQual_enc']\"}, {\"search_node\": {\"trial\": 16, \"parent_trial\": 15, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\", \"score\": -0.13365202713357074}, {\"update\": \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\", \"score\": -0.13319472683183448}, {\"update\": \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log transformation of GrLivArea to handle skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Combined Condition Score: weighted sum of overall condition, exterior, basement, and garage condition)\\n# Input samples: 'OverallCond': [6, 7, 5], 'ExterCond_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3], 'GarageCond_enc': [3, 4, 3]\\n# Note: ExterCond_enc, BsmtCond_enc, GarageCond_enc were accepted in previous blocks.\\ndf['CombinedCondScore'] = df['OverallCond'] + df['ExterCond_enc'] + df['BsmtCond_enc'] + df['GarageCond_enc']\", \"score\": -0.13273066211438242}, {\"update\": \"import numpy as np\\n\\n# (Has Pool: Binary indicator if the house has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Misc Feature: Binary indicator if the house has any miscellaneous value item)\\n# Input samples: 'MiscVal': [400, 0, 0, 0, 0]\\ndf['HasMiscVal'] = (df['MiscVal'] > 0).astype(int)\\n\\n# (Has 2nd Floor: Binary indicator if the house has a second floor)\\n# Input samples: '2ndFlrSF': [0, 1168, 672, 0, 0]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Years Since Last Major Activity: Years since the last of either construction or major remodel)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceLastActivity'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Log of Total Square Footage: Log-transformed sum of 1st, 2nd floor, and total basement square footage)\\n# Input samples: 'TotalSF': [1144, 2520, 1520, 1479, 894] (TotalSF is an accepted feature from earlier blocks)\\ndf['LogTotalSF'] = np.log1p(df['TotalSF'])\\n\\n# (Garage Total Value: Product of GarageArea and GarageCars to indicate overall garage capacity/utility)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageTotal'] = df['GarageArea'] * df['GarageCars']\\n\\n# (Overall Material and Kitchen Quality: Combined score from general quality, exterior quality, and kitchen quality)\\n# Input samples: 'OverallQual': [5, 8, 5], 'ExterQual_enc': [3, 4, 3], 'KitchenQual_enc': [3, 4, 3] (ExterQual_enc and KitchenQual_enc are accepted features from earlier blocks)\\ndf['OverallMaterialKitchenQual'] = df['OverallQual'] + df['ExterQual_enc'] + df['KitchenQual_enc']\", \"score\": -0.13268714103095364}], \"predefined_state\": null, \"parent_score\": -0.13268714103095364, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\nimport pandas as pd\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\\n\\n# (Log of Ground Living Area: log transformation of above ground living area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (House Style Story Rating: numerical representation of house style's \\\"storiness\\\")\\n# Input samples: 'HouseStyle': ['1Story', '2Story', '1.5Fin', '1Story', '1Story']\\nhouse_style_map = {\\n    '1Story': 1, '1.5Fin': 1.5, '1.5Unf': 1.5, '2Story': 2,\\n    '2.5Fin': 2.5, '2.5Unf': 2.5, 'SFoyer': 1, 'SLvl': 1\\n}\\ndf['HouseStyle_Story'] = df['HouseStyle'].map(house_style_map).fillna(1) # Default to 1 story for any unmapped\\n\\n# (Central Air Quality Interaction: Interaction between presence of Central Air and Overall Quality)\\n# Input samples: 'HasCentralAir': [1, 1, 1], 'OverallQual': [5, 8, 5] (HasCentralAir created in this block)\\ndf['CentralAir_x_OverallQual'] = df['HasCentralAir'] * df['OverallQual']\\n\\n# (Total Porch/Deck Area per Total SF Interaction with Overall Quality)\\n# Input samples: 'TotalPorchDeckSF': [165, 264, 56], 'TotalSF': [1144, 2520, 1520], 'OverallQual': [5, 8, 5] (TotalPorchDeckSF created in this block, TotalSF is an accepted column)\\ndf['PorchDeckSF_QualRatio'] = df['TotalPorchDeckSF'] / np.maximum(df['TotalSF'], 1) * df['OverallQual']\\n\\n# (Exterior Quality Combined: Product of Overall Quality and Exterior Quality)\\n# Input samples: 'OverallQual': [5, 8, 5], 'ExterQual_enc': [3, 4, 3] (ExterQual_enc from accepted block)\\ndf['OverallExterQual_Prod'] = df['OverallQual'] * df['ExterQual_enc']\\n\\n# (Functional Deficient: Binary indicator if the functional condition is anything other than 'Typical')\\n# Input samples: 'Functional_enc': [7, 7, 7, 7, 7] (Functional_enc created in this block)\\ndf['FunctionalDeficient'] = (df['Functional_enc'] < 7).astype(int)\\n\\n# (Lot Shape Irregular: Binary indicator if the LotShape is anything other than 'Reg')\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\ndf['LotShape_Irregular'] = (df['LotShape'] != 'Reg').astype(int)\\n\\n# (Binary feature for the most common 2-story house class type)\\n# Input samples: 'MSSubClass': [20, 60, 50, 20, 20]\\ndf['IsMSSubClass60'] = (df['MSSubClass'] == 60).astype(int)\"]}, \"score\": -0.13332811868789463, \"memory_update\": \"import numpy as np\\nimport pandas as pd\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\\n\\n# (Log of Ground Living Area: log transformation of above ground living area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (House Style Story Rating: numerical representation of house style's \\\"storiness\\\")\\n# Input samples: 'HouseStyle': ['1Story', '2Story', '1.5Fin', '1Story', '1Story']\\nhouse_style_map = {\\n    '1Story': 1, '1.5Fin': 1.5, '1.5Unf': 1.5, '2Story': 2,\\n    '2.5Fin': 2.5, '2.5Unf': 2.5, 'SFoyer': 1, 'SLvl': 1\\n}\\ndf['HouseStyle_Story'] = df['HouseStyle'].map(house_style_map).fillna(1) # Default to 1 story for any unmapped\\n\\n# (Central Air Quality Interaction: Interaction between presence of Central Air and Overall Quality)\\n# Input samples: 'HasCentralAir': [1, 1, 1], 'OverallQual': [5, 8, 5] (HasCentralAir created in this block)\\ndf['CentralAir_x_OverallQual'] = df['HasCentralAir'] * df['OverallQual']\\n\\n# (Total Porch/Deck Area per Total SF Interaction with Overall Quality)\\n# Input samples: 'TotalPorchDeckSF': [165, 264, 56], 'TotalSF': [1144, 2520, 1520], 'OverallQual': [5, 8, 5] (TotalPorchDeckSF created in this block, TotalSF is an accepted column)\\ndf['PorchDeckSF_QualRatio'] = df['TotalPorchDeckSF'] / np.maximum(df['TotalSF'], 1) * df['OverallQual']\\n\\n# (Exterior Quality Combined: Product of Overall Quality and Exterior Quality)\\n# Input samples: 'OverallQual': [5, 8, 5], 'ExterQual_enc': [3, 4, 3] (ExterQual_enc from accepted block)\\ndf['OverallExterQual_Prod'] = df['OverallQual'] * df['ExterQual_enc']\\n\\n# (Functional Deficient: Binary indicator if the functional condition is anything other than 'Typical')\\n# Input samples: 'Functional_enc': [7, 7, 7, 7, 7] (Functional_enc created in this block)\\ndf['FunctionalDeficient'] = (df['Functional_enc'] < 7).astype(int)\\n\\n# (Lot Shape Irregular: Binary indicator if the LotShape is anything other than 'Reg')\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\ndf['LotShape_Irregular'] = (df['LotShape'] != 'Reg').astype(int)\\n\\n# (Binary feature for the most common 2-story house class type)\\n# Input samples: 'MSSubClass': [20, 60, 50, 20, 20]\\ndf['IsMSSubClass60'] = (df['MSSubClass'] == 60).astype(int)\"}, {\"search_node\": {\"trial\": 17, \"parent_trial\": 1, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}], \"predefined_state\": null, \"parent_score\": -0.13304342646742578, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"# (Total outdoor living area: Sum of WoodDeckSF, OpenPorchSF, EnclosedPorch, 3SsnPorch, ScreenPorch)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Remodeled: Binary flag if YearRemodAdd is different from YearBuilt)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['HasRemodeled_bool'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (MasVnrPresent: Binary flag if masonry veneer area is present (i.e., > 0) after handling its small NaN count)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrPresent_bool'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (HasAlley: Binary flag for the presence of Alley access, handling high NaN frequency where NaN means no alley)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['HasAlley_bool'] = df['Alley'].notna().astype(int)\\n\\n# (HasFence: Binary flag for the presence of a Fence, handling high NaN frequency where NaN means no fence)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan]\\ndf['HasFence_bool'] = df['Fence'].notna().astype(int)\\n\\n# (Rooms per GrLivArea: Ratio of total rooms above grade to general living area, indicating open-plan vs dense layout)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]\\n# Add a small epsilon to the denominator to prevent division by zero for rows where GrLivArea is 0\\ndf['RoomsPerGrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6)\\n\\n# (GrLivArea to TotalBsmtSF Ratio: Ratio of above grade living area to total basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\n# Handle division by zero for TotalBsmtSF (implies no basement) by adding a small epsilon\\ndf['LivAreaBsmtRatio'] = df['GrLivArea'] / (df['TotalBsmtSF'] + 1e-6)\\n\\n# (LotArea per LotFrontage: Ratio of lot area to lot frontage. Fills LotFrontage NaNs with its median before division.)\\n# Input samples: 'LotArea': [10000, 14541, 4500], 'LotFrontage': [80.0, nan, 55.0]\\ndf['LotAreaPerFrontage'] = df['LotArea'] / (df['LotFrontage'].fillna(df['LotFrontage'].median()) + 1e-6)\\n\\n# (Years difference between House built and Garage built, absolute value. NaNs in GarageYrBlt are filled with YearBuilt.)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, nan]\\ndf['YearsDiffGarageHouseBuilt'] = abs(df['YearBuilt'] - df['GarageYrBlt'].fillna(df['YearBuilt']))\\n\\n# (Qual_x_TotalSF: A combined metric of overall quality scaled by the total living area (TotalSF from previous block))\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotalSF': [1908, 2690, 1641]\\ndf['Qual_x_TotalSF'] = df['OverallQual'] * df['TotalSF']\"]}, \"score\": -0.13858652803267618, \"memory_update\": \"# (Total outdoor living area: Sum of WoodDeckSF, OpenPorchSF, EnclosedPorch, 3SsnPorch, ScreenPorch)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalOutdoorArea'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Remodeled: Binary flag if YearRemodAdd is different from YearBuilt)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['HasRemodeled_bool'] = (df['YearRemodAdd'] != df['YearBuilt']).astype(int)\\n\\n# (MasVnrPresent: Binary flag if masonry veneer area is present (i.e., > 0) after handling its small NaN count)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrPresent_bool'] = (df['MasVnrArea'].fillna(0) > 0).astype(int)\\n\\n# (HasAlley: Binary flag for the presence of Alley access, handling high NaN frequency where NaN means no alley)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['HasAlley_bool'] = df['Alley'].notna().astype(int)\\n\\n# (HasFence: Binary flag for the presence of a Fence, handling high NaN frequency where NaN means no fence)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan]\\ndf['HasFence_bool'] = df['Fence'].notna().astype(int)\\n\\n# (Rooms per GrLivArea: Ratio of total rooms above grade to general living area, indicating open-plan vs dense layout)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]\\n# Add a small epsilon to the denominator to prevent division by zero for rows where GrLivArea is 0\\ndf['RoomsPerGrLivArea'] = df['TotRmsAbvGrd'] / (df['GrLivArea'] + 1e-6)\\n\\n# (GrLivArea to TotalBsmtSF Ratio: Ratio of above grade living area to total basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalBsmtSF': [864, 1338, 793]\\n# Handle division by zero for TotalBsmtSF (implies no basement) by adding a small epsilon\\ndf['LivAreaBsmtRatio'] = df['GrLivArea'] / (df['TotalBsmtSF'] + 1e-6)\\n\\n# (LotArea per LotFrontage: Ratio of lot area to lot frontage. Fills LotFrontage NaNs with its median before division.)\\n# Input samples: 'LotArea': [10000, 14541, 4500], 'LotFrontage': [80.0, nan, 55.0]\\ndf['LotAreaPerFrontage'] = df['LotArea'] / (df['LotFrontage'].fillna(df['LotFrontage'].median()) + 1e-6)\\n\\n# (Years difference between House built and Garage built, absolute value. NaNs in GarageYrBlt are filled with YearBuilt.)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, nan]\\ndf['YearsDiffGarageHouseBuilt'] = abs(df['YearBuilt'] - df['GarageYrBlt'].fillna(df['YearBuilt']))\\n\\n# (Qual_x_TotalSF: A combined metric of overall quality scaled by the total living area (TotalSF from previous block))\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotalSF': [1908, 2690, 1641]\\ndf['Qual_x_TotalSF'] = df['OverallQual'] * df['TotalSF']\"}, {\"search_node\": {\"trial\": 18, \"parent_trial\": 12, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Has Pool: Binary indicator for whether the house has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0] (Despite samples showing 0, assume there are instances with pools, a rare but significant feature)\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Garage: Binary indicator for whether the house has a garage)\\n# Input samples: 'GarageArea': [264, 796, 281]\\ndf['HasGarage'] = (df['GarageArea'] > 0).astype(int)\\n\\n# (Remodel Indicator: Binary indicator for whether the house has been remodeled since it was built)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['RemodelIndicator'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Total Rooms and Baths: Sum of total rooms above ground and total calculated bathrooms)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'TotalBath': [1.0, 3.5, 1.0] (TotalBath is from a previous block)\\ndf['TotalRoomsAndBaths'] = df['TotRmsAbvGrd'] + df['TotalBath']\\n\\n# (Effective Age of Home: Years since construction or last major remodel/addition, whichever is newer)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['AgeOfHomeAtSale_Adj'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Area Per Room Above Ground: Average living area per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['AreaPerRoom_GrLiv'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Living Area Ratio to Lot Area: Ratio of above-grade living area to the total lot area)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\ndf['LivingAreaRatio_to_LotArea'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Garage Car Capacity Factor: Interaction between number of garage cars and garage quality encoding)\\n# Input samples: 'GarageCars': [1, 3, 1], 'GarageQual_enc': [3.0, 3.0, 3.0] (GarageQual_enc from a previous block)\\ndf['GarageCarCapacityFactor'] = df['GarageCars'] * df['GarageQual_enc']\\n\\n# (Fireplace Presence and Quality Interaction: Interaction of number of fireplaces and their quality encoding)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3.0, 3.0, 0.0] (FireplaceQu_enc from a previous block)\\ndf['FireplacePresence_Qual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Basement Unfinished Ratio: Proportion of the basement that is unfinished)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtUnfRatio'] = df['BsmtUnfSF'] / np.maximum(df['TotalBsmtSF'], 1)\", \"score\": -0.133093350398863}], \"predefined_state\": null, \"parent_score\": -0.133093350398863, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# Define quality/condition mapping for ordinal features, will reuse.\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Functional, mapping NaN to 0 as 'Sal' (lowest functionality) or missing)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Average Living Area per Bedroom, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BedroomAbvGr': [3, 5, 3]\\ndf['AvgAreaPerBedroom'] = df['GrLivArea'] / np.maximum(df['BedroomAbvGr'], 1)\"]}, \"score\": -0.13298684179999173, \"memory_update\": \"import numpy as np\\n\\n# Define quality/condition mapping for ordinal features, will reuse.\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Functional, mapping NaN to 0 as 'Sal' (lowest functionality) or missing)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Average Living Area per Bedroom, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BedroomAbvGr': [3, 5, 3]\\ndf['AvgAreaPerBedroom'] = df['GrLivArea'] / np.maximum(df['BedroomAbvGr'], 1)\"}, {\"search_node\": {\"trial\": 19, \"parent_trial\": 15, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\", \"score\": -0.13365202713357074}, {\"update\": \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\", \"score\": -0.13319472683183448}, {\"update\": \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log transformation of GrLivArea to handle skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Combined Condition Score: weighted sum of overall condition, exterior, basement, and garage condition)\\n# Input samples: 'OverallCond': [6, 7, 5], 'ExterCond_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3], 'GarageCond_enc': [3, 4, 3]\\n# Note: ExterCond_enc, BsmtCond_enc, GarageCond_enc were accepted in previous blocks.\\ndf['CombinedCondScore'] = df['OverallCond'] + df['ExterCond_enc'] + df['BsmtCond_enc'] + df['GarageCond_enc']\", \"score\": -0.13273066211438242}, {\"update\": \"import numpy as np\\n\\n# (Has Pool: Binary indicator if the house has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Misc Feature: Binary indicator if the house has any miscellaneous value item)\\n# Input samples: 'MiscVal': [400, 0, 0, 0, 0]\\ndf['HasMiscVal'] = (df['MiscVal'] > 0).astype(int)\\n\\n# (Has 2nd Floor: Binary indicator if the house has a second floor)\\n# Input samples: '2ndFlrSF': [0, 1168, 672, 0, 0]\\ndf['Has2ndFloor'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Years Since Last Major Activity: Years since the last of either construction or major remodel)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearsSinceLastActivity'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Log of Total Square Footage: Log-transformed sum of 1st, 2nd floor, and total basement square footage)\\n# Input samples: 'TotalSF': [1144, 2520, 1520, 1479, 894] (TotalSF is an accepted feature from earlier blocks)\\ndf['LogTotalSF'] = np.log1p(df['TotalSF'])\\n\\n# (Garage Total Value: Product of GarageArea and GarageCars to indicate overall garage capacity/utility)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageTotal'] = df['GarageArea'] * df['GarageCars']\\n\\n# (Overall Material and Kitchen Quality: Combined score from general quality, exterior quality, and kitchen quality)\\n# Input samples: 'OverallQual': [5, 8, 5], 'ExterQual_enc': [3, 4, 3], 'KitchenQual_enc': [3, 4, 3] (ExterQual_enc and KitchenQual_enc are accepted features from earlier blocks)\\ndf['OverallMaterialKitchenQual'] = df['OverallQual'] + df['ExterQual_enc'] + df['KitchenQual_enc']\", \"score\": -0.13268714103095364}], \"predefined_state\": null, \"parent_score\": -0.13268714103095364, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Log transformation of LotFrontage, using the imputed value)\\n# Input samples: 'LotFrontage_Imputed': [80.0, 70.0, 55.0]\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage_Imputed'])\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Binary indicator for presence of a garage, derived from GarageCars > 0)\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Interaction of LogLotArea with overall quality)\\n# Input samples: 'LogLotArea': [9.21, 9.58, 8.41], 'OverallQual': [5, 8, 5]\\ndf['LotArea_x_OverallQual'] = df['LogLotArea'] * df['OverallQual']\\n\\n# (Binary feature for 2-story house style)\\n# Input samples: 'HouseStyle': ['1Story', '2Story', '1.5Fin']\\ndf['Is2Story'] = (df['HouseStyle'] == '2Story').astype(int)\\n\\n# (Numerical encoding of Electrical system quality)\\n# Input samples: 'Electrical': ['SBrkr', 'SBrkr', 'SBrkr', 'SBrkr', 'SBrkr']\\nelectrical_map = {'SBrkr': 5, 'FuseA': 4, 'FuseF': 3, 'FuseP': 2, 'Mix': 1}\\ndf['Electrical_enc'] = df['Electrical'].map(electrical_map).fillna(0) # Fill NaN for safety, assuming lowest quality if missing\\n\\n# (Combined above ground quality score for kitchen and heating)\\n# Input samples: 'KitchenQual_enc': [3, 4, 3], 'HeatingQC_enc': [5, 5, 5] (KitchenQual_enc is accepted)\\ndf['AboveGroundQual_score'] = df['KitchenQual_enc'] + df['HeatingQC_enc']\\n\\n# (Ratio of above grade living area to total square footage (above ground + basement))\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalSF': [1144, 2520, 1520] (TotalSF is accepted)\\ndf['GrLivRatioToTotalSF'] = df['GrLivArea'] / np.maximum(df['TotalSF'], 1)\\n\\n# (Binary feature indicating if the lot is a corner lot or has an irregular shape)\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside'], 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['IsCornerLotOrIrregular'] = ((df['LotConfig'] == 'Corner') | (df['LotShape'] != 'Reg')).astype(int)\"]}, \"score\": -0.13101159337403426, \"memory_update\": \"import numpy as np\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Log transformation of LotFrontage, using the imputed value)\\n# Input samples: 'LotFrontage_Imputed': [80.0, 70.0, 55.0]\\ndf['LogLotFrontage'] = np.log1p(df['LotFrontage_Imputed'])\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Binary indicator for presence of a garage, derived from GarageCars > 0)\\n# Input samples: 'GarageCars': [1, 3, 1]\\ndf['HasGarage'] = (df['GarageCars'] > 0).astype(int)\\n\\n# (Interaction of LogLotArea with overall quality)\\n# Input samples: 'LogLotArea': [9.21, 9.58, 8.41], 'OverallQual': [5, 8, 5]\\ndf['LotArea_x_OverallQual'] = df['LogLotArea'] * df['OverallQual']\\n\\n# (Binary feature for 2-story house style)\\n# Input samples: 'HouseStyle': ['1Story', '2Story', '1.5Fin']\\ndf['Is2Story'] = (df['HouseStyle'] == '2Story').astype(int)\\n\\n# (Numerical encoding of Electrical system quality)\\n# Input samples: 'Electrical': ['SBrkr', 'SBrkr', 'SBrkr', 'SBrkr', 'SBrkr']\\nelectrical_map = {'SBrkr': 5, 'FuseA': 4, 'FuseF': 3, 'FuseP': 2, 'Mix': 1}\\ndf['Electrical_enc'] = df['Electrical'].map(electrical_map).fillna(0) # Fill NaN for safety, assuming lowest quality if missing\\n\\n# (Combined above ground quality score for kitchen and heating)\\n# Input samples: 'KitchenQual_enc': [3, 4, 3], 'HeatingQC_enc': [5, 5, 5] (KitchenQual_enc is accepted)\\ndf['AboveGroundQual_score'] = df['KitchenQual_enc'] + df['HeatingQC_enc']\\n\\n# (Ratio of above grade living area to total square footage (above ground + basement))\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotalSF': [1144, 2520, 1520] (TotalSF is accepted)\\ndf['GrLivRatioToTotalSF'] = df['GrLivArea'] / np.maximum(df['TotalSF'], 1)\\n\\n# (Binary feature indicating if the lot is a corner lot or has an irregular shape)\\n# Input samples: 'LotConfig': ['Corner', 'Corner', 'Inside'], 'LotShape': ['Reg', 'IR1', 'IR2']\\ndf['IsCornerLotOrIrregular'] = ((df['LotConfig'] == 'Corner') | (df['LotShape'] != 'Reg')).astype(int)\"}, {\"search_node\": {\"trial\": 20, \"parent_trial\": 4, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}], \"predefined_state\": null, \"parent_score\": -0.13231140571525984, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Binary feature indicating if the property has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Binary feature indicating if the property has a fireplace)\\n# Input samples: 'Fireplaces': [1, 1, 0, 0, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Binary feature indicating if the property has alley access, imputing NaN as no alley)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['HasAlley'] = (~df['Alley'].isnull()).astype(int)\\n\\n# (Ratio of first floor square footage to above grade living area, preventing division by zero)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], 'GrLivArea': [1144, 2520, 1520]\\ndf['1stFlrRatio'] = df['1stFlrSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Ratio of finished basement area (FinSF1) to total basement area, imputing 0 for no basement)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinRatio1'] = df['BsmtFinSF1'] / np.maximum(df['TotalBsmtSF'], 1)\\ndf.loc[df['TotalBsmtSF'] == 0, 'BsmtFinRatio1'] = 0 # Explicitly set to 0 where TotalBsmtSF is 0\\n\\n# (Ratio of total rooms above ground to number of bedrooms above ground, indicating common vs private space. Prevent division by zero.)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]\\ndf['RoomsPerBedroom'] = df['TotRmsAbvGrd'] / np.maximum(df['BedroomAbvGr'], 1)\\n\\n# (Numerical encoding of LotShape: Regular, Slightly Irregular, Moderately Irregular, Irregular. NaN handled by .fillna)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0) # 0 for any missing/unrecognized\\n\\n# (Interaction of Overall Quality with House Age)\\n# Input samples: 'OverallQual': [5, 8, 5], 'HouseAge': [48, 13, 77]\\ndf['Qual_x_Age'] = df['OverallQual'] * df['HouseAge']\\n\\n# (Binary feature indicating if the property has a two-story structure)\\n# Input samples: '2ndFlrSF': [0, 1168, 672, 0, 0]\\ndf['Has2ndFlr'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Ratio of garage area per car capacity, avoiding division by zero for GarageCars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageAreaPerCar'] = df['GarageArea'] / np.maximum(df['GarageCars'], 1)\\ndf.loc[df['GarageCars'] == 0, 'GarageAreaPerCar'] = 0 # Explicitly set to 0 where GarageCars is 0\"]}, \"score\": -0.13380875480507667, \"memory_update\": \"import numpy as np\\n\\n# (Binary feature indicating if the property has a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Binary feature indicating if the property has a fireplace)\\n# Input samples: 'Fireplaces': [1, 1, 0, 0, 0]\\ndf['HasFireplace'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Binary feature indicating if the property has alley access, imputing NaN as no alley)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['HasAlley'] = (~df['Alley'].isnull()).astype(int)\\n\\n# (Ratio of first floor square footage to above grade living area, preventing division by zero)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], 'GrLivArea': [1144, 2520, 1520]\\ndf['1stFlrRatio'] = df['1stFlrSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Ratio of finished basement area (FinSF1) to total basement area, imputing 0 for no basement)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'TotalBsmtSF': [864, 1338, 793]\\ndf['BsmtFinRatio1'] = df['BsmtFinSF1'] / np.maximum(df['TotalBsmtSF'], 1)\\ndf.loc[df['TotalBsmtSF'] == 0, 'BsmtFinRatio1'] = 0 # Explicitly set to 0 where TotalBsmtSF is 0\\n\\n# (Ratio of total rooms above ground to number of bedrooms above ground, indicating common vs private space. Prevent division by zero.)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'BedroomAbvGr': [3, 5, 3]\\ndf['RoomsPerBedroom'] = df['TotRmsAbvGrd'] / np.maximum(df['BedroomAbvGr'], 1)\\n\\n# (Numerical encoding of LotShape: Regular, Slightly Irregular, Moderately Irregular, Irregular. NaN handled by .fillna)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0) # 0 for any missing/unrecognized\\n\\n# (Interaction of Overall Quality with House Age)\\n# Input samples: 'OverallQual': [5, 8, 5], 'HouseAge': [48, 13, 77]\\ndf['Qual_x_Age'] = df['OverallQual'] * df['HouseAge']\\n\\n# (Binary feature indicating if the property has a two-story structure)\\n# Input samples: '2ndFlrSF': [0, 1168, 672, 0, 0]\\ndf['Has2ndFlr'] = (df['2ndFlrSF'] > 0).astype(int)\\n\\n# (Ratio of garage area per car capacity, avoiding division by zero for GarageCars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\ndf['GarageAreaPerCar'] = df['GarageArea'] / np.maximum(df['GarageCars'], 1)\\ndf.loc[df['GarageCars'] == 0, 'GarageAreaPerCar'] = 0 # Explicitly set to 0 where GarageCars is 0\"}, {\"search_node\": {\"trial\": 21, \"parent_trial\": 10, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Difference in years between last remodel and original construction year. 0 if no remodel.)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['YearDiffRemodBuilt'] = df['YearRemodAdd'] - df['YearBuilt']\\n\\n# (Ratio of garage area per car. Handled as 0 if no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Assume GarageArea and GarageCars are 0 if no garage, otherwise 0/0 leads to NaN/inf.\\ndf['GarageAreaPerCar'] = df['GarageArea'] / np.maximum(df['GarageCars'], 1)\\ndf.loc[df['GarageCars'] == 0, 'GarageAreaPerCar'] = 0 # Explicitly set to 0 where no garage or 0 cars\\n\\n# (Binary feature: does the property have a pool?)\\n# Input samples: 'PoolArea': [0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Binary feature: does the property have an alley? (NaN in 'Alley' means No Alley Access))\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan]\\ndf['HasAlley'] = (~df['Alley'].isnull()).astype(int)\\n\\n# (Binary feature: does the property have a fence? (NaN in 'Fence' means No Fence))\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan]\\ndf['HasFence'] = (~df['Fence'].isnull()).astype(int)\\n\\n# (Ratio of total rooms above ground to the overall living area)\\n# Input samples: 'TotRmsAbvGrd': [6, 10, 6], 'GrLivArea': [1144, 2520, 1520]\\ndf['RoomsPerGrLivArea'] = df['TotRmsAbvGrd'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding for BsmtFinType1 - basement finished type 1)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf']\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0) # 0 for no basement or unknown type\\n\\n# (Numerical encoding for BsmtFinType2 - basement finished type 2)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf']\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0) # 0 for no basement or unknown type\\n\\n# (Indicator for 'Excellent' heating quality. As 'Ex' is the top tier and could be very predictive.)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\ndf['HeatingQC_Ex'] = (df['HeatingQC'] == 'Ex').astype(int)\\n\\n# (Binary feature indicating if the MasVnrType is 'Stone', often associated with higher quality/price.)\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan, 'BrkFace', 'BrkFace']\\ndf['IsStoneVeneer'] = (df['MasVnrType'] == 'Stone').astype(int)\", \"score\": -0.1325570257604041}], \"predefined_state\": null, \"parent_score\": -0.1325570257604041, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Total outdoor living area: Sum of open porch and wood deck areas)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0]\\ndf['OutdoorLivingSF'] = df['WoodDeckSF'] + df['OpenPorchSF']\\n\\n# (Combined Living Area Quality: Interaction of Above-Ground Living Area and Overall Quality)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]\\ndf['GrLivArea_OverallQual'] = df['GrLivArea'] * df['OverallQual']\\n\\n# (Combined Basement Area Quality: Interaction of Total Basement Area and Overall Quality)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'OverallQual': [5, 8, 5]\\ndf['TotalBsmtSF_OverallQual'] = df['TotalBsmtSF'] * df['OverallQual']\\n\\n# (Indication of a recent major update (construction or remodel). 1 if last update within last 20 years, 0 otherwise)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RecentUpdate_20yrs'] = ((df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])) <= 20).astype(int)\\n\\n# (Has Fireplaces: Binary indicator for the presence of any fireplaces)\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace_bool'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Ratio of finished basement area to total basement area, avoiding division by zero)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]\\ndf['FinishedBsmtRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / np.maximum(df['TotalBsmtSF'], 1)\\n\\n# (Binary feature for attached garage, which often adds convenience and value)\\n# Input samples: 'GarageType': ['Attchd', 'Attchd', 'Detchd', 'Attchd', 'Detchd']\\ndf['IsAttachedGarage'] = (df['GarageType'] == 'Attchd').astype(int)\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LotArea_log'] = np.log1p(df['LotArea'])\\n\\n# (Age since the last major change (either built or remodeled) at the time of sale)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['AgeSinceLastMajorChange'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Has a garage: Binary indicator if any garage exists, based on GarageType being non-null)\\n# Input samples: 'GarageType': ['Attchd', 'Attchd', 'Detchd', nan, 'Attchd']\\ndf['HasGarage_Type'] = df['GarageType'].notnull().astype(int)\"]}, \"score\": -0.13523781819203107, \"memory_update\": \"import numpy as np\\n\\n# (Total outdoor living area: Sum of open porch and wood deck areas)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0]\\ndf['OutdoorLivingSF'] = df['WoodDeckSF'] + df['OpenPorchSF']\\n\\n# (Combined Living Area Quality: Interaction of Above-Ground Living Area and Overall Quality)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'OverallQual': [5, 8, 5]\\ndf['GrLivArea_OverallQual'] = df['GrLivArea'] * df['OverallQual']\\n\\n# (Combined Basement Area Quality: Interaction of Total Basement Area and Overall Quality)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'OverallQual': [5, 8, 5]\\ndf['TotalBsmtSF_OverallQual'] = df['TotalBsmtSF'] * df['OverallQual']\\n\\n# (Indication of a recent major update (construction or remodel). 1 if last update within last 20 years, 0 otherwise)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RecentUpdate_20yrs'] = ((df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])) <= 20).astype(int)\\n\\n# (Has Fireplaces: Binary indicator for the presence of any fireplaces)\\n# Input samples: 'Fireplaces': [1, 1, 0]\\ndf['HasFireplace_bool'] = (df['Fireplaces'] > 0).astype(int)\\n\\n# (Ratio of finished basement area to total basement area, avoiding division by zero)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0], 'TotalBsmtSF': [864, 1338, 793]\\ndf['FinishedBsmtRatio'] = (df['BsmtFinSF1'] + df['BsmtFinSF2']) / np.maximum(df['TotalBsmtSF'], 1)\\n\\n# (Binary feature for attached garage, which often adds convenience and value)\\n# Input samples: 'GarageType': ['Attchd', 'Attchd', 'Detchd', 'Attchd', 'Detchd']\\ndf['IsAttachedGarage'] = (df['GarageType'] == 'Attchd').astype(int)\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LotArea_log'] = np.log1p(df['LotArea'])\\n\\n# (Age since the last major change (either built or remodeled) at the time of sale)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['AgeSinceLastMajorChange'] = df['YrSold'] - np.maximum(df['YearBuilt'], df['YearRemodAdd'])\\n\\n# (Has a garage: Binary indicator if any garage exists, based on GarageType being non-null)\\n# Input samples: 'GarageType': ['Attchd', 'Attchd', 'Detchd', nan, 'Attchd']\\ndf['HasGarage_Type'] = df['GarageType'].notnull().astype(int)\"}, {\"search_node\": {\"trial\": 22, \"parent_trial\": 14, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}, {\"update\": \"import numpy as np\\n\\n# (Numerical encoding of Alley access: Pave=2, Grvl=1, No_Alley=0)\\n# Input samples: 'Alley': [nan, nan, 'Pave', nan, nan, nan, nan, nan, nan, nan]\\nalley_map = {'Pave': 2, 'Grvl': 1}\\ndf['Alley_enc'] = df['Alley'].map(alley_map).fillna(0) # NaN means no alley access\\n\\n# (Numerical encoding of Fence quality: GdPrv=4, MnPrv=3, GdWo=2, MnWw=1, No_Fence=0)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan, nan, nan, 'MnPrv', nan, 'GdPrv']\\nfence_map = {'GdPrv': 4, 'MnPrv': 3, 'GdWo': 2, 'MnWw': 1}\\ndf['Fence_enc'] = df['Fence'].map(fence_map).fillna(0) # NaN means no fence\\n\\n# (Numerical encoding of Basement Finished Type 1: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType1': ['BLQ', 'GLQ', 'Rec', 'GLQ', 'LwQ', 'GLQ', 'BLQ', 'ALQ', 'GLQ', 'Unf', nan]\\nbsmt_fin_type_map = {'GLQ': 6, 'ALQ': 5, 'BLQ': 4, 'Rec': 3, 'LwQ': 2, 'Unf': 1}\\ndf['BsmtFinType1_enc'] = df['BsmtFinType1'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Numerical encoding of Basement Finished Type 2: GLQ=6, ALQ=5, BLQ=4, Rec=3, LwQ=2, Unf=1, No_Bsmt/Unknown=0)\\n# Input samples: 'BsmtFinType2': ['Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', 'Unf', nan]\\ndf['BsmtFinType2_enc'] = df['BsmtFinType2'].map(bsmt_fin_type_map).fillna(0)\\n\\n# (Binary feature indicating if the house was remodeled after initial construction)\\n# Input samples: 'YearBuilt': [1961, 1993, 1932], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['WasRemodeled'] = (df['YearRemodAdd'] > df['YearBuilt']).astype(int)\\n\\n# (Ratio of total basement square footage to above ground living area)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793], 'GrLivArea': [1144, 2520, 1520]\\n# Add 1 to GrLivArea to prevent division by zero, in case GrLivArea can be 0 (e.g. accessory structures without living space, highly unlikely for primary residential)\\ndf['BsmtGrLivRatio'] = df['TotalBsmtSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Numerical encoding of Lot Shape: Reg=4, IR1=3, IR2=2, IR3=1)\\n# Input samples: 'LotShape': ['Reg', 'IR1', 'IR2', 'IR1', 'Reg']\\nlot_shape_map = {'Reg': 4, 'IR1': 3, 'IR2': 2, 'IR3': 1}\\ndf['LotShape_enc'] = df['LotShape'].map(lot_shape_map).fillna(0)\\n\\n# (Interaction feature: Product of house age and overall quality)\\n# Input samples: 'HouseAge': [48, 13, 77], 'OverallQual': [5, 8, 5] (HouseAge from previous block)\\ndf['Age_Qual_Interaction'] = df['HouseAge'] * df['OverallQual']\\n\\n# (Binary feature indicating if the house is considered 'new' (built in the last 5 years from sale))\\n# Input samples: 'HouseAge': [48, 13, 77] (HouseAge from previous block)\\ndf['IsNewHouse'] = (df['HouseAge'] <= 5).astype(int)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Add 1 to GarageCars to prevent division by zero for cases where Cars = 0 but Area > 0 (should not happen based on description, but good practice). Or just make it 0 for no garage/0 cars.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\", \"score\": -0.13365202713357074}, {\"update\": \"import numpy as np\\n\\n# (Log transformation of LotArea to handle skewness)\\n# Input samples: 'LotArea': [10000, 14541, 4500]\\ndf['LogLotArea'] = np.log1p(df['LotArea'])\\n\\n# (Total finished basement area)\\n# Input samples: 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['FinishedBsmtArea'] = df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# (Ratio of unfinished basement area to total basement area, handle cases with no basement)\\n# Input samples: 'BsmtUnfSF': [270, 326, 611], 'TotalBsmtSF': [864, 1338, 793]\\ndf['UnfinishedBsmtSF_Ratio'] = np.where(df['TotalBsmtSF'] > 0, df['BsmtUnfSF'] / df['TotalBsmtSF'], 0)\\n\\n# (Overall Quality combined with total rooms above ground)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotRmsAbvGrd': [6, 10, 6]\\ndf['OverallQual_x_TotRms'] = df['OverallQual'] * df['TotRmsAbvGrd']\\n\\n# (Interaction of kitchen count with total full bathrooms above ground)\\n# Input samples: 'KitchenAbvGr': [1, 1, 1], 'FullBath': [1, 2, 1]\\ndf['Kitchen_x_FullBath'] = df['KitchenAbvGr'] * df['FullBath']\\n\\n# (Combined score for fireplace quality and quantity)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0] (FireplaceQu_enc from accepted block)\\ndf['TotalFireplaceQual'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Binary flag indicating if the house was remodeled recently (e.g., within the last 10 years relative to sale year))\\n# Input samples: 'RemodAge': [26, 13, 9] (RemodAge from accepted block)\\ndf['IsRecentlyRemodeled'] = (df['RemodAge'] <= 10).astype(int)\\n\\n# (Ratio of low quality finished square footage to total above-grade living area, handle division by zero)\\n# Input samples: 'LowQualFinSF': [0, 0, 0], 'GrLivArea': [1144, 2520, 1520]\\ndf['LowQualRatio_to_GrLiv'] = df['LowQualFinSF'] / np.maximum(df['GrLivArea'], 1)\\n\\n# (Binary feature for Central Air conditioning presence)\\n# Input samples: 'CentralAir': ['Y', 'Y', 'Y', 'Y', 'Y']\\ndf['HasCentralAir'] = (df['CentralAir'] == 'Y').astype(int)\\n\\n# (Binary feature for certain unfavorable or feeding street conditions)\\n# Input samples: 'Condition1': ['Feedr', 'Norm', 'Norm', 'Norm', 'Norm']\\ndf['Condition_Unfavorable'] = df['Condition1'].apply(lambda x: 1 if x in ['Feedr', 'PosA', 'PosN', 'RRNn'] else 0)\", \"score\": -0.13319472683183448}, {\"update\": \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Log transformation of GrLivArea to handle skewness)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520]\\ndf['LogGrLivArea'] = np.log1p(df['GrLivArea'])\\n\\n# (Combined Condition Score: weighted sum of overall condition, exterior, basement, and garage condition)\\n# Input samples: 'OverallCond': [6, 7, 5], 'ExterCond_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3], 'GarageCond_enc': [3, 4, 3]\\n# Note: ExterCond_enc, BsmtCond_enc, GarageCond_enc were accepted in previous blocks.\\ndf['CombinedCondScore'] = df['OverallCond'] + df['ExterCond_enc'] + df['BsmtCond_enc'] + df['GarageCond_enc']\", \"score\": -0.13273066211438242}], \"predefined_state\": null, \"parent_score\": -0.13273066211438242, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0, 100.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1, NaN/None=0)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0 for no garage)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Assume GarageArea and GarageCars being 0 means no garage, leading to 0 AvgGarageAreaPerCar.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\\n\\n# (Interaction feature: Product of Overall Quality and Ground Living Area)\\n# Input samples: 'OverallQual': [5, 8, 5], 'GrLivArea': [1144, 2520, 1520]\\ndf['OverallQual_GrLivArea_Interaction'] = df['OverallQual'] * df['GrLivArea']\\n\\n# (Binary feature indicating the presence of a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\"]}, \"score\": -0.13694838914878676, \"memory_update\": \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0, 100.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1, NaN/None=0)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0 for no garage)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Average area per car in the garage. Handles cases where there's no garage or 0 cars)\\n# Input samples: 'GarageArea': [264, 796, 281], 'GarageCars': [1, 3, 1]\\n# Assume GarageArea and GarageCars being 0 means no garage, leading to 0 AvgGarageAreaPerCar.\\ndf['GaragePerCarArea'] = np.where(df['GarageCars'] > 0, df['GarageArea'] / df['GarageCars'], 0)\\n\\n# (Interaction feature: Product of Overall Quality and Ground Living Area)\\n# Input samples: 'OverallQual': [5, 8, 5], 'GrLivArea': [1144, 2520, 1520]\\ndf['OverallQual_GrLivArea_Interaction'] = df['OverallQual'] * df['GrLivArea']\\n\\n# (Binary feature indicating the presence of a pool)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\"}, {\"search_node\": {\"trial\": 23, \"parent_trial\": 4, \"memory\": [{\"update\": \"\", \"score\": -0.14098390849032688}, {\"update\": \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"score\": -0.13304342646742578}, {\"update\": \"import numpy as np\\n\\n# (Total combined square footage of all porches and decks)\\n# Input samples: 'WoodDeckSF': [165, 209, 0], 'OpenPorchSF': [0, 55, 0], 'EnclosedPorch': [0, 0, 56], '3SsnPorch': [0, 0, 0], 'ScreenPorch': [0, 0, 0]\\ndf['TotalPorchDeckSF'] = df['WoodDeckSF'] + df['OpenPorchSF'] + df['EnclosedPorch'] + df['3SsnPorch'] + df['ScreenPorch']\\n\\n# (Binary feature indicating the presence of a basement)\\n# Input samples: 'TotalBsmtSF': [864, 1338, 793, 1453, 894, 1902, 864, 1040, 1476, 672]\\ndf['HasBsmt'] = (df['TotalBsmtSF'] > 0).astype(int)\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Binary feature indicating the presence of any masonry veneer)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['HasMasVnr'] = (df['MasVnrArea_Imputed'] > 0).astype(int)\\n\\n# (Average square footage per room above ground)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'TotRmsAbvGrd': [6, 10, 6]\\n# Use np.maximum to prevent division by zero for TotRmsAbvGrd, though samples show non-zero.\\ndf['AvgRoomSF'] = df['GrLivArea'] / np.maximum(df['TotRmsAbvGrd'], 1)\\n\\n# (Numerical encoding of Garage Finish: Fin=3, RFn=2, Unf=1, NaN/None=0)\\n# Input samples: 'GarageFinish': ['RFn', 'RFn', 'Unf', 'RFn', 'Unf', 'Fin', 'Unf', 'Fin', 'RFn', 'Unf', nan]\\ngarage_finish_map = {'Fin': 3, 'RFn': 2, 'Unf': 1}\\ndf['GarageFinish_enc'] = df['GarageFinish'].map(garage_finish_map).fillna(0)\\n\\n# (Numerical encoding of Heating Quality: Ex=5, Gd=4, TA=3, Fa=2, Po=1)\\n# Input samples: 'HeatingQC': ['Ex', 'Ex', 'Ex', 'Ex', 'Ex', 'TA', 'Ex', 'Fa', 'Ex', 'Ex']\\nheating_qc_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\ndf['HeatingQC_enc'] = df['HeatingQC'].map(heating_qc_map).fillna(0) # NaNs should be extremely rare if any, fall back to 0\\n\\n# (Imputed LotFrontage: fill NaN values with the median of the column)\\n# Input samples: 'LotFrontage': [80.0, nan, 55.0, 72.0, 68.0]\\ndf['LotFrontage_Imputed'] = df['LotFrontage'].fillna(df['LotFrontage'].median())\\n\\n# (Density Factor: Ratio of above grade living area to lot area, avoiding division by zero)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'LotArea': [10000, 14541, 4500]\\n# Use np.maximum to prevent division by zero for LotArea.\\ndf['LotAreaDensity'] = df['GrLivArea'] / np.maximum(df['LotArea'], 1)\\n\\n# (Numerical encoding of Functional: Typ=7, Min1=6, Min2=5, Mod=4, Maj1=3, Maj2=2, Sev=1, Sal=0, NaN/Other=0)\\n# Input samples: 'Functional': ['Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ', 'Typ']\\nfunctional_map = {'Typ': 7, 'Min1': 6, 'Min2': 5, 'Mod': 4, 'Maj1': 3, 'Maj2': 2, 'Sev': 1, 'Sal': 0}\\ndf['Functional_enc'] = df['Functional'].map(functional_map).fillna(0) # Default to 0 for unknown or 'Sal' or NaN\", \"score\": -0.1346066602590829}, {\"update\": \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"score\": -0.13231140571525984}], \"predefined_state\": null, \"parent_score\": -0.13231140571525984, \"inspirations\": []}, \"state\": {\"generated_code\": [\"\", \"# (Total Living Area: sum of 1st floor, 2nd floor, and total basement square footage)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], '2ndFlrSF': [0, 1168, 672], 'TotalBsmtSF': [864, 1338, 793]\\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF'] + df['TotalBsmtSF']\\n\\n# (Total number of bathrooms in the house, combining full and half baths. Half baths are weighted as 0.5 of a full bath.)\\n# Input samples: 'BsmtFullBath': [1, 1, 0], 'BsmtHalfBath': [0, 0, 0], 'FullBath': [1, 2, 1], 'HalfBath': [0, 1, 0]\\ndf['TotalBath'] = df['BsmtFullBath'] + (df['BsmtHalfBath'] * 0.5) + df['FullBath'] + (df['HalfBath'] * 0.5)\\n\\n# (Age of the house when sold)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearBuilt': [1961, 1993, 1932]\\ndf['HouseAge'] = df['YrSold'] - df['YearBuilt']\\n\\n# (Years since the house was last remodeled or built, whichever is more recent)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'YearRemodAdd': [1983, 1993, 2000]\\ndf['RemodAge'] = df['YrSold'] - df['YearRemodAdd']\\n\\n# (Combined overall quality and condition score of the house)\\n# Input samples: 'OverallQual': [5, 8, 5], 'OverallCond': [6, 7, 5]\\ndf['OverallRating'] = df['OverallQual'] * df['OverallCond']\\n\\n# (Age of the garage when sold. NaNs in GarageYrBlt are imputed to 0, signifying no garage. A higher value will mean no garage/very old garage.)\\n# Input samples: 'YrSold': [2009, 2006, 2009], 'GarageYrBlt': [1961.0, 1993.0, 1968.0, 2003.0, 1999.0]\\n# Note: df['GarageYrBlt'].fillna(0) is used because NaNs correspond to houses without garages (consistent with samples of other Garage columns).\\ndf['GarageAge'] = df['YrSold'] - df['GarageYrBlt'].fillna(0)\\n\\n# Define a mapping for quality features (Excellent to Poor)\\nqual_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Quality, mapping NaN to 0 assuming lowest quality/no relevant feature)\\n# Input samples: 'ExterQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['ExterQual_enc'] = df['ExterQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Basement Quality, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtQual': ['TA', 'Gd', 'TA', 'Gd', 'TA', nan]\\ndf['BsmtQual_enc'] = df['BsmtQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Kitchen Quality)\\n# Input samples: 'KitchenQual': ['TA', 'Gd', 'TA', 'Gd', 'TA']\\ndf['KitchenQual_enc'] = df['KitchenQual'].map(qual_map).fillna(0)\\n\\n# (Numerical encoding of Fireplace Quality, mapping NaN to 0 assuming no fireplace)\\n# Input samples: 'FireplaceQu': ['TA', 'TA', nan, nan, nan, 'TA']\\ndf['FireplaceQu_enc'] = df['FireplaceQu'].map(qual_map).fillna(0)\\n\", \"import numpy as np\\n\\n# (Total finished living area: sum of above ground living area and finished basement square footage)\\n# Input samples: 'GrLivArea': [1144, 2520, 1520], 'BsmtFinSF1': [594, 1012, 182], 'BsmtFinSF2': [0, 0, 0]\\ndf['TotalFinishedSF'] = df['GrLivArea'] + df['BsmtFinSF1'] + df['BsmtFinSF2']\\n\\n# Define quality/condition mapping for ordinal features\\nqual_cond_map = {'Ex': 5, 'Gd': 4, 'TA': 3, 'Fa': 2, 'Po': 1}\\n\\n# (Numerical encoding of Exterior Condition, mapping NaN to 0 if any missing, though unlikely)\\n# Input samples: 'ExterCond': ['TA', 'Gd', 'TA', 'TA', 'TA']\\ndf['ExterCond_enc'] = df['ExterCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Condition, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtCond': ['TA', 'Gd', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['BsmtCond_enc'] = df['BsmtCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Quality, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageQual': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageQual_enc'] = df['GarageQual'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Garage Condition, mapping NaN to 0 assuming no garage)\\n# Input samples: 'GarageCond': ['TA', 'TA', 'TA', 'TA', 'TA', nan]\\ndf['GarageCond_enc'] = df['GarageCond'].map(qual_cond_map).fillna(0)\\n\\n# (Numerical encoding of Basement Exposure, mapping NaN to 0 assuming no basement)\\n# Input samples: 'BsmtExposure': ['No', 'No', 'No', 'Av', 'No', 'Av', nan]\\nbsmt_exposure_map = {'Gd': 4, 'Av': 3, 'Mn': 2, 'No': 1}\\ndf['BsmtExposure_enc'] = df['BsmtExposure'].map(bsmt_exposure_map).fillna(0)\\n\\n# (Binary feature indicating whether the driveway is paved)\\n# Input samples: 'PavedDrive': ['Y', 'Y', 'Y', 'Y', 'Y', 'N']\\ndf['IsPavedDrive'] = (df['PavedDrive'] == 'Y').astype(int)\\n\\n# (Numerical encoding of MasVnrType, mapping NaN to 0 for 'None')\\n# Input samples: 'MasVnrType': [nan, nan, nan, 'BrkFace', nan]\\nmasvnr_type_map = {'BrkCmn': 1, 'BrkFace': 2, 'CBlock': 1, 'Stone': 3, 'None': 0}\\ndf['MasVnrType_enc'] = df['MasVnrType'].map(masvnr_type_map).fillna(0) # 'None' corresponds to NaN in data\\n\\n# (Interaction feature: Combined quality/condition of Exterior and Basement, mapping NaN to 0 where no basement/exterior feature exists)\\n# Input samples: 'ExterQual_enc': [3, 4, 3], 'ExterCond_enc': [3, 4, 3], 'BsmtQual_enc': [3, 4, 3], 'BsmtCond_enc': [3, 4, 3]\\ndf['CombinedExtBsmtQual'] = (df['ExterQual_enc'] + df['ExterCond_enc']) * (df['BsmtQual_enc'] + df['BsmtCond_enc'])\", \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Lot Coverage: Ratio of the first floor area (approximate building footprint) to the total lot area)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], 'LotArea': [10000, 14541, 4500]\\ndf['LotCoverage'] = df['1stFlrSF'] / np.maximum(df['LotArea'], 1)\\n\\n# (Overall Quality x Total Finished Square Footage: An interaction term for quality and size)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotalSF': [2008, 3858, 1640]\\ndf['OverallSFQual'] = df['OverallQual'] * df['TotalSF']\\n\\n# (Foundation Type Encoded: Ordinal mapping of foundation types based on general strength/cost)\\n# Input samples: 'Foundation': ['CBlock', 'PConc', 'BrkTil', 'PConc', 'CBlock']\\nfoundation_map = {'PConc': 5, 'Stone': 4, 'Wood': 3, 'CBlock': 2, 'BrkTil': 1, 'Slab': 0}\\ndf['Foundation_enc'] = df['Foundation'].map(foundation_map).fillna(0)\\n\\n# (Bedroom Plus Bath: A simple sum indicating total key rooms)\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotalBath': [1.0, 3.5, 1.0]\\ndf['BedroomPlusBath'] = df['BedroomAbvGr'] + df['TotalBath']\\n\\n# (Years Since Last Major Change: Time elapsed between YearBuilt and YearRemodAdd. 0 if no remodel)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceMajorChange'] = df['YearRemodAdd'] - df['YearBuilt']\\n\\n# (MasVnr Area Ratio: Ratio of masonry veneer area to total finished square footage)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0], 'TotalSF': [2008, 3858, 1640]\\ndf['MasVnrAreaRatio'] = df['MasVnrArea_Imputed'] / np.maximum(df['TotalSF'], 1)\\n\\n# (Fireplace Quality x Number of Fireplaces: An interaction term combining presence and quality)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0]\\ndf['Fireplaces_x_Quality'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Has Pool Indicator: Binary flag if the house has a pool, based on PoolArea > 0)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Fence Indicator: Binary flag if the house has a fence, based on Fence column presence)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan]\\ndf['HasFence'] = df['Fence'].notna().astype(int)\"]}, \"score\": -0.13543195895967083, \"memory_update\": \"import numpy as np\\n\\n# (Imputed MasVnrArea: fill NaN values with 0, assuming no masonry veneer when data is missing)\\n# Input samples: 'MasVnrArea': [0.0, 0.0, 0.0, 167.0, 0.0]\\ndf['MasVnrArea_Imputed'] = df['MasVnrArea'].fillna(0)\\n\\n# (Lot Coverage: Ratio of the first floor area (approximate building footprint) to the total lot area)\\n# Input samples: '1stFlrSF': [1144, 1352, 848], 'LotArea': [10000, 14541, 4500]\\ndf['LotCoverage'] = df['1stFlrSF'] / np.maximum(df['LotArea'], 1)\\n\\n# (Overall Quality x Total Finished Square Footage: An interaction term for quality and size)\\n# Input samples: 'OverallQual': [5, 8, 5], 'TotalSF': [2008, 3858, 1640]\\ndf['OverallSFQual'] = df['OverallQual'] * df['TotalSF']\\n\\n# (Foundation Type Encoded: Ordinal mapping of foundation types based on general strength/cost)\\n# Input samples: 'Foundation': ['CBlock', 'PConc', 'BrkTil', 'PConc', 'CBlock']\\nfoundation_map = {'PConc': 5, 'Stone': 4, 'Wood': 3, 'CBlock': 2, 'BrkTil': 1, 'Slab': 0}\\ndf['Foundation_enc'] = df['Foundation'].map(foundation_map).fillna(0)\\n\\n# (Bedroom Plus Bath: A simple sum indicating total key rooms)\\n# Input samples: 'BedroomAbvGr': [3, 5, 3], 'TotalBath': [1.0, 3.5, 1.0]\\ndf['BedroomPlusBath'] = df['BedroomAbvGr'] + df['TotalBath']\\n\\n# (Years Since Last Major Change: Time elapsed between YearBuilt and YearRemodAdd. 0 if no remodel)\\n# Input samples: 'YearRemodAdd': [1983, 1993, 2000], 'YearBuilt': [1961, 1993, 1932]\\ndf['YearsSinceMajorChange'] = df['YearRemodAdd'] - df['YearBuilt']\\n\\n# (MasVnr Area Ratio: Ratio of masonry veneer area to total finished square footage)\\n# Input samples: 'MasVnrArea_Imputed': [0.0, 0.0, 0.0], 'TotalSF': [2008, 3858, 1640]\\ndf['MasVnrAreaRatio'] = df['MasVnrArea_Imputed'] / np.maximum(df['TotalSF'], 1)\\n\\n# (Fireplace Quality x Number of Fireplaces: An interaction term combining presence and quality)\\n# Input samples: 'Fireplaces': [1, 1, 0], 'FireplaceQu_enc': [3, 3, 0]\\ndf['Fireplaces_x_Quality'] = df['Fireplaces'] * df['FireplaceQu_enc']\\n\\n# (Has Pool Indicator: Binary flag if the house has a pool, based on PoolArea > 0)\\n# Input samples: 'PoolArea': [0, 0, 0, 0, 0]\\ndf['HasPool'] = (df['PoolArea'] > 0).astype(int)\\n\\n# (Has Fence Indicator: Binary flag if the house has a fence, based on Fence column presence)\\n# Input samples: 'Fence': ['GdWo', nan, nan, nan, nan]\\ndf['HasFence'] = df['Fence'].notna().astype(int)\"}]}"